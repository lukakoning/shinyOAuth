[{"path":"https://lukakoning.github.io/shinyOAuth/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 shinyOAuth authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Audit logging and hooks","text":"‘shinyOAuth’ emits structured audit events key steps OAuth 2.0/OIDC flow. may help detect anomalous activity (e.g., brute force, replay, configuration errors). vignette covers: - register audit hooks export/store events - audit events emitted & fields included event - Best practices","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"receiving-audit-events","dir":"Articles","previous_headings":"","what":"Receiving audit events","title":"Audit logging and hooks","text":"two hook options can set. receive event object (named list). functions register options fast, non-blocking, never throw errors. options(shinyOAuth.audit_hook = function(event) { ... }) - intended audit-specific sinks options(shinyOAuth.trace_hook = function(event) { ... }) - general-purpose tracing hook used audit events error traces Example printing audit events console: stop receiving events, unset option:","code":"options(shinyOAuth.audit_hook = function(event) {     cat(sprintf(\"[AUDIT] %s %s\\n\", event$type, event$trace_id))     str(event) }) options(shinyOAuth.audit_hook = NULL)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-structure","dir":"Articles","previous_headings":"","what":"Event structure","title":"Audit logging and hooks","text":"audit events share following base shape: type: string starting audit_... trace_id: short correlation id linking related records timestamp: POSIXct time event created (Sys.time()) Additional key/value fields depending event (see event catalog) events emitted within Shiny session, JSON-friendly shiny_session list attached every event correlate audit activity HTTP request session. structure designed directly serializable jsonlite::toJSON(): shiny_session$token: Shiny per-session token (session$token) available. method, path, query_string, host, scheme, remote_addr headers: list request headers derived HTTP_* environment variables, lowercase names (e.g., user_agent, x_forwarded_for). Note: raw session$request Shiny included keep event JSON-serializable concise. Note: shiny_session$http summary intentionally captures HTTP_* headers raw QUERY_STRING active Shiny request. forward events log sink, may include sensitive material authorization code, state, every request header (including Cookie, Authorization, bearer tokens). Consider stripping redacting sensitive headers query parameters hook exporting.","code":""},{"path":[]},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_redirect_issued","dir":"Articles","previous_headings":"Event catalog > Authorization redirect issuance","what":"Event: audit_redirect_issued","title":"Audit logging and hooks","text":": prepare_call() builds authorization URL Context: provider, issuer client_id_digest state_digest browser_token_digest pkce_method (e.g., S256, plain, NA) nonce_present (logical) scopes_count redirect_uri","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_callback_received","dir":"Articles","previous_headings":"Event catalog > Callback received","what":"Event: audit_callback_received","title":"Audit logging and hooks","text":": handle_callback() begins processing callback Context: provider, issuer, client_id_digest, code_digest, state_digest, browser_token_digest","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"callback-validation","dir":"Articles","previous_headings":"Event catalog","what":"Callback validation","title":"Audit logging and hooks","text":"Callback validation spans decryption + freshness + binding encrypted payload well subsequent checks values bound state (browser token, PKCE code verifier, nonce). check emits either success (payload) failure audit event.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_callback_validation_success","dir":"Articles","previous_headings":"Event catalog > Callback validation","what":"Event: audit_callback_validation_success","title":"Audit logging and hooks","text":": encrypted state payload decrypted verified freshness client/provider binding (emitted state_payload_decrypt_validate()) Context: provider, issuer, client_id_digest, state_digest","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_callback_validation_failed","dir":"Articles","previous_headings":"Event catalog > Callback validation","what":"Event: audit_callback_validation_failed","title":"Audit logging and hooks","text":": validation step fails prior token exchange Context: provider, issuer, client_id_digest, state_digest, phase, error_class (+ browser_token_digest phase browser_token_validation) Phases include: payload_validation, browser_token_validation, pkce_verifier_validation, nonce_validation Note: Failures related state store access (lookup/removal) reported events (see ) rather using callback_validation_failed event.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"state-store-access","dir":"Articles","previous_headings":"Event catalog","what":"State store access","title":"Audit logging and hooks","text":"State retrieval removal single-use state entry emitted separate events state_store_get_remove().","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_state_store_lookup_failed","dir":"Articles","previous_headings":"Event catalog > State store access","what":"Event: audit_state_store_lookup_failed","title":"Audit logging and hooks","text":": retrieving single-use state entry configured state_store fails (missing, malformed, underlying cache error) Context: provider, issuer, client_id_digest, state_digest, error_class, phase (state_store_lookup) Notes: flow aborts invalid state error.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_state_store_removal_failed","dir":"Articles","previous_headings":"Event catalog > State store access","what":"Event: audit_state_store_removal_failed","title":"Audit logging and hooks","text":": removal single-use state entry (enforcing one-time use) fails Context: provider, issuer, client_id_digest, state_digest, error_class, phase (state_store_removal) Notes: failure remove also aborts flow invalid state error; event emitted best-effort never throw. Digest differences: audit_callback_validation_failed payload decryption (phase = \"payload_validation\") state_digest computed encrypted payload (plaintext yet available). state store events digest reflects plaintext state string.","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_token_exchange","dir":"Articles","previous_headings":"Event catalog > Token exchange","what":"Event: audit_token_exchange","title":"Audit logging and hooks","text":": authorization code successfully exchanged tokens Context: provider, issuer, client_id_digest, code_digest, used_pkce, received_id_token, received_refresh_token","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_token_exchange_error","dir":"Articles","previous_headings":"Event catalog > Token exchange","what":"Event: audit_token_exchange_error","title":"Audit logging and hooks","text":": token exchange fails Context: provider, issuer, client_id_digest, code_digest, error_class","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_login_success","dir":"Articles","previous_headings":"Event catalog > Login result","what":"Event: audit_login_success","title":"Audit logging and hooks","text":": token set verified OAuthToken created Context: provider, issuer, client_id_digest, sub_digest, refresh_token_present, expires_at","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_login_failed","dir":"Articles","previous_headings":"Event catalog > Login result","what":"Event: audit_login_failed","title":"Audit logging and hooks","text":": surface-level login failure callback handling Shiny module Context: provider, issuer, client_id_digest, phase (sync_token_exchange|async_token_exchange), error_class","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_logout","dir":"Articles","previous_headings":"Event catalog > Logout and session clears","what":"Event: audit_logout","title":"Audit logging and hooks","text":": values$logout() called module Context: provider, issuer, client_id_digest, reason (default manual_logout)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_session_cleared","dir":"Articles","previous_headings":"Event catalog > Logout and session clears","what":"Event: audit_session_cleared","title":"Audit logging and hooks","text":": module clears token reactively Context: provider, issuer, client_id_digest, reason Reasons include: refresh_failed_async, refresh_failed_sync, reauth_window, token_expired","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_refresh_failed_but_kept_session","dir":"Articles","previous_headings":"Event catalog > Refresh failures while keeping the session (indefinite sessions)","what":"Event: audit_refresh_failed_but_kept_session","title":"Audit logging and hooks","text":": token refresh attempt fails module configured clear session (.e., indefinite_session = TRUE oauth_module_server()) Context: provider, issuer, client_id_digest, reason (refresh_failed_async|refresh_failed_sync), kept_token (TRUE), error_class","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_browser_cookie_error","dir":"Articles","previous_headings":"Event catalog > Browser cookie/WebCrypto error","what":"Event: audit_browser_cookie_error","title":"Audit logging and hooks","text":": browser reports set/read module cookie WebCrypto unavailable Context: provider, issuer, client_id_digest, reason, url_protocol Notes: typically indicates third-party cookies blocked, cookies disabled, WebCrypto API unavailable environment (e.g., old browsers restrictive embedded webviews).","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_invalid_browser_token","dir":"Articles","previous_headings":"Event catalog > Invalid browser token","what":"Event: audit_invalid_browser_token","title":"Audit logging and hooks","text":": module receives invalid shinyOAuth_sid value browser requests regeneration Context: provider, issuer, client_id_digest, reason, length","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_token_refresh","dir":"Articles","previous_headings":"Event catalog > Token refresh","what":"Event: audit_token_refresh","title":"Audit logging and hooks","text":": refresh_token() successfully refreshes access token Context: provider, issuer, client_id_digest, had_refresh_token, new_expires_at","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_userinfo","dir":"Articles","previous_headings":"Event catalog > Userinfo fetch","what":"Event: audit_userinfo","title":"Audit logging and hooks","text":": get_userinfo() successfully retrieves user information Context: provider, issuer, client_id_digest, sub_digest","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"state-parsing-failures","dir":"Articles","previous_headings":"Event catalog","what":"State parsing failures","title":"Audit logging and hooks","text":"State parsing failures occur decoding validating encrypted wrapper prior extracting logical state value.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_state_parse_failure","dir":"Articles","previous_headings":"Event catalog > State parsing failures","what":"Event: audit_state_parse_failure","title":"Audit logging and hooks","text":": encrypted state wrapper components fail validation/decoding Context: includes phase = decrypt, reason code (e.g., token_b64_invalid, iv_missing, tag_len_invalid), token_digest, additional details (lengths). Emitted best-effort parsing utilities never interferes control flow.","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_session_started","dir":"Articles","previous_headings":"Event catalog > Module/session lifecycle","what":"Event: audit_session_started","title":"Audit logging and hooks","text":": authentication module (oauth_module_server()) initialized Shiny session Context: module_id, ns_prefix, client_provider, client_issuer, client_id_digest, plus standard shiny_session context described ","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"where-to-find-these-in-code","dir":"Articles","previous_headings":"","what":"Where to find these in code","title":"Audit logging and hooks","text":"Redirect login audits emitted R/methods__login.R Module lifecycle/session audits emitted R/oauth_module_server.R events flow audit_event() defined R/errors.R, delegates hook options","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"best-practices-for-audit-hooks","dir":"Articles","previous_headings":"","what":"Best practices for audit hooks","title":"Audit logging and hooks","text":"Keep hooks fast never throw; wrap internals try(..., silent = TRUE) needed Export logging backend JSON easy parsing attempt reverse digests; use correlation Consider adding host/app identifier record exporting also want error traces, set options(shinyOAuth.trace_hook=...) Example JSON export hook:","code":"json_hook <- function(event) {     try({         line <- jsonlite::toJSON(event, auto_unbox = TRUE, null = \"null\")         cat(line, \"\\n\", file = \"shinyOAuth-audit.log\", append = TRUE)     }, silent = TRUE) }  options(shinyOAuth.audit_hook = json_hook)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Authentication flow","text":"vignette provides step--step description happens authentication flow using oauth_module_server() Shiny module. maps protocol concepts (OAuth 2.0 Authorization Code + PKCE, OpenID Connect) concrete implementation details package. concise quick-start (minimal manual button examples, options, security checklist) see: vignette(\"usage\", package = \"shinyOAuth\"). explanation logging key events flow, see: vignette(\"audit-logging\", package = \"shinyOAuth\").","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"what-happens-during-the-authentication-flow","dir":"Articles","previous_headings":"","what":"What happens during the authentication flow?","title":"Authentication flow","text":"package implements OAuth 2.0 Authorization Code flow (PKCE) optional OpenID Connect checks end‑‑end. sequence operations rationale behind step.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"first-page-load-set-a-browser-token","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"1. First page load: set a browser token","title":"Authentication flow","text":"first load app, module sets small random cookie user’s browser (SameSite=Strict; Secure HTTPS). browser token mirrored Shiny input. helps bind start end OAuth flow browser (“double-submit” style CSRF defense) prevents cross-tab confusion.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"decide-whether-to-start-login","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"2. Decide whether to start login","title":"Authentication flow","text":"oauth_module_server(auto_redirect = TRUE), unauthenticated session triggers immediate redirection. oauth_module_server(auto_redirect = FALSE), manually call $request_login() (e.g., via button) begin flow.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"build-the-authorization-url-prepare_call","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"3. Build the authorization URL (prepare_call())","title":"Authentication flow","text":"authorization request contains multiple high-entropy contextual elements: State: high-entropy random string prevent CSRF; sealed sent PKCE: code_verifier (random) code_challenge (S256 hash) proving party finishes flow Nonce (OIDC): random string echoed back ID token, mitigating replay attacks Server-side one-time state store: keyed cache-safe hash raw state (derived state satisfy cache backends); stores: browser token, code_verifier, nonce. Purged callback state, client_id, redirect_uri requested scopes provider fingerprint (issuer/auth/token URLs) issued_at timestamp sealing prevents tampering, stale callbacks, mix-ups providers/clients.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"app-redirects-to-the-provider","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"4. App redirects to the provider","title":"Authentication flow","text":"browser app user redirected provider’s authorization endpoint following parameters: response_type=code, client_id, redirect_uri, state=<sealed>, PKCE parameters, nonce (OIDC), scope, plus configured extra parameters.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"user-authenticates-and-authorizes","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"5. User authenticates and authorizes","title":"Authentication flow","text":"provider’s authorization page, user prompted log authorize app access requested scopes.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"provider-redirects-back","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"6. Provider redirects back","title":"Authentication flow","text":"provider redirects user’s browser back Shiny app (redirect_uri), including code state parameters (optionally error error_description failure).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"callback-processing-state-verification-handle_callback","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"7. Callback processing & state verification (handle_callback())","title":"Authentication flow","text":"Wait browser token input yet visible (page load race) proceeding Decrypt + verify sealed state: integrity (auth tag), authenticity, freshness (issued_at window) Check embedded context matches expected client/provider (defends misconfiguration / multi-tenant mix-ups) Strict semantics: entry missing, malformed, deletion fails, flow aborts shinyOAuth_state_error Audit events emitted failures (e.g., audit_state_store_lookup_failed, audit_state_store_removal_failed) redacted context Verify browser token equality stored value Ensure PKCE components available required Note: asynchronous token exchange mode, module may pre‑decrypt sealed state prefetch+remove state store entry main thread handing work async worker, preserving single‑use strict failure behavior.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"exchange-authorization-code-for-tokens","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"8. Exchange authorization code for tokens","title":"Authentication flow","text":"POST request made token endpoint grant_type=authorization_code, code, redirect_uri, code_verifier (PKCE). Client authentication method depends provider style: HTTP Basic header (client_secret_basic), body params (client_secret_post), JWT-based assertions (client_secret_jwt, private_key_jwt) configured. response must include least access_token. Malformed error responses abort flow. successful, package also applies two safety rails: token response includes scope, scopes requested client must present granted set; otherwise flow fails fast avoid downstream surprises. token response includes token_type, provider configured allowed_token_types, token_type must present response one allowed types (e.g., Bearer). Failure aborts flow.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"optional-fetch-userinfo","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"9. (Optional) Fetch userinfo","title":"Authentication flow","text":"oauth_provider(userinfo_required = TRUE), module calls userinfo endpoint access token stores returned claims. Failure aborts flow.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"oidc-validate-id-token","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"10. (OIDC) Validate ID token","title":"Authentication flow","text":"using oauth_provider(id_token_validation = TRUE), following verifications performed: Signature: verified provider JWKS (optional thumbprint pinning) RS256/ES256; HS256 explicit opt-server-held secret Claims: iss matches expected issuer; aud vector contains client_id; sub present; iat REQUIRED must single finite numeric; time-based claims (exp REQUIRED, nbf optional) evaluated small configurable leeway; tokens issued future rejected Nonce: used, matches stored value Subject match: oauth_provider(userinfo_id_token_match = TRUE), ensure sub userinfo equals ID token sub","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"materialize-the-oauthtoken","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"11. Materialize the OAuthToken","title":"Authentication flow","text":"Constructs S7 OAuthToken capturing access_token, optional refresh_token, expiry time, id_token, userinfo, verification results. $authenticated becomes TRUE requested verifications pass.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"clean-url-tidy-ui","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"12. Clean URL & tidy UI","title":"Authentication flow","text":"Removes OAuth query parameters (code, state, etc.) browser’s address bar optionally adjusts page title. Clears browser token cookie allow fresh future flow.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"keeping-the-session-alive","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"13. Keeping the session alive","title":"Authentication flow","text":"Proactive refresh: enabled refresh token exists, refresh expiry. Expiration & reauth: expired tokens cleared. Optional oauth_module_server(reauth_after_seconds = ...) forces periodic re-authentication.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"errors-logging-and-safety-rails","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"14. Errors, logging, and safety rails","title":"Authentication flow","text":"Structured errors surface short codes (optionally) detailed descriptions (avoid exposing full descriptions users) browser set session-binding cookie Web Crypto API unavailable, module surfaces browser_cookie_error concise description halts login attempts resolved Host HTTPS constraints enforced early State single‑use time‑limited; sealed state + cookie binding mitigate CSRF/state injection State store access strict: lookup removal failures cause flow abort shinyOAuth_state_error prevent replay/mix‑Hooks (trace_hook, audit_hook) provide structured telemetry without exposing raw tokens","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/example-spotify.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Example: Spotify login to display listening data","text":"vignette demonstrates code example Shiny application uses shinyOAuth package authenticate users via Spotify’s OAuth 2.0 service. logging , app fetches displays data user listening behaviour form simple dashboard built ‘bslib’. shows user’s profile information avatar, live view currently playing, top tracks artists, history recently played songs. detailed explanation use ‘shinyOAuth’ features, see: vignette(\"usage\", package = \"shinyOAuth\").","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/example-spotify.html","id":"code","dir":"Articles","previous_headings":"","what":"Code","title":"Example: Spotify login to display listening data","text":"","code":"# Example Shiny app using shinyOAuth to connect to Spotify API # # This app demonstrates logging into Spotify with shinyOAuth and fetching # various user statistics via the Spotify Web API. We then build a simple # dashboard to display this information # # Requirements: # - Create a Spotify OAuth 2.0 application at https://developer.spotify.com # - Add a redirect URI that matches redirect_uri below (default: http://127.0.0.1:8100) # - Set environment variables `SPOTIFY_OAUTH_CLIENT_ID` and `SPOTIFY_OAUTH_CLIENT_SECRET`  # Load packages & configure OAuth 2.0 client for Spotify -----------------------  library(shiny) library(shinyOAuth) library(bslib) library(ggplot2) library(DT)  # Configure provider and client for Spotify  provider <- oauth_provider_spotify(   # For Spotify, scopes have to be given in the authentication request itself;   # `oauth_provider_spotify()` handles this via the `scope` argument   scope = paste(     c(       \"user-read-email\",       \"user-read-private\",       \"user-top-read\",       \"user-read-recently-played\",       \"user-read-playback-state\",       \"user-read-currently-playing\"     ),     collapse = \" \"   ) )  client <- oauth_client(   provider = provider,   client_id = Sys.getenv(\"SPOTIFY_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"SPOTIFY_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )   # Spotify API helpers ----------------------------------------------------------  # Small helpers to call Spotify API with the user's access token # We define a few specialized functions for common endpoints  spotify_get <- function(token, path, query = list()) {   url <- paste0(\"https://api.spotify.com\", path)    req <- client_bearer_req(token, url, query = query)   resp <- req_with_retry(req)    if (httr2::resp_is_error(resp)) {     msg <- sprintf(\"Spotify API error: HTTP %s\", httr2::resp_status(resp))     stop(msg, call. = FALSE)   }    httr2::resp_body_json(resp, simplifyVector = TRUE) }  # Specialized helper for endpoints that may return 204 (e.g., currently-playing) spotify_get_maybe_empty <- function(token, path, query = list()) {   url <- paste0(\"https://api.spotify.com\", path)      req <- client_bearer_req(token, url, query = query)   resp <- req_with_retry(req)      status <- httr2::resp_status(resp)   if (status == 204L) {     return(NULL)   }      if (httr2::resp_is_error(resp)) {     msg <- sprintf(\"Spotify API error: HTTP %s\", status)     stop(msg, call. = FALSE)   }      httr2::resp_body_json(resp, simplifyVector = TRUE) }  # Fetch top tracks and artists (short_term: last 4 weeks) get_top_tracks <- function(token, limit = 10, time_range = \"short_term\") {   out <- spotify_get(     token,     \"/v1/me/top/tracks\",     query = list(limit = limit, time_range = time_range)   )    items <- out$items %||% list()   if (length(items) == 0) {     return(data.frame())   }    df <- purrr::map(seq_along(items), function(i) {     item <- items[i, ]     data.frame(       name = item$name %||% NA_character_,       artist = paste(item$artists[[1]]$name, collapse = \", \"),       album = item$album$name %||% NA_character_,       popularity = as.numeric(item$popularity) %||% NA_real_,       stringsAsFactors = FALSE     )   }) |>      dplyr::bind_rows()    df }  # Fetch top artists get_top_artists <- function(token, limit = 10, time_range = \"short_term\") {   out <- spotify_get(     token,     \"/v1/me/top/artists\",     query = list(limit = limit, time_range = time_range)   )    items <- out$items %||% list()   if (length(items) == 0) {     return(data.frame())   }    df <- purrr::map(seq_along(items), function(i) {     item <- items[i, ]     data.frame(       name = item$name %||% NA_character_,       genres = paste(         as.character(item$genres |> purrr::flatten() %||% character()),         collapse = \", \"       ),       popularity = as.numeric(item$popularity) %||% NA_real_,       followers = as.numeric(item$followers$total %||% NA_real_),       stringsAsFactors = FALSE     )   }) |>     dplyr::bind_rows()    df }  # Get recently played tracks get_recently_played <- function(token, limit = 20) {   out <- spotify_get(     token,     \"/v1/me/player/recently-played\",     query = list(limit = limit)   )    items <- out$items %||% list()   if (length(items) == 0) {     return(data.frame())   }    df <- purrr::map(seq_along(items), function(i) {     item <- items[i, ]     data.frame(       played_at = as.POSIXct(item$played_at %||% NA_character_, tz = \"UTC\"),       track = item$track$name %||% NA_character_,       artist = paste(item$track$artists[[1]]$name, collapse = \", \"),       album = item$track$album$name %||% NA_character_,       stringsAsFactors = FALSE     )   }) |>     dplyr::bind_rows()    df }  # Currently playing (may be NULL if nothing is playing) get_currently_playing <- function(token) {   out <- spotify_get_maybe_empty(token, \"/v1/me/player/currently-playing\")    if (is.null(out)) {     return(NULL)   }      # Normalize essential fields with guards   item <- out$item    if (is.null(item)) {     return(NULL)   }      artists <- tryCatch(     {       if (!is.null(item$artists) && length(item$artists) > 0) {         paste(item$artists$name, collapse = \", \")       } else {         \"—\"       }     },     error = function(e) \"—\"   )      art_url <- tryCatch(     {       item$album$images$url[[1]]     },     error = function(e) NULL   )      list(     is_playing = isTRUE(out$is_playing),     progress_ms = as.numeric(out$progress_ms %||% NA_real_),     duration_ms = as.numeric(item$duration_ms %||% NA_real_),     track = item$name %||% \"—\",     artist = artists,     album = item$album$name %||% \"—\",     art = art_url   ) }  # Helper to safely validate data frames returned from API calls safe_df <- function(x) {   if (inherits(x, \"try-error\")) {     return(NULL)   }      if (is.null(x) || !is.data.frame(x) || nrow(x) == 0) {     return(NULL)   }      x }  # Format milliseconds to m:ss format_ms <- function(ms) {   if (is.null(ms) || is.na(ms)) {     return(\"—\")   }      s <- round(as.numeric(ms) / 1000)      sprintf(\"%d:%02d\", s %/% 60, s %% 60) }   # Shiny app --------------------------------------------------------------------  ## Theme & CSS -----------------------------------------------------------------  # Some basic Bootstrap theming spotify_theme <- bs_theme(   version = 5,   base_font = font_google(\"Inter\"),   heading_font = font_google(\"Space Grotesk\"),   bg = \"#121212\",   fg = \"#F5F6F8\",   primary = \"#1DB954\",   secondary = \"#191414\",   success = \"#1ED760\",   \"navbar-bg\" = \"#0F0F0F\",   \"card-border-color\" = \"#1DB95433\" )  # Add CSS spotify_theme <- bs_add_rules(   spotify_theme,   paste(     \"body { background: radial-gradient(circle at top left, #1DB95411, #121212 55%); }\",     \".navbar-dark { border-bottom: 1px solid #1DB95422; }\",     \".card { background-color: #181818; border-radius: 18px; box-shadow: 0 18px 30px -24px rgba(0,0,0,0.7); transition: transform 0.2s, box-shadow 0.2s; }\",     \".card:hover { box-shadow: 0 20px 35px -20px rgba(29, 185, 84, 0.3); }\",     \".card-header { background-color: rgba(29, 185, 84, 0.08); border-bottom: 1px solid rgba(29, 185, 84, 0.2); font-weight: 600; }\",     \".profile-avatar { width: 72px; height: 72px; border-radius: 50%; object-fit: cover; box-shadow: 0 0 0 3px #1DB95455; transition: box-shadow 0.3s; }\",     \".profile-avatar:hover { box-shadow: 0 0 0 4px #1DB954; }\",     \".login-hero { min-height: 60vh; }\",     \".login-card { background: linear-gradient(130deg, #1DB954 0%, #1AA34A 55%, #121212 100%); color: #0C0C0C; border: none; }\",     \".login-card .btn { background-color: #121212; color: #F5F6F8; border: none; transition: all 0.3s; }\",     \".login-card .btn:hover { background-color: #0f0f0f; color: #1DB954; transform: scale(1.05); }\",     \".value-box { background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%); border: 1px solid #1DB95433; border-radius: 12px; transition: border-color 0.3s; padding: 0.6rem 0.9rem !important; }\",     \".value-box:hover { border-color: #1DB95466; }\",     \".value-box .value { font-size: 1.3rem; font-weight: 700; color: #1DB954; line-height: 1.2; }\",     \".value-box .value-box-title, .value-box h6, .value-box .title { font-size: 0.85rem; letter-spacing: .02em; opacity: .95; }\",     \".value-box p { margin-bottom: 0; font-size: 0.9rem; }\",     \".value-box .showcase-icon { color: #1DB954; opacity: 0.7; }\",     \".table { color: #F5F6F8; margin-bottom: 0; }\",     \".table thead { color: #1DB954; font-weight: 600; border-bottom: 2px solid #1DB95444; }\",     \".table tbody tr { transition: background-color 0.2s; }\",     \".table tbody tr:hover { background-color: rgba(29, 185, 84, 0.15); }\",     \".table td { vertical-align: middle; padding: 0.75rem; }\",     \".table td:first-child { color: #1DB954; font-weight: 600; width: 40px; text-align: center; }\",     \".control-card { background: rgba(16, 16, 16, 0.7); border: 1px solid #1DB95422; }\",     \".badge { font-size: 0.85rem; padding: 0.4em 0.8em; }\",     \".play-count-badge { background: linear-gradient(135deg, #1DB954 0%, #1AA34A 100%); color: #000; font-weight: 700; }\",     \".navbar .navbar-nav { display: none !important; }\",     sep = \"\\n\"   ) )  # Subtle readability and responsive polish overrides spotify_theme <- bs_add_rules(   spotify_theme,   paste(     \"/* Ensure cards don't collapse too small on narrow screens */\",     \".card { min-width: 300px; }\",     \"/* Avoid horizontal scroll within cards */\",     \".card .card-body { overflow-x: hidden; }\",     \"/* Add gap between cards in layout_columns */\",     \".bslib-grid { gap: 1rem !important; }\",     \"/* Ensure proper wrapping for cards - prevent cards from becoming too narrow */\",     \".bslib-grid > div { min-width: 300px; flex: 1 1 300px; }\",     \"/* Prevent value box containers from collapsing */\",     \".card-body .bslib-grid { display: flex; flex-wrap: wrap; }\",      \"/* Softer login gradient and better contrast */\",     \".login-card { background: linear-gradient(145deg, rgba(29,185,84,0.18) 0%, rgba(29,185,84,0.08) 38%, #1a1a1a 100%); color: #F5F6F8; border: 1px solid #1DB95422; overflow: hidden; }\",     \".login-card .btn { background-color: #121212; color: #F5F6F8; border: 1px solid #1DB95444; transition: background-color 0.25s, color 0.25s, box-shadow 0.25s; }\",     \".login-card .btn:hover { background-color: #0f0f0f; color: #1DB954; box-shadow: 0 8px 22px rgba(29,185,84,0.22); }\",     \".login-card .btn:focus, .login-card .btn:focus-visible { outline: none; box-shadow: 0 0 0 0.2rem rgba(29,185,84,0.35); }\",      \"/* Improve muted text contrast inside cards/value boxes */\",     \".card .text-muted, .value-box .text-muted { color: #CFD3D8 !important; }\",      \"/* DataTables dark theme tweaks */\",     \".dataTables_wrapper .dataTables_length select, .dataTables_wrapper .dataTables_filter input { background-color: #0f0f0f; color: #F5F6F8; border: 1px solid #1DB95433; }\",     \".dataTables_wrapper .dataTables_paginate .paginate_button { color: #F5F6F8 !important; border: 1px solid transparent; }\",     \".dataTables_wrapper .dataTables_paginate .paginate_button.current, .dataTables_wrapper .dataTables_paginate .paginate_button:hover { color: #1DB954 !important; background: #0f0f0f; border-color: #1DB95433; }\",     \".dataTables_wrapper .dataTables_info { color: #E4E7EB; }\",      \"/* Slightly more visible table header border for clarity */\",     \".table thead { border-bottom: 2px solid #1DB95455; }\",      \"/* Custom Spotify outline button (for Sign out) */\",     \".btn-spotify-outline { color: #1DB954; border: 1px solid #1DB95499; background: transparent; }\",     \".btn-spotify-outline:hover { color: #0b0b0b; background: #1DB954; border-color: #1DB954; }\",      \"/* Plan badge for better readability */\",     \".badge-plan { background: transparent; border: 1px solid #1DB95466; color: #F5F6F8; }\",      \"/* Sidebar toggle visibility */\",     \".layout-sidebar .collapse-toggle, .layout-sidebar .sidebar-toggle, .bslib-sidebar-layout .collapse-toggle { color: #F5F6F8; border: 1px solid #1DB95455; background: #0f0f0f; }\",     \".layout-sidebar .collapse-toggle:hover, .layout-sidebar .sidebar-toggle:hover, .bslib-sidebar-layout .collapse-toggle:hover { border-color: #1DB954aa; color: #1DB954; }\",      \"/* Value box compact sizing and min width with proper wrapping */\",     \".value-box { min-width: 220px; margin-bottom: 0.75rem; flex: 1 1 220px; }\",     \".value-box .showcase-top, .value-box .showcase-bottom, .value-box .showcase-area { gap: .5rem; }\",     \".value-box .showcase-icon { font-size: 0.95rem; }\",     \"/* Prevent value box text overflow */\",     \".value-box .value { word-break: break-word; font-size: 1.1rem !important; }\",     \".value-box p { word-break: break-word; overflow-wrap: break-word; font-size: 0.85rem; }\",     \".value-box .title, .value-box h6 { font-size: 0.8rem; }\",      \"/* Now playing artwork sizing */\",     \".now-playing-art { width: 80px; height: 80px; object-fit: cover; border-radius: 8px; box-shadow: 0 8px 18px rgba(0,0,0,.35); }\",      sep = \"\\n\"   ) )   ## UI --------------------------------------------------------------------------  ui <- bslib::page_fluid(   title = tags$span(     class = \"d-flex align-items-center gap-2\",     icon(\"headphones\"),     span(class = \"fw-semibold\", \"Spotify Listening Studio\")   ),   theme = spotify_theme,   use_shinyOAuth(),   div(     class = \"pt-4 pb-5\",     uiOutput(\"oauth_error\"),     conditionalPanel(       condition = \"output.isAuthenticated\",       layout_sidebar(         sidebar = sidebar(           card(             class = \"control-card\",             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"sliders-h\"),               span(\"Personalize view\")             )),             card_body(               selectInput(                 \"time_range\",                 \"Listening window\",                 choices = c(                   \"Last 4 weeks\" = \"short_term\",                   \"Last 6 months\" = \"medium_term\",                   \"All-time favorites\" = \"long_term\"                 ),                 selected = \"short_term\"               ),               sliderInput(                 \"top_limit\",                 \"Top items\",                 min = 5,                 max = 20,                 value = 10,                 step = 1               )             ),             card_footer(tags$small(               class = \"text-muted\",               \"Adjust filters to explore different eras of your listening.\"             ))           ),           width = 320,           open = TRUE         ),         fillable = TRUE,         layout_column_wrap(           width = \"350px\",           heights_equal = \"row\",           card(             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"user\"),               span(\"Profile\")             )),             card_body(uiOutput(\"profile\"))           ),           card(             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"play-circle\"),               span(\"Listening sessions\")             )),             card_body(uiOutput(\"summary_boxes\"))           ),           card(             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"broadcast-tower\"),               span(\"Now playing\")             )),             card_body(uiOutput(\"now_playing\"))           )         ),         layout_column_wrap(           width = \"400px\",           fill = TRUE,           card(             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"music\"),               span(\"Top tracks\")             )),             card_body(DTOutput(\"top_tracks\"))           ),           card(             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"users\"),               span(\"Top artists\")             )),             card_body(DTOutput(\"top_artists\"))           )         ),         layout_column_wrap(           width = NULL,           fill = TRUE,           style = css(grid_template_columns = \"3fr 2fr\"),           card(             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"history\"),               span(\"Recent plays\")             )),             card_body(DTOutput(\"recent\"))           ),           card(             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"chart-bar\"),               span(\"Artists on repeat\")             )),             card_body(plotOutput(\"recent_artist_plot\", height = \"400px\"))           )         )       )     ),     conditionalPanel(       condition = \"!output.isAuthenticated\",       div(         class = \"login-hero d-flex justify-content-center align-items-center\",         card(           class = \"login-card text-center p-5\",           card_body(             icon(\"headphones\", class = \"display-4 mb-3\"),             h2(\"Spotify Listening Studio\"),             p(               class = \"lead\",               \"Sign in to reveal your personal soundtrack: relive your top tracks, spotlight your favorite artists, and surface the songs you can't stop replaying.\"             ),             actionButton(               \"login\",               \"Sign in with Spotify\",               class = \"btn btn-lg px-4 py-3 mt-2\"             ),             div(               class = \"mt-3 small\",               tags$strong(\"Scopes:\"),               \" user-top-read • user-read-recently-played • user-read-email • user-read-private\"             )           )         )       )     )   ) )   ## Server ----------------------------------------------------------------------  server <- function(input, output, session) {   # Handle Spotify login -------------------------------------------------------    auth <- oauth_module_server(\"auth\", client, auto_redirect = FALSE)    # Expose auth state to JS for our conditionalPanel   output$isAuthenticated <- shiny::reactive({     isTRUE(auth$authenticated)   })   shiny::outputOptions(output, \"isAuthenticated\", suspendWhenHidden = FALSE)    observeEvent(input$login, {     auth$request_login()   })    observeEvent(input$logout, {     req(isTRUE(auth$authenticated))     auth$logout()   })    output$oauth_error <- renderUI({     if (!is.null(auth$error)) {       msg <- auth$error       if (!is.null(auth$error_description)) {         msg <- paste0(msg, \": \", auth$error_description)       }       div(class = \"alert alert-danger\", role = \"alert\", msg)     }   })    # Show user profile ----------------------------------------------------------    output$profile <- renderUI({     req(auth$token)     user_info <- auth$token@userinfo     if (length(user_info) == 0) {       return(div(class = \"text-muted\", \"No user info\"))     }      avatar <- NULL     if (       !is.null(user_info$images) &&         is.data.frame(user_info$images) &&         nrow(user_info$images) > 0     ) {       img_url <- user_info$images$url[[1]]       if (!is.null(img_url) && nzchar(img_url)) {         avatar <- tags$img(           src = img_url,           class = \"profile-avatar\",           alt = \"User avatar\"         )       }     }      display_name <- user_info$display_name %||% user_info$id %||% \"<unknown>\"      followers_badge <- NULL     if (       !is.null(user_info$followers) &&         is.list(user_info$followers) &&         !is.null(user_info$followers$total)     ) {       followers_badge <- span(         class = \"badge bg-success-subtle text-success-emphasis\",         \"Followers:\",         tags$span(           class = \"ms-1\",           format(user_info$followers$total, big.mark = \",\")         )       )     }      plan_badge <- NULL     if (!is.null(user_info$product)) {       plan_badge <- span(         class = \"badge badge-plan\",         paste(\"Plan:\", user_info$product)       )     }      country_badge <- NULL     if (!is.null(user_info$country)) {       country_badge <- span(         class = \"badge bg-dark border border-success\",         paste(\"Country:\", user_info$country)       )     }      spotify_link <- NULL     if (       !is.null(user_info$external_urls) &&         is.list(user_info$external_urls) &&         !is.null(user_info$external_urls$spotify)     ) {       spotify_link <- a(         icon(\"external-link-alt\", class = \"ms-2\"),         href = user_info$external_urls$spotify,         class = \"text-decoration-none text-success\",         target = \"_blank\",         title = \"Open in Spotify\"       )     }      tagList(       div(         class = \"d-flex align-items-center gap-3 flex-wrap\",         avatar,         div(           h4(class = \"mb-1\", display_name, spotify_link),           if (!is.null(user_info$email)) {             span(class = \"text-muted\", user_info$email)           }         ),         div(           class = \"ms-auto\",           actionButton(             \"logout\",             \"Sign out\",             class = \"btn btn-spotify-outline btn-sm\"           )         )       ),       hr(class = \"border-success-subtle\"),       div(         class = \"d-flex flex-wrap gap-2\",         followers_badge,         plan_badge,         country_badge       )     )   })    # Reactives containing Spotify data ------------------------------------------    # Data fetch reactives   top_tracks <- reactive({     req(auth$token, input$time_range, input$top_limit)     try(       get_top_tracks(         auth$token,         limit = input$top_limit,         time_range = input$time_range       ),       silent = FALSE     )   })    top_artists <- reactive({     req(auth$token, input$time_range, input$top_limit)     try(       get_top_artists(         auth$token,         limit = input$top_limit,         time_range = input$time_range       ),       silent = FALSE     )   })    recent <- reactive({     req(auth$token)     try(get_recently_played(auth$token, limit = 50), silent = FALSE)   })    summary_data <- reactive({     tracks_df <- safe_df(top_tracks())     artists_df <- safe_df(top_artists())     recent_df <- safe_df(recent())      list(       top_track = if (!is.null(tracks_df)) {         list(           name = tracks_df$name[1] %||% \"—\",           artist = tracks_df$artist[1] %||% \"—\"         )       } else {         NULL       },       top_artist = if (!is.null(artists_df)) {         list(           name = artists_df$name[1] %||% \"—\",           genres = if (             !is.null(artists_df$genres[1]) && nzchar(artists_df$genres[1])           ) {             artists_df$genres[1]           } else {             \"—\"           }         )       } else {         NULL       },       last_play = if (!is.null(recent_df)) {         list(           track = recent_df$track[1] %||% \"—\",           artist = recent_df$artist[1] %||% \"—\",           played_at = recent_df$played_at[1]         )       } else {         NULL       },       unique_recent = if (!is.null(recent_df)) {         dplyr::n_distinct(recent_df$artist)       } else {         NA_integer_       }     )   })    # Summary cards --------------------------------------------------------------    # These show a few different summary stats about the user's listening    output$summary_boxes <- renderUI({     data <- summary_data()      top_track <- data$top_track     top_artist <- data$top_artist     last_play <- data$last_play      top_track_name <- if (!is.null(top_track)) top_track$name else \"—\"     top_track_artist <- if (!is.null(top_track)) {       top_track$artist     } else {       \"No data for this window\"     }      top_artist_name <- if (!is.null(top_artist)) top_artist$name else \"—\"     top_artist_genres <- if (!is.null(top_artist)) {       top_artist$genres     } else {       \"No genres available\"     }      last_track_name <- if (!is.null(last_play)) last_play$track else \"—\"     last_track_details <- if (!is.null(last_play)) {       parts <- c(last_play$artist %||% \"—\")       if (!is.null(last_play$played_at) && !is.na(last_play$played_at)) {         parts <- c(parts, format(last_play$played_at, \"%b %d • %H:%M\", tz = \"\"))       }       paste(parts, collapse = \"  |  \")     } else {       \"No recent playback\"     }      unique_recent <- data$unique_recent     unique_recent_value <- if (!is.na(unique_recent)) unique_recent else \"—\"      layout_column_wrap(       width = \"220px\",       value_box(         title = \"Top Track\",         value = top_track_name,         showcase = icon(\"music\"),         p(class = \"text-muted\", top_track_artist)       ),       value_box(         title = \"Top Artist\",         value = top_artist_name,         showcase = icon(\"star\"),         p(class = \"text-muted\", top_artist_genres)       ),       value_box(         title = \"Recent Session\",         value = last_track_name,         showcase = icon(\"clock\"),         p(class = \"text-muted\", last_track_details)       ),       value_box(         title = \"Unique Artists (recent)\",         value = unique_recent_value,         showcase = icon(\"users\"),         p(class = \"text-muted\", \"Across your latest 50 plays\")       )     )   })    # Top tracks -----------------------------------------------------------------    # Shows the user's top tracks in a data table    output$top_tracks <- renderDT({     df <- top_tracks()     shiny::validate(       need(!inherits(df, \"try-error\"), \"Failed to load top tracks\"),       need(!is.null(df) && nrow(df) > 0, \"No tracks returned for this window\")     )      # Calculate play counts from recent plays     recent_df <- safe_df(recent())     if (!is.null(recent_df)) {       recent_df$key <- paste0(recent_df$track, \" — \", recent_df$artist)       df$key <- paste0(df$name, \" — \", df$artist)       play_counts <- table(recent_df$key)       df$plays <- vapply(         df$key,         function(k) {           count <- suppressWarnings(play_counts[k])           if (is.na(count)) 0L else as.integer(count)         },         integer(1)       )     } else {       df$plays <- 0L     }      # Drop rows that are entirely missing name & artist     keep <- (!is.na(df$name) & nzchar(df$name)) |       (!is.na(df$artist) & nzchar(df$artist))     df <- df[keep, , drop = FALSE]      df <- df[, c(\"name\", \"artist\", \"album\", \"plays\", \"popularity\")]     df$plays <- ifelse(df$plays > 0, sprintf(\"🔁 %d\", df$plays), \"—\")     df$popularity <- ifelse(       is.na(df$popularity),       \"—\",       sprintf(\"⭐ %d\", round(df$popularity))     )      # Add rank numbers     df <- cbind(`#` = seq_len(nrow(df)), df)      df <- stats::setNames(       df,       c(\"#\", \"Track\", \"Artist\", \"Album\", \"Recent Plays\", \"Popularity\")     )     datatable(       df,       rownames = FALSE,       escape = FALSE,       options = list(         pageLength = 10,         lengthChange = FALSE,         order = list(list(0, 'asc')),         columnDefs = list(           list(orderable = FALSE, targets = 0)         )       )     )   })    # Top artists ----------------------------------------------------------------    # Shows the user's top artists in a data table    output$top_artists <- renderDT({     df <- top_artists()     shiny::validate(       need(!inherits(df, \"try-error\"), \"Failed to load top artists\"),       need(!is.null(df) && nrow(df) > 0, \"No artists returned for this window\")     )     df <- df[, c(\"name\", \"genres\", \"popularity\", \"followers\")]     df$genres[df$genres == \"\"] <- \"—\"     df$genres <- vapply(       df$genres,       function(g) {         if (nchar(g) > 50) paste0(substr(g, 1, 47), \"...\") else g       },       character(1)     )     df$popularity <- ifelse(       is.na(df$popularity),       \"—\",       sprintf(\"⭐ %d\", round(df$popularity))     )     df$followers <- ifelse(       is.na(df$followers),       \"—\",       paste0(\"👥 \", format(round(df$followers), big.mark = \",\"))     )      # Add rank numbers     df <- cbind(`#` = seq_len(nrow(df)), df)      df <- stats::setNames(       df,       c(\"#\", \"Artist\", \"Genres\", \"Popularity\", \"Followers\")     )     datatable(       df,       rownames = FALSE,       escape = FALSE,       options = list(         pageLength = 10,         lengthChange = FALSE,         order = list(list(0, 'asc')),         columnDefs = list(           list(orderable = FALSE, targets = 0)         )       )     )   })    # Recent plays ---------------------------------------------------------------    # Shows the user's recent plays in a data table    output$recent <- renderDT({     df <- recent()     shiny::validate(       need(!inherits(df, \"try-error\"), \"Failed to load recent plays\"),       need(!is.null(df) && nrow(df) > 0, \"No recent plays available\")     )     df$played <- format(df$played_at, \"%b %d • %H:%M\", tz = \"\")     df <- df[, c(\"played\", \"track\", \"artist\", \"album\")]      # Add rank numbers     df <- cbind(`#` = seq_len(nrow(df)), df)     df <- stats::setNames(df, c(\"#\", \"Played\", \"Track\", \"Artist\", \"Album\"))     datatable(       df,       rownames = FALSE,       options = list(         pageLength = 10,         lengthChange = FALSE,         order = list(list(0, 'desc')),         columnDefs = list(           list(orderable = FALSE, targets = 0)         )       )     )   })    # Recent artists plot --------------------------------------------------------    # Bar plot of most frequently played artists in recent plays    output$recent_artist_plot <- renderPlot({     df_recent <- recent()     shiny::validate(       need(!inherits(df_recent, \"try-error\"), \"Failed to load recent plays\"),       need(         !is.null(df_recent) && nrow(df_recent) > 0,         \"No recent plays available\"       )     )      # Primary: counts from recent plays     counts <- sort(table(df_recent$artist), decreasing = TRUE)     counts_df <- data.frame(       artist = names(counts),       plays = as.numeric(counts),       stringsAsFactors = FALSE     )      # If the recent signal is weak (<= 3 artists or max <= 1), fall back to time-range top artists by popularity     use_fallback <- nrow(counts_df) <= 3 ||       max(counts_df$plays, na.rm = TRUE) <= 1     if (isTRUE(use_fallback)) {       df_top <- safe_df(top_artists())       if (!is.null(df_top) && nrow(df_top) > 0) {         counts_df <- df_top[, c(\"name\", \"popularity\")]         names(counts_df) <- c(\"artist\", \"plays\")       }     }      # Take top 10 and order for plotting     counts_df <- utils::head(       counts_df[order(counts_df$plays, decreasing = TRUE), ],       10L     )     counts_df$artist <- factor(counts_df$artist, levels = rev(counts_df$artist))      x_lab <- if (isTRUE(use_fallback)) \"Popularity\" else \"Plays (last 50)\"      ggplot(counts_df, aes_string(x = \"plays\", y = \"artist\")) +       geom_col(fill = \"#1DB954\", width = 0.65) +       geom_text(aes(label = plays), hjust = -0.2, color = \"#F5F6F8\", size = 4) +       scale_x_continuous(expand = expansion(mult = c(0, 0.08))) +       labs(x = x_lab, y = NULL) +       theme_minimal(base_family = \"Inter\", base_size = 13) +       theme(         plot.background = element_rect(fill = \"#181818\", colour = NA),         panel.background = element_rect(fill = \"#181818\", colour = NA),         panel.grid.major.y = element_blank(),         panel.grid.major.x = element_line(colour = \"#FFFFFF22\"),         text = element_text(colour = \"#F5F6F8\"),         axis.text.y = element_text(colour = \"#F5F6F8\", size = 12),         axis.text.x = element_text(colour = \"#F5F6F8\", size = 11),         plot.margin = margin(10, 20, 10, 20)       )   })    # Now playing ----------------------------------------------------------------    # Shows the user's currently playing track with a progress bar    output$now_playing <- renderUI({     req(auth$token)     # refresh every 5 seconds     invalidateLater(5000, session)     playing <- try(get_currently_playing(auth$token), silent = FALSE)     if (inherits(playing, \"try-error\") || is.null(playing)) {       return(div(class = \"text-muted\", \"Nothing playing right now\"))     }      pct <- NA_real_     if (       !is.na(playing$progress_ms) &&         !is.na(playing$duration_ms) &&         playing$duration_ms > 0     ) {       pct <- max(         0,         min(100, round(playing$progress_ms / playing$duration_ms * 100))       )     }      progress_bar <- NULL     if (!is.na(pct)) {       progress_bar <- div(         class = \"progress mt-2\",         div(           class = \"progress-bar bg-success\",           role = \"progressbar\",           style = paste0(\"width: \", pct, \"%\"),           `aria-valuenow` = pct,           `aria-valuemin` = 0,           `aria-valuemax` = 100         )       )     }      time_label <- span(       class = \"small text-muted\",       paste(format_ms(playing$progress_ms), \"/\", format_ms(playing$duration_ms))     )      tagList(       div(         class = \"d-flex gap-3 align-items-center\",         if (!is.null(playing$art)) {           tags$img(             src = playing$art,             class = \"now-playing-art\",             alt = \"Album art\"           )         },         div(           div(class = \"fw-semibold\", playing$track),           div(class = \"text-muted\", paste(playing$artist, \"•\", playing$album))         )       ),       progress_bar,       div(class = \"d-flex justify-content-end\", time_label)     )   }) }   # Run app ----------------------------------------------------------------------  shiny::runApp(shinyApp(ui, server), port = 8100)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Usage","text":"‘shinyOAuth’ implements provider‑agnostic OAuth 2.0 OpenID Connect (OIDC) authorization/authentication Shiny apps, modern S7 classes secure defaults. streamlines full authorization/authentication flow, including: Building authorization URLs redirecting unauthenticated users State, nonce, PKCE generation, sealing, verification Authorization code exchange token validation Optional userinfo retrieval & ID token signature/claims validation Proactive token refresh re‑authentication triggers full step--step protocol breakdown, see separate vignette: vignette(\"authentication-flow\", package = \"shinyOAuth\"). detailed explanation audit logging key events flow, see: vignette(\"audit-logging\", package = \"shinyOAuth\").","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"minimal-shiny-module-example","dir":"Articles","previous_headings":"","what":"Minimal Shiny module example","title":"Usage","text":"minimal example using GitHub’s OAuth 2.0 app (shown README). Register OAuth application https://github.com/settings/developers set environment variables GITHUB_OAUTH_CLIENT_ID GITHUB_OAUTH_CLIENT_SECRET. Note ui includes use_shinyOAuth() load necessary JavaScript dependency. Always place use_shinyOAuth() UI; otherwise, module function. may place near top-level UI (e.g., inside fluidPage(), tagList(), bslib::page()).","code":"library(shiny) library(shinyOAuth)  provider <- oauth_provider_github()  client <- oauth_client(   provider = provider,   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\",   scopes = c(\"read:user\", \"user:email\") )  ui <- fluidPage(   # Include JavaScript dependency:   use_shinyOAuth(),   # Render login status & user info:   uiOutput(\"login\") )  server <- function(input, output, session) {   auth <- oauth_module_server(\"auth\", client, auto_redirect = TRUE)   output$login <- renderUI({     if (auth$authenticated) {       user_info <- auth$token@userinfo       tagList(         tags$p(\"You are logged in!\"),         tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))       )     } else {       tags$p(\"You are not logged in.\")     }   }) }  # runApp(shinyApp(ui, server), port = 8100)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"manual-login-button-variant","dir":"Articles","previous_headings":"","what":"Manual login button variant","title":"Usage","text":"example user clicks button start login process instead redirected immediately page load.","code":"library(shiny) library(shinyOAuth)  provider <- oauth_provider_github()  client <- oauth_client(   provider = provider,   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\",   scopes = c(\"read:user\", \"user:email\") )  ui <- fluidPage(   use_shinyOAuth(),   actionButton(\"login_btn\", \"Login\"),   uiOutput(\"login\") )  server <- function(input, output, session) {   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = FALSE   )    observeEvent(input$login_btn, {     auth$request_login()   })    output$login <- renderUI({     if (auth$authenticated) {       user_info <- auth$token@userinfo       tagList(         tags$p(\"You are logged in!\"),         tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))       )     } else {       tags$p(\"You are not logged in.\")     }   }) }  runApp(shinyApp(ui, server), port = 8100)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"making-authenticated-api-calls","dir":"Articles","previous_headings":"","what":"Making authenticated API calls","title":"Usage","text":"authenticated, may want call API behalf user using access token. Use client_bearer_req() quickly build authorized httr2 request correct Bearer token. See example app ; calls GitHub API obtain user’s repositories. example application fetches data Spotify web API, see: vignette(\"example-spotify\", package = \"shinyOAuth\").","code":"library(shiny) library(shinyOAuth)  provider <- oauth_provider_github()  client <- oauth_client(   provider = provider,   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\",   scopes = c(\"read:user\", \"user:email\") )  ui <- fluidPage(   use_shinyOAuth(),   uiOutput(\"ui\") )  server <- function(input, output, session) {   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = TRUE   )      repositories <- reactiveVal(NULL)      observe({     req(auth$authenticated)          # Example additional API request using the access token     # (e.g., fetch user repositories from GitHub)     req <- client_bearer_req(auth$token, \"https://api.github.com/user/repos\")     resp <- httr2::req_perform(req)          if (httr2::resp_is_error(resp)) {       repositories(NULL)     } else {       repos_data <- httr2::resp_body_json(resp, simplifyVector = TRUE)       repositories(repos_data)     }   })      # Render username + their repositories   output$ui <- renderUI({     if (isTRUE(auth$authenticated)) {       user_info <- auth$token@userinfo       repos <- repositories()              return(tagList(         tags$p(paste(\"You are logged in as:\", user_info$login)),         tags$h4(\"Your repositories:\"),         if (!is.null(repos)) {           tags$ul(             Map(function(url, name) {               tags$li(tags$a(href = url, target = \"_blank\", name))             }, repos$html_url, repos$full_name)           )         } else {           tags$p(\"Loading repositories...\")         }       ))     }          return(tags$p(\"You are not logged in.\"))   }) }  runApp(shinyApp(ui, server), port = 8100)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"async-mode-to-keep-ui-responsive","dir":"Articles","previous_headings":"","what":"Async mode to keep UI responsive","title":"Usage","text":"default, oauth_module_server() performs network operations (authorization code exchange, refresh, userinfo) main R thread. transient network errors package retries backoff, sleeping main thread can block Shiny event loop worker process. avoid blocking, enable async mode configure future backend: need keep async = FALSE, may consider reducing retry behaviour limit blocking provider incidents. See ‘Global options’ ‘HTTP timeout/retries’.","code":"# in global.R or at app startup # Use a background process pool for promises future::plan(future::multisession)  server <- function(input, output, session) {   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = TRUE,     async = TRUE # Run token exchange/refresh off the main thread   )      # ... }"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"global-options","dir":"Articles","previous_headings":"","what":"Global options","title":"Usage","text":"package provides several global options customize behavior. list available options.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"observabilitylogging","dir":"Articles","previous_headings":"Global options","what":"Observability/logging","title":"Usage","text":"options(shinyOAuth.print_errors = TRUE) – concise error lines (interactive / tests ) options(shinyOAuth.print_traceback = TRUE) – include backtraces (interactive / tests ) options(shinyOAuth.expose_error_body = TRUE) – include sanitized HTTP bodies (may reveal details) options(shinyOAuth.trace_hook = function(event){ ... }) – structured events (errors, http, etc.) options(shinyOAuth.audit_hook = function(event){ ... }) – separate audit stream See vignette(\"audit-logging\", package = \"shinyOAuth\") details audit trace hooks.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"networkingsecurity","dir":"Articles","previous_headings":"Global options","what":"Networking/security","title":"Usage","text":"options(shinyOAuth.leeway = 30) – default ID token exp/iat leeway seconds options(shinyOAuth.allowed_non_https_hosts = c(\"localhost\", \"127.0.0.1\", \"::1\")) - allows hosts use http:// scheme instead https:// options(shinyOAuth.allowed_hosts = c()) – non‑empty, restricts accepted hosts whitelist options(shinyOAuth.allow_hs = TRUE) – opt‑HMAC validation ID tokens (HS256/HS384/HS512). Requires strictly server‑side client_secret options(shinyOAuth.client_assertion_ttl = 300L) – lifetime seconds JWT client assertions used client_secret_jwt private_key_jwt token endpoint authentication. Values 60 seconds coerced safe minimum; default 300 seconds options(shinyOAuth.state_fail_delay_ms = c(10, 30)) – adds small randomized delay (milliseconds) state validation failure (e.g., malformed token, IV/tag/ciphertext issues, GCM authentication failure). helps reduce timing side‑channels different failure modes Note allowed_hosts: patterns support globs (*, ?). Using catch‑like \"*\" matches host effectively disables endpoint host restrictions (scheme rules still apply). Avoid unless truly intend accept host; prefer pinning domain(s), e.g., c(\".example.com\").","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"http-settings-timeout-retries-user-agent","dir":"Articles","previous_headings":"Global options","what":"HTTP settings (timeout, retries, user agent)","title":"Usage","text":"options(shinyOAuth.timeout = 5) – default HTTP timeout (seconds) applied outbound requests (discovery, JWKS, token exchange, userinfo). Increase provider/network slow; can overridden per‑session via options() making requests options(shinyOAuth.retry_max_tries = 3L) – maximum attempts transient failures (network errors, 408, 429, 5xx) options(shinyOAuth.retry_backoff_base = 0.5) – base backoff seconds used exponential backoff jitter options(shinyOAuth.retry_backoff_cap = 5) – per‑attempt cap backoff seconds (jitter) options(shinyOAuth.retry_status = c(408L, 429L, 500:599)) – HTTP statuses considered transient retried options(shinyOAuth.user_agent = \"shinyOAuth/<version> R/<version> httr2/<version>\") – override default User‑Agent header applied outbound requests. default string built dynamically installed package/runtime versions; set custom string organization requires specific format","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"development-softening","dir":"Articles","previous_headings":"Global options","what":"Development softening","title":"Usage","text":"options(shinyOAuth.skip_browser_token = TRUE) – skip browser cookie binding options(shinyOAuth.skip_id_sig = TRUE) – skip ID token signature verification Don’t enable production. disable key security checks intended local testing . Use error_on_softened() startup fail fast softening flags enabled environment .","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"state-envelope-size-caps","dir":"Articles","previous_headings":"Global options","what":"State envelope size caps","title":"Usage","text":"options(shinyOAuth.state_max_token_chars = 8192) – maximum allowed length base64url-encoded state query parameter options(shinyOAuth.state_max_wrapper_bytes = 8192) – maximum decoded byte size outer JSON wrapper (parsing) options(shinyOAuth.state_max_ct_b64_chars = 8192) – maximum allowed length base64url-encoded ciphertext inside wrapper options(shinyOAuth.state_max_ct_bytes = 8192) – maximum decoded byte size ciphertext attempting AES-GCM decrypt prevent maliciously large state parameters causing excessive CPU memory usage decoding decryption.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"browser-cookie-preventing-xss","dir":"Articles","previous_headings":"","what":"Browser cookie & preventing XSS","title":"Usage","text":"oauth_module_server() binds browser server session short‑lived cookie must readable client‑side JavaScript bridge values Shiny. cookie ensures browser initiated login one receiving callback. specifically prevents attack attacker tricks user clicking link initiates login attacker’s account, confusing user logging attacker (login confusion). cookie set HttpOnly flag disabled can read JavaScript. necessary bridge cookie value Shiny. However, means app XSS vulnerabilities, attacker read cookie . relatively limited attack vector, still take care prevent XSS vulnerabilities app. important mitigation sanitize user inputs rendering UI (e.g., using htmltools::htmlEscape()).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"multiprocess-deployments-share-state-store-key","dir":"Articles","previous_headings":"","what":"Multi‑process deployments: share state store & key","title":"Usage","text":"run multiple Shiny R processes (e.g., multiple workers, Shiny Server Pro, RStudio Connect, Docker/Kubernetes replicas, non‑sticky load balancer), must ensure : workers share state store (e.g., cachem::cache_disk() pointing shared directory, custom cachem backend; default cachem::cache_mem() per‑process shared) workers share state key (e.g., read environment variable; default, random key generated per client instance shared) authorization code + PKCE flow, ‘shinyOAuth’ creates encrypted “state envelope” stored cache (state_store) echoed back via state query parameter. envelope sealed AES‑GCM using state_key. callback lands different worker one initiated login, worker must able read cached entry decrypt envelope using key. workers different keys, decryption fail login flow abort state error. providing custom state key, please ensure high entropy (minimum 32 characters 32 raw bytes; recommended 64–128 characters) prevent offline guessing attacks encrypted state. use short human‑memorable passphrases.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"security-checklist","dir":"Articles","previous_headings":"","what":"Security checklist","title":"Usage","text":"checklist things may want think bringing app production: Use HTTPS everywhere production Verify issuer used provider correct OAuthProvider, set many security options possible; instance, set jwks_host_issuer_match/jwks_host_allow_only (provider uses different host JWKS) OAuthClient request minimum scopes necessary; give app registration permissions needs show $error_description users; never expose tokens UI logs Keep secrets safe environment variables (e.g., OAUTH_CLIENT_ID, OAUTH_CLIENT_SECRET) Sanitize user inputs rendering UI (e.g., using htmltools::htmlEscape()) Make use audit logging (see vignette(\"audit-logging\", package = \"shinyOAuth\")) monitor logs Use provider enforces strong authentication (e.g., multi-factor authentication) Set Content Security Policy (CSP) headers restrict resource loading mitigate XSS attacks; (requires middleware; can’t done Shiny) Log IP addresses accessing app (requires middleware; can’t done Shiny) R package developed care OAuth 2.0/OIDC protocols contain many security features, guarantees can made realm cybersecurity. highly sensitive applications, consider layered (‘defense--depth’) approach security (example, adding IP whitelist additional safeguard).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Luka Koning. Author, maintainer, copyright holder.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Koning L (2025). shinyOAuth: Provider-Agnostic OAuth Authentication Shiny Applications. R package version 0.1.0, https://github.com/lukakoning/shinyOAuth.","code":"@Manual{,   title = {shinyOAuth: Provider-Agnostic OAuth Authentication for Shiny Applications},   author = {Luka Koning},   year = {2025},   note = {R package version 0.1.0},   url = {https://github.com/lukakoning/shinyOAuth}, }"},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"id_-basic-usage-of-s7-taken-from-the-s7-package-vignettes","dir":"","previous_headings":"","what":"# Basic usage of S7 (taken from the S7 package vignettes)","title":"NA","text":"title: “S7 basics” output: rmarkdown::html_vignette vignette: > % % % — {r, include = FALSE} knitr::opts_chunk$set(   collapse = TRUE,   comment = \"#>\" ) S7 package provides new OOP system designed successor S3 S4. designed implemented collaboratively RConsortium Object-Oriented Programming Working Group, includes representatives R-Core, BioConductor, RStudio/tidyverse, wider R community. vignette gives overview important parts S7: classes objects, generics methods, basics method dispatch inheritance. {r setup} library(S7)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"classes-and-objects","dir":"","previous_headings":"","what":"Classes and objects","title":"NA","text":"S7 classes formal definition create new_class(). two arguments ’ll use almost every class: name class, supplied first argument. class properties, data associated instance class. easiest way define properties supply named list values define valid types property. following code defines simple dog class two properties: character name numeric age. {r} Dog <- new_class(\"Dog\", properties = list(   name = class_character,   age = class_numeric )) Dog S7 provides number built-definitions allow refer existing base types S7 classes. can recognize definitions start class_. Note ’ve assigned return value new_class() object name class. important! object represents class use construct instances class: {r} lola <- Dog(name = \"Lola\", age = 11) lola S7 object, can get set properties using @: {r} lola@age <- 12 lola@age S7 automatically validates type property using type supplied new_class(): {r, error = TRUE} lola@age <- \"twelve\" Given object, can retrieve class S7_class(): {r} S7_class(lola) S7 objects also S3 class(). used compatibility existing S3 generics can learn vignette(\"compatibility\"). {r} class(lola) want learn details S7 classes objects, including validation methods details properties, please see vignette(\"classes-objects\").","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"generics-and-methods","dir":"","previous_headings":"","what":"Generics and methods","title":"NA","text":"S7, like S3 S4, built around idea generic functions, generics short. generic defines interface, uses different implementation depending class one arguments. implementation specific class called method, generic finds appropriate method performing method dispatch. Use new_generic() create S7 generic. simplest form, needs two arguments: name generic (used error messages) name argument used method dispatch: {r} speak <- new_generic(\"speak\", \"x\") Like new_class(), always assign result new_generic() variable name first argument. generic, can register methods specific classes method(generic, class) <- implementation. {r} method(speak, Dog) <- function(x) {   \"Woof\" } method registered, generic use appropriate: {r} speak(lola) Let’s define another class, one cats, define another method speak(): ```{r} Cat <- new_class(“Cat”, properties = list( name = class_character, age = class_double )) method(speak, Cat) <- function(x) { “Meow” } fluffy <- Cat(name = “Fluffy”, age = 5) speak(fluffy)","code":"You get an error if you call the generic with a class that doesn't have a method:  ```{r, error = TRUE} speak(1)"},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"method-dispatch-and-inheritance","dir":"","previous_headings":"","what":"Method dispatch and inheritance","title":"NA","text":"cat dog classes share properties, use common parent class extract duplicated specification. first define parent class: {r} Pet <- new_class(\"Pet\",   properties = list(     name = class_character,     age = class_numeric   ) ) use parent argument new_class: ```{r} Cat <- new_class(“Cat”, parent = Pet) Dog <- new_class(“Dog”, parent = Pet) Cat Dog Method dispatch takes advantage hierarchy parent classes: method defined class, try method parent class, finds method gives error. inheritance powerful mechanism sharing code across classes. ```{r} describe <- new_generic(“describe”, “x”) method(describe, Pet) <- function(x) { paste0(x@name, ” “, x@age,” years old”) } describe(lola) describe(fluffy) method(describe, Dog) <- function(x) { paste0(x@name, ” “, x@age,” year old dog”) } describe(lola) describe(fluffy) Printing generic show methods currently defined: {r} describe can use method() retrieve implementation one methods: {r} method(describe, Pet)","code":"Because we have created new classes, we need to recreate the existing `lola` and `fluffy` objects:  ```{r} lola <- Dog(name = \"Lola\", age = 11) fluffy <- Cat(name = \"Fluffy\", age = 5) You can define a fallback method for any S7 object by registering a method for `S7_object`:  ```{r} method(describe, S7_object) <- function(x) {   \"An S7 object\" }  Cocktail <- new_class(\"Cocktail\",   properties = list(     ingredients = class_character   ) ) martini <- Cocktail(ingredients = c(\"gin\", \"vermouth\")) describe(martini)"},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"id_-using-s7-in-a-package-taken-from-the-s7-package-vignettes","dir":"","previous_headings":"","what":"# Using S7 in a package (taken from the S7 package vignettes)","title":"NA","text":"title: “Using S7 package” output: rmarkdown::html_vignette vignette: > % % % — {r, include = FALSE} knitr::opts_chunk$set(   collapse = TRUE,   comment = \"#>\" ) vignette outlines important things need know using S7 package. S7 new, people used package yet; means vignette likely incomplete, ’d love help make better. Please let us know questions vignette doesn’t answer. {r setup} library(S7)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"method-registration","dir":"","previous_headings":"","what":"Method registration","title":"NA","text":"always call methods_register() .onLoad(): {r} .onLoad <- function(...) {   S7::methods_register() } S7’s way registering methods, rather using export directives NAMESPACE like S3 S4 . strictly necessary registering methods generics packages, ’s harm adding ensures won’t forget later. (’re importing S7 namespace quiet R CMD check NOTE.)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"documentation-and-exports","dir":"","previous_headings":"","what":"Documentation and exports","title":"NA","text":"want users create instances class, need export class constructor. means also need document , since constructor function, means document arguments properties class (unless customised constructor). export class, must also set package argument, ensuring classes name disambiguated across packages. document generics like regular functions (since !). expect others create methods generic, may want include section describing properties expect methods . plan provide easy way document methods generic, yet implemented . can track progress https://github.com/RConsortium/S7/issues/167. don’t currently recommendations documenting methods. ’s need document order pass R CMD check, obviously cases ’s nice provide additional details method, particularly takes extra arguments compared generic. ’re tracking issue https://github.com/RConsortium/S7/issues/315.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"backward-compatibility","dir":"","previous_headings":"","what":"Backward compatibility","title":"NA","text":"using S7 package want package work versions R 4.3.0, need know versions R @ works S4 objects. two workarounds. easiest least convenient workaround just prop() instead @. Otherwise, can conditionally make S7-aware @ available package custom NAMESPACE directive: @ work users package S7 automatically attaches environment containing needed definition ’s loaded.","code":"# enable usage of <S7_object>@name in package code #' @rawNamespace if (getRversion() < \"4.3.0\") importFrom(\"S7\", \"@\") NULL"},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/copilot-instructions.html","id":"project-snapshot","dir":"","previous_headings":"","what":"Project Snapshot","title":"AI Coding Guide","text":"shinyOAuth S7-based OAuth/OIDC toolkit Shiny; top-level flow lives R/oauth_module_server.R supporting UI glue R/use_shinyOAuth.R. Core domain objects S7 classes R/classes__OAuthProvider.R, R/classes__OAuthClient.R, R/classes_OAuthToken.R; prefer helper constructors (oauth_provider*(), oauth_client()) manual new_class calls. S7 new OOP system R; follow existing patterns generics, methods, validation extending adding new classes. need information S7, refer .github/copilot-instructions-S7.md ## Core Code Paths oauth_module_server() orchestrates redirect→callback→token→refresh, exposing reactiveValues API (request_login(), logout(), build_auth_url()) watchdogs missing JS/browser tokens. Token exchange, refresh, userinfo logic live R/methods__login.R, R/methods__token.R, R/methods__userinfo.R; rely swap_code_for_token_set() expect httr2 requests pass add_req_defaults() req_with_retry(). UI resources ship via inst/www/shinyOAuth.js must loaded per app via use_shinyOAuth(); watchdog warning triggered oauth_module_server() runs helper sets flag. ## Security & State OAuthClient instances seal state payloads AES-GCM using client@state_key single-use cache entries (state_store_get_remove()); share key cache across workers production deployments. Host validation centralized is_ok_host() enforced OAuthProvider validators; always pipe new endpoints helpers avoid bypassing checks. Provider objects gate PKCE/nonce/id-token policies token_type enforcement; align new provider helpers existing defaults R/providers.R (e.g., allowed_algs, allowed_token_types). ## HTTP & External Providers Every outbound call wrap httr2::request() add_req_defaults() timeout/UA req_with_retry() transient handling; tune via options(shinyOAuth.timeout, shinyOAuth.retry_*). oauth_provider_oidc_discover() intersects discovery metadata caller allowed_algs infers token_auth_style; surface configuration failures err_config()/err_http() retain trace ids. Built-providers (oauth_provider_github/google/microsoft/…) illustrate extra_token_headers, JWKS pinning, fingerprinting; mirror structure adding providers tests can stub with_mocked_bindings(). ## Shiny Integration Module cookies bind browser sessions using Web Crypto; tests headless contexts can skip requirement options(shinyOAuth.skip_browser_token = TRUE) stubbing values via helper functions. Async flows require promises, future, later; configure plan (e.g., future::plan(multisession)) enabling async=TRUE tests degrade synchronous warnings. Tab title cleanup, cookie scope, proactive refresh configurable arguments oauth_module_server(); document new parameters roxygen comments guard stopifnot validations. ## Auditing & Diagnostics audit_event()/emit_trace_event() R/errors.R send redacted telemetry options(shinyOAuth.trace_hook) options(shinyOAuth.audit_hook); preserve hashed identifiers via string_digest() logging new fields. error paths raise via err_abort wrappers (err_token(), err_invalid_state(), err_userinfo(), etc.) trace ids structured context propagate Shiny logs audit hooks. Options like shinyOAuth.print_errors, shinyOAuth.print_traceback, shinyOAuth.disable_watchdog_warning let operators tune verbosity; respect flags instead printing directly. ## Error Handling Throw failures typed helpers R/errors.R (err_abort() plus err_token()/err_invalid_state()/err_http(), etc.); wrap rlang::abort package-specific classes inject trace ids, avoid base stop(). recoverable notices use rlang::warn()/inform() cli-style bullet vectors frequency guards (see warn_about_missing_js_dependency() client_state_store_max_age()) instead message()/warning(); surface structured context via context = list(). Prefer adding new err_* warn_* helpers next existing ones tests can assert condition classes message formats. Default rlang/cli idioms developer messaging: use cli::cli_warn()/cli_inform() rlang::warn()/inform() cli bullets, avoid cat()/print()/message() unless tests explicitly stub paths. ## Testing Workflow Run tests mcp_r-mcp-server_run_testthat(mode = “”) available Rscript -e “testthat::test_local()” repo root. testthat suites tests/testthat/ intensively mock network calls (with_mocked_bindings) spin webfakes servers; keep new HTTP helpers injectable return httr2 responses mocks remain simple. Async module tests reset future::plan(future::sequential) poll later::run_now(); use existing helpers (make_test_client(), valid_browser_token()) instead reimplementing fixtures. adding state-store logic, ensure cache backends expose get/set/remove/missing signatures duck-typing checks OAuthClient/OAuthProvider validators keep passing. ## Documentation & Examples Roxygen comments R/ generate man/ via Rscript -e “devtools::document()”; never hand-edit .Rd files. Example Shiny integrations live inst/examples/ long-form guidance vignettes/*.Rmd; update alongside API changes pkgdown docs (docs/) stay accurate. .onLoad() already registers S7 methods (R/zzz.R); adding generics ensure S7::methods_register() triggered namespace imports remain consistent. ## Backwards compatibility working towards first release. previous release maintain backwards compatibility . code backwards compatibility unless instructed specifically instructed . Breaking changes acceptable stage project; leave leftover compatibility shims. ever think need add backwards compatibility code, please discuss first. ## Global options add new global options unless specifially requested . reason think new global option needed, please discuss first. global option ever added, note must documented ‘usage’ vignette.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"shinyoauth","dir":"","previous_headings":"","what":"Provider-Agnostic OAuth Authentication for Shiny Applications","title":"Provider-Agnostic OAuth Authentication for Shiny Applications","text":"‘shinyOAuth’ R package implementing provider‑agnostic OAuth 2.0 OpenID Connect (OIDC) authorization authentication Shiny apps. built modern S7 classes security mind. OAuth 2.0/OIDC lets users sign app using accounts already (e.g., Google, Microsoft, GitHub, many ), via self-hosted identity provider (e.g., Keycloak), via identity---service provider (e.g., Auth0, Okta). achieve , app redirects unauthenticated users identity provider, authenticate , redirected back app authorization code. app exchanges code tokens prove user’s identity, optionally allow app call provider’s APIs user’s behalf (e.g., fetch data associated user’s account). package streamlines flow Shiny applications, enabling developers add OAuth 2.0/OIDC authorization/authentication apps minimal code. provided Shiny module handles redirecting unauthenticated users, managing state/PKCE/nonce secure code-token exchange, verifying OIDC tokens, automatically fetching user info performing token refresh, using asynchronous execution, . package highly configurable works various OAuth 2.0/OIDC providers protocol features.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Provider-Agnostic OAuth Authentication for Shiny Applications","text":"Shiny module: oauth_module_server() gives ready‑‑use OAuth authentication flow secure defaults. Easily read authentication status, token details, & user info reactive values Shiny server logic S7 classes: OAuthProvider, OAuthClient, OAuthToken, structured representation key elements OAuth 2.0/OIDC flow Functions: prepare_call(), handle_callback(), introspect_token(), refresh_token(), , wish manually implement parts OAuth 2.0/OIDC flow Provider helpers: can configure OAuth 2.0/OIDC providers, package also includes oauth_provider_oidc_discover() function quick OIDC setup, contains built-configurations popular providers (e.g., GitHub, Google, Microsoft, Keycloak, Auth0). Security best practices: AES-GCM–sealed state payloads (AEAD), server-side state validation coupled local cookie verification, HTTPS enforcement, PKCE (S256), ID token signature/claims validation (including nonce), userinfo subject match, (see vignette(\"authentication-flow\", package = \"shinyOAuth\") (link) details) Provides hooks auditing & logging key events, like login successes failures (see vignette(\"audit-logging\", package = \"shinyOAuth\") (link) details)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Provider-Agnostic OAuth Authentication for Shiny Applications","text":"Install development version GitHub: , install CRAN (accepted release):","code":"remotes::install_github(\"lukakoning/shinyOAuth\") install.packages(\"shinyOAuth\")"},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Provider-Agnostic OAuth Authentication for Shiny Applications","text":"complete usage documentation (.e., making manual login button, making authenticated API calls, setting various options, security checklist) see: vignette(\"usage\", package = \"shinyOAuth\") (link).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"minimal-example","dir":"","previous_headings":"Usage","what":"Minimal example","title":"Provider-Agnostic OAuth Authentication for Shiny Applications","text":"minimal example using GitHub OAuth 2.0 app. want try example , can register app GitHub Developer Settings.","code":"library(shiny) library(shinyOAuth)  # GitHub OAuth provider has been preconfigured in the package #  - You can quickly configure OIDC providers with `oauth_provider_oidc_discover()` #  - You can manually configure every other provider with `oauth_provider()` provider <- oauth_provider_github()  # Build client using your app's ID, secret, & redirect URI: client <- oauth_client(   provider = provider,   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\",   scopes = c(\"read:user\", \"user:email\") )  # Simple UI ui <- fluidPage(   # Include JavaScript dependency:   use_shinyOAuth(),   # Show login information:   uiOutput(\"login_information\") )  # Server which obtains authentication  server <- function(input, output, session) {   # Start authentication module; will automatically redirect unauthenticated users   #   to the provider's login page and handle the callback   # Returns reactive values with authentication status, token details, user info,   #   etc.   auth <- oauth_module_server(\"auth\", client)    # Render login information:   output$login_information <- renderUI({     if (auth$authenticated) {       user_info <- auth$token@userinfo       tagList(         tags$p(\"You are logged in! Your details:\"),         tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))       )     } else {       tags$p(\"You are not logged in.\")     }   }) }  runApp(shinyApp(ui, server), port = 8100)"},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"loggingauditing","dir":"","previous_headings":"Usage","what":"Logging/auditing","title":"Provider-Agnostic OAuth Authentication for Shiny Applications","text":"package provides hooks logging/auditing crucial events (e.g., callbacks issued & received, login success/failures). See vignette(\"audit-logging\", package = \"shinyOAuth\") (link) details.","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"what-happens-during-the-authentication-flow","dir":"","previous_headings":"More information","what":"What happens during the authentication flow?","title":"Provider-Agnostic OAuth Authentication for Shiny Applications","text":"-depth step--step explanation happens authentication flow, see: vignette(\"authentication-flow\", package = \"shinyOAuth\") (link).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"what-do-i-need-to-consider-for-production-use","dir":"","previous_headings":"More information","what":"What do I need to consider for production use?","title":"Provider-Agnostic OAuth Authentication for Shiny Applications","text":"checklist security considerations best practices production use, see: vignette(\"usage\", package = \"shinyOAuth\") (link).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthClient.html","id":null,"dir":"Reference","previous_headings":"","what":"OAuthClient S7 class — OAuthClient","title":"OAuthClient S7 class — OAuthClient","text":"S7 class representing OAuth 2.0 client configuration, including provider, client credentials, redirect URI, requested scopes, state management. low-level constructor intended advanced use. users prefer helper constructor oauth_client().","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthClient.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OAuthClient S7 class — OAuthClient","text":"","code":"OAuthClient(   provider = NULL,   client_id = character(0),   client_secret = character(0),   client_private_key = NULL,   client_private_key_kid = NA_character_,   client_assertion_alg = NA_character_,   redirect_uri = character(0),   scopes = character(0),   state_store = cachem::cache_mem(max_age = 300),   state_entropy = 64,   state_key = random_urlsafe(n = 128) )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthClient.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OAuthClient S7 class — OAuthClient","text":"provider OAuthProvider object client_id OAuth client ID client_secret OAuth client secret. Validation rules: Required (non-empty) provider authenticates client HTTP Basic auth token endpoint (token_auth_style = \"header\", also known client_secret_basic). Optional public PKCE-clients provider configured use_pkce = TRUE uses form-body client authentication token endpoint (token_auth_style = \"body\", also known client_secret_post). case, secret omitted token requests. Note: provider issues HS256 ID tokens id_token_validation enabled, non-empty client_secret required signature validation. client_private_key Optional private key private_key_jwt client authentication token endpoint. Can openssl::key PEM string containing private key. Required provider's token_auth_style = 'private_key_jwt'. Ignored auth styles. client_private_key_kid Optional key identifier (kid) include JWT header private_key_jwt assertions. Useful authorization server uses kid select correct verification key. client_assertion_alg Optional JWT signing algorithm use client assertions. omitted, defaults HS256 client_secret_jwt. private_key_jwt, compatible default selected based private key type/curve (e.g., RS256 RSA, ES256/ES384/ES512 EC P-256/384/521, EdDSA Ed25519/Ed448). explicit value provided incompatible key, validation fails early configuration error. Supported values HS256, HS384, HS512 client_secret_jwt asymmetric algorithms supported jose::jwt_encode_sig (e.g., RS256, PS256, ES256, EdDSA) private keys. redirect_uri Redirect URI registered provider scopes Vector scopes request state_store State storage backend. Defaults cachem::cache_mem(max_age = 300). Alternative backends include cachem::cache_disk() custom implementation (can create custom_cache(). backend must implement cachem-like methods $get(key, missing), $set(key, value), $remove(key); $info() optional. Trade-offs: cache_mem -memory thus scoped single R process (good default single Shiny process). cache_disk persists disk can shared across multiple R processes (useful multi-process deployments Shiny workers sticky). custom_cache() backend use database external store (e.g., Redis, Memcached). See also vignette(\"usage\", package = \"shinyOAuth\"). client automatically generates, persists (state_store), validates OAuth state parameter (OIDC nonce applicable) authorization code flow state_entropy Integer. length (characters) randomly generated state parameter. Higher values provide entropy better security CSRF attacks. Must 22 128 (align validate_state()'s default minimum targets ~128 bits base64url‑like strings). Default 64, provides approximately 384 bits entropy state_key Optional per-client secret used state sealing key AES-GCM AEAD (authenticated encryption) state payload travels via state query parameter. provides confidentiality integrity (via authentication tag) embedded data used callback verification. omit argument, random value generated via random_urlsafe(128). key distinct OAuth client_secret may used public clients. Type: character string (>= 32 bytes encoded) raw vector (>= 32 bytes). Raw keys enable direct use high-entropy secrets external stores. forms normalized internally cryptographic helpers. Multi-process deployments: app runs multiple R workers behind non-sticky load balancer, must configure shared state_store state_key across workers. Otherwise callbacks land different worker unable decrypt/validate state envelope authentication fail. environments, rely random per-process default: provide explicit, high-entropy key (example via secret store environment variable). Prefer values substantial entropy (e.g., 64–128 base64url characters raw 32+ byte key). Avoid human‑memorable passphrases. See also vignette(\"usage\", package = \"shinyOAuth\").","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthClient.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OAuthClient S7 class — OAuthClient","text":"","code":"# Example requires a configured app & credentials # (code is therefore not run) # (go to https://github.com/settings/developers to create a GitHub OAuth app) if (FALSE) { # \\dontrun{ library(shiny) library(shinyOAuth)  # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Example app with auto-redirect (1) -----------------------------------------  ui_1 <- fluidPage(   use_shinyOAuth(),   uiOutput(\"login\") )  server_1 <- function(input, output, session) {   # Auto-redirect (default):   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = TRUE   )      output$login <- renderUI({     if (auth$authenticated) {       user_info <- auth$token@userinfo       tagList(         tags$p(\"You are logged in!\"),         tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))       )     } else {       tags$p(\"You are not logged in.\")     }   }) }  app_1 <- shinyApp(ui_1, server_1) runApp(app_1, port = 8100)   # Example app with manual login button (2) -----------------------------------  ui_2 <- fluidPage(   use_shinyOAuth(),   actionButton(\"login_btn\", \"Login\"),   uiOutput(\"login\") )  server_2 <- function(input, output, session) {   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = FALSE   )      observeEvent(input$login_btn, {     auth$request_login()   })      output$login <- renderUI({     if (auth$authenticated) {       user_info <- auth$token@userinfo       tagList(         tags$p(\"You are logged in!\"),         tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))       )     } else {       tags$p(\"You are not logged in.\")     }   }) }  app_2 <- shinyApp(ui_2, server_2) runApp(app_2, port = 8100)  # Example app requesting additional resource with access token ---------------  # Below app shows the authenticated username + their GitHub repositories, # fetched via GitHub API using the access token obtained during login  ui_3 <- fluidPage(   use_shinyOAuth(),   uiOutput(\"ui\") )  server_3 <- function(input, output, session) {   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = TRUE   )      repositories <- reactiveVal(NULL)      observe({     req(auth$authenticated)          # Example additional API request using the access token     # (e.g., fetch user repositories from GitHub)     req <- client_bearer_req(auth$token, \"https://api.github.com/user/repos\")     resp <- httr2::req_perform(req)          if (httr2::resp_is_error(resp)) {       repositories(NULL)     } else {       repos_data <- httr2::resp_body_json(resp, simplifyVector = TRUE)       repositories(repos_data)     }   })      # Render username + their repositories   output$ui <- renderUI({     if (isTRUE(auth$authenticated)) {       user_info <- auth$token@userinfo       repos <- repositories()              return(tagList(         tags$p(paste(\"You are logged in as:\", user_info$login)),         tags$h4(\"Your repositories:\"),         if (!is.null(repos)) {           tags$ul(             Map(function(url, name) {               tags$li(tags$a(href = url, target = \"_blank\", name))             }, repos$html_url, repos$full_name)           )         } else {           tags$p(\"Loading repositories...\")         }       ))     }          return(tags$p(\"You are not logged in.\"))   }) }  app_3 <- shinyApp(ui_3, server_3) runApp(app_3, port = 8100) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthProvider.html","id":null,"dir":"Reference","previous_headings":"","what":"OAuthProvider S7 class — OAuthProvider","title":"OAuthProvider S7 class — OAuthProvider","text":"S7 class representing OAuth 2.0 provider configuration. Includes endpoints, OIDC settings, various security options govern OAuth OIDC flows. low-level constructor intended advanced use. users prefer helper constructors oauth_provider() generic OAuth 2.0 providers oauth_provider_oidc() / oauth_provider_oidc_discover() OpenID Connect providers. helpers enable secure defaults based presence issuer available endpoints.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthProvider.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OAuthProvider S7 class — OAuthProvider","text":"","code":"OAuthProvider(   name = character(0),   auth_url = character(0),   token_url = character(0),   userinfo_url = NA_character_,   introspection_url = NA_character_,   issuer = NA_character_,   use_nonce = FALSE,   use_pkce = TRUE,   pkce_method = \"S256\",   userinfo_required = FALSE,   userinfo_id_selector = function(userinfo) userinfo$sub,   userinfo_id_token_match = FALSE,   id_token_required = FALSE,   id_token_validation = FALSE,   extra_auth_params = list(),   extra_token_params = list(),   extra_token_headers = character(0),   token_auth_style = \"header\",   jwks_cache = cachem::cache_mem(max_age = 3600),   jwks_pins = character(0),   jwks_pin_mode = \"any\",   jwks_host_issuer_match = FALSE,   jwks_host_allow_only = NA_character_,   allowed_algs = c(\"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\",     \"ES384\", \"ES512\", \"EdDSA\"),   allowed_token_types = character(0),   leeway = getOption(\"shinyOAuth.leeway\", 30) )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthProvider.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OAuthProvider S7 class — OAuthProvider","text":"name Provider name (e.g., \"github\", \"google\"). Cosmetic ; used logging audit events auth_url Authorization endpoint URL token_url Token endpoint URL userinfo_url User info endpoint URL (optional) introspection_url Token introspection endpoint URL (optional; RFC 7662) issuer OIDC issuer URL (optional; required ID token validation). base URL identifies OpenID Provider (OP). used ID token validation verify iss claim ID token matches expected issuer. also used fetch provider's JSON Web Key Set (JWKS) verifying ID token signatures (typically via OIDC discovery document located /.well-known/openid-configuration relative issuer URL) use_nonce Whether use OIDC nonce. adds nonce parameter authorization request validates nonce claim ID token. recommended OIDC flows mitigate replay attacks use_pkce Whether use PKCE. adds code_challenge parameter authorization request requires code_verifier exchanging authorization code tokens. prevents authorization code interception attacks pkce_method PKCE code challenge method (\"S256\" \"plain\"). \"S256\" recommended. \"plain\" used non-compliant providers support \"S256\" userinfo_required Whether fetch userinfo token exchange. User information stored userinfo field returned OAuthToken object. requires valid userinfo_url set. fetching userinfo fails, token exchange fail. low-level constructor oauth_provider(), explicitly supplied, inferred presence non-empty userinfo_url: userinfo_url provided, userinfo_required defaults TRUE, otherwise defaults FALSE. avoids unexpected validation errors userinfo_url omitted (since optional). userinfo_id_selector function extracts user ID userinfo response.#' take single argument (userinfo list) return user ID string. used userinfo_id_token_match TRUE. Optional otherwise; supplied, features (like subject matching) unavailable. Helper constructors like oauth_provider() oauth_provider_oidc() provide default selector extracts sub field. userinfo_id_token_match Whether verify user ID (\"sub\") ID token matches user ID extracted userinfo response. requires userinfo_required id_token_validation TRUE (thus valid userinfo_url issuer set, plus potentially setting client's scope include \"openid\", ID token returned). Furthermore, provider's userinfo_id_selector must configured extract user ID userinfo response. check helps ensure integrity user information confirming sources agree user's identity. oauth_provider(), explicitly supplied, inferred TRUE userinfo_required id_token_validation TRUE; otherwise defaults FALSE. id_token_required Whether require ID token returned token exchange. ID token returned, token exchange fail. requires provider valid OpenID Connect provider may require setting client's scope include \"openid\". Note: S7 class level, defaults FALSE pure OAuth 2.0 providers can configured without OIDC. Helper constructors like oauth_provider() oauth_provider_oidc() enable issuer supplied OIDC explicitly requested. id_token_validation Whether perform ID token validation token exchange. requires provider valid OpenID Connect provider configured issuer token response include ID token (may require setting client's scope include \"openid\"). Note: S7 class level, defaults FALSE. Helper constructors like oauth_provider() oauth_provider_oidc() turn issuer provided OIDC used. extra_auth_params Extra parameters authorization URL extra_token_params Extra parameters token exchange extra_token_headers Extra headers token exchange requests (named character vector) token_auth_style authenticate exchanging tokens. One : \"header\": HTTP Basic (client_secret_basic) \"body\": Form body (client_secret_post) \"client_secret_jwt\": JWT client assertion signed HMAC using client_secret (RFC 7523) \"private_key_jwt\": JWT client assertion signed asymmetric key (RFC 7523) jwks_cache JWKS cache backend. provided, cachem::cache_mem(max_age = 3600) (1 hour) cache created. May cachem‑compatible backend, including cachem::cache_disk() filesystem cache shared across workers, custom implementation created via custom_cache() (e.g., database/Redis backed). TTL guidance: Choose max_age line identity platform’s JWKS rotation cache‑control cadence. range 15 minutes 2 hours typically sensible; default 1 hour. Shorter TTLs adopt new keys faster cost JWKS traffic; longer TTLs reduce traffic may delay new keys slightly. Signature verification automatically perform one‑time JWKS refresh new kid appears ID token. Cache keys internal, hashed issuer pinning configuration. Cache values lists elements jwks fetched_at (numeric epoch seconds) jwks_pins Optional character vector RFC 7638 JWK thumbprints (base64url) pin . non-empty, fetched JWKS must contain keys whose thumbprints match values depending jwks_pin_mode. Use reduce key substitution risks pre-authorizing expected keys jwks_pin_mode Pinning policy jwks_pins provided. Either \"\" (default; least one key JWKS must match) \"\" (every RSA/EC public key JWKS must match one configured pins) jwks_host_issuer_match TRUE, enforce discovery jwks_uri host matches issuer host (subdomain). Defaults FALSE class level, helper constructors OIDC (e.g., oauth_provider_oidc() oauth_provider_oidc_discover()) enable default safer config. generic helper oauth_provider() also automatically set TRUE issuer provided either id_token_validation id_token_required TRUE (OIDC-like configuration). Set explicitly FALSE opt . providers legitimately publish JWKS different host (e.g., Google), prefer setting jwks_host_allow_only exact hostname rather disabling check jwks_host_allow_only Optional explicit hostname jwks_uri must match. provided, jwks_uri host must equal value (exact match). can pass either just host (e.g., \"www.googleapis.com\") full URL; host component used. Takes precedence jwks_host_issuer_match allowed_algs Optional vector allowed JWT algorithms ID tokens. Use restrict acceptable alg values per-provider basis. Supported asymmetric algorithms include RS256, RS384, RS512, PS256, PS384, PS512, ES256, ES384, ES512, EdDSA (Ed25519/Ed448 via OKP). Symmetric HMAC algorithms HS256, HS384, HS512 also supported require supply client_secret explicitly enable HMAC verification via option options(shinyOAuth.allow_hs = TRUE). Defaults c(\"RS256\",\"RS384\",\"RS512\",\"PS256\",\"PS384\",\"PS512\", \"ES256\",\"ES384\",\"ES512\",\"EdDSA\"), intentionally excludes HS*. include HS* certain client_secret stored strictly server-side never shipped , derivable , browser untrusted environments. Prefer rotating secrets regularly enabling . allowed_token_types Character vector acceptable OAuth token types returned token endpoint (case-insensitive). non-empty, token response MUST include token_type must one allowed values; otherwise flow fails fast shinyOAuth_token_error. empty, check performed token_type may omitted provider. Helper constructors default strictly: oauth_provider() issuer supplied OIDC flags enabled, allowed_token_types defaults c(\"Bearer\") enforce Bearer default; otherwise remains empty. can override widen disable enforcement setting explicitly leeway Clock skew leeway (seconds) applied ID token exp/iat checks. Default 30. Can globally overridden via option shinyOAuth.leeway","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthProvider.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OAuthProvider S7 class — OAuthProvider","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional; S   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" ) #> Warning: [shinyOAuth] - Configure allowed hosts for production #> ! No host allowlist configured via `options(shinyOAuth.allowed_hosts = #>   c(\".example.com\", \"api.example.com\"))`. #> ℹ Restricting hosts hardens redirect and API endpoint validation. #> ℹ See `?is_ok_host` for policy details and review the 'authentication-flow' #>   vignette #> This warning is displayed once per session.  # Configure OIDC provider via OIDC discovery # (example requires network access; is therefore not run) if (FALSE) { # \\dontrun{ oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://accounts.google.com\" ) } # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Other providers # (all requiring network access; example is therefore not run) if (FALSE) { # \\dontrun{ # Slack via OIDC discovery slack_provider <- oauth_provider_slack()  # Keycloak # (requires configured Keycloak realm) oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\")  # Auth0 # (requires configured Auth0 domain) oauth_provider_auth0(domain = \"your-tenant.auth0.com\")  # Okta # (requires configured Okta domain) oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthToken.html","id":null,"dir":"Reference","previous_headings":"","what":"OAuthToken S7 class — OAuthToken","title":"OAuthToken S7 class — OAuthToken","text":"S7 class representing OAuth tokens (optionally) user information.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthToken.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OAuthToken S7 class — OAuthToken","text":"","code":"OAuthToken(   access_token = character(0),   refresh_token = NA_character_,   id_token = NA_character_,   expires_at = Inf,   userinfo = list() )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthToken.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OAuthToken S7 class — OAuthToken","text":"access_token Access token refresh_token Refresh token (provided provider) id_token ID token (provided provider; OpenID Connect) expires_at Numeric timestamp (seconds since epoch) access token expires. Inf non-expiring tokens userinfo List containing user information fetched provider's userinfo endpoint (fetched)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthToken.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OAuthToken S7 class — OAuthToken","text":"","code":"# Please note: `get_userinfo()`, `introspect_token()`, and `refresh_token()` # are typically not called by users of this package directly, but are called # internally by `oauth_module_server()`. These functions are exported # nonetheless for advanced use cases. Most users will not need to # call these functions directly  # Example requires a real token from a completed OAuth flow # (code is therefore not run; would require user interaction) if (FALSE) { # \\dontrun{ # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Have a valid OAuthToken object; fake example below # (typically provided by `oauth_module_server()` or `handle_callback()`) token <- handle_callback(client, \"<code>\", \"<payload>\", \"<browser_token>\")  # Get userinfo user_info <- get_userinfo(client, token)  # Introspect token (if supported by provider) introspection <- introspect_token(client, token)  # Refresh token new_token <- refresh_token(client, token, introspect = TRUE) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/client_bearer_req.html","id":null,"dir":"Reference","previous_headings":"","what":"Build an authorized httr2 request with Bearer token — client_bearer_req","title":"Build an authorized httr2 request with Bearer token — client_bearer_req","text":"Convenience helper reduce boilerplate calling downstream APIs. creates httr2::request() given URL, attaches Authorization: Bearer <token> header, applies package's standard HTTP defaults (timeout User-Agent). Accepts either raw access token string OAuthToken object.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/client_bearer_req.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build an authorized httr2 request with Bearer token — client_bearer_req","text":"","code":"client_bearer_req(token, url, method = \"GET\", headers = NULL, query = NULL)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/client_bearer_req.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build an authorized httr2 request with Bearer token — client_bearer_req","text":"token Either OAuthToken object raw access token string. url absolute URL call. method Optional HTTP method (character). Defaults \"GET\". headers Optional named list named character vector extra headers set request. Header names case-insensitive. user-supplied Authorization header ignored ensure Bearer token set function overridden. query Optional named list query parameters append URL.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/client_bearer_req.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build an authorized httr2 request with Bearer token — client_bearer_req","text":"httr2 request object, ready customized performed httr2::req_perform().","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/client_bearer_req.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build an authorized httr2 request with Bearer token — client_bearer_req","text":"","code":"# Make request using OAuthToken object # (code is not run because it requires a real token from user interaction) if (FALSE) { # \\dontrun{ # Get OAuthToken # (typically provided as reactive return value by `oauth_module_server()`) token <- OAuthToken(...)  # Build request request <- client_bearer_req(   token,    \"https://api.example.com/resource\",    query = list(limit = 5) )  # Perform rquest response <- httr2::req_perform(request) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/custom_cache.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a custom cache backend (cachem-like) — custom_cache","title":"Create a custom cache backend (cachem-like) — custom_cache","text":"Builds minimal cachem-like cache backend object exposes cachem-compatible methods: $get(key, missing), $set(key, value), $remove(key), $info(). Use helper want plug custom state store JWKS cache 'shinyOAuth', cachem::cache_mem() cachem::cache_disk() suitable. may useful specifically deploy Shiny app multi-process environment non-sticky workers. cases, may want use shared external cache (e.g., database, Redis, Memcached). resulting object can used places 'shinyOAuth' accepts cache-like object: OAuthClient@state_store (requires $get, $set, $remove; optional $info) OAuthProvider@jwks_cache (requires $get, $set; optional $remove, $info) $info() method optional, provided returns list max_age (seconds), shinyOAuth align cookie/issued_at TTLs value.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/custom_cache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a custom cache backend (cachem-like) — custom_cache","text":"","code":"custom_cache(get, set, remove, info = NULL)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/custom_cache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a custom cache backend (cachem-like) — custom_cache","text":"get function(key, missing = NULL) -> value. Required. return stored value, missing argument key present. missing parameter mandatory OAuthClient OAuthProvider validators pass explicitly. set function(key, value) -> invisible(NULL). Required. store value given key remove function(key) -> logical sentinel. Required. state stores, enforces single-use eviction. backend performs atomic \"get--delete\" (e.g., SQL DELETE .. RETURNING), may supply function nothing returns TRUE. (login flow always attempt call $remove() $get() best-effort cleanup.) Recommended contract interoperability strong replay protection: Return TRUE key actually deleted already exist Return FALSE key deleted unknown key deleted return value TRUE, 'shinyOAuth' attempt retrieve value state store check may still present; fails (.e., key present), treat removal succesful. find key, produce error indicating removal succeed. info Function() -> list(max_age = seconds, ...). Optional may provided TTL information $info() used align browser cookie max age oauth_module_server()","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/custom_cache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a custom cache backend (cachem-like) — custom_cache","text":"R6 object exposing cachem-like $get/$set/$remove/$info methods","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/custom_cache.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a custom cache backend (cachem-like) — custom_cache","text":"","code":"mem <- new.env(parent = emptyenv())  my_cache <- custom_cache(   get = function(key, missing = NULL) {     base::get0(key, envir = mem, ifnotfound = missing, inherits = FALSE)   },    set = function(key, value) {     assign(key, value, envir = mem)     invisible(NULL)   },    remove = function(key) {     if (exists(key, envir = mem, inherits = FALSE)) {       rm(list = key, envir = mem)       return(TRUE) # signal successful deletion     }     return(FALSE) # key did not exist   },    info = function() list(max_age = 600) )  # Can be used as state_store: # oauth_client(..., state_store = my_cache)  # Or as JWKS cache: # oauth_provider(..., jwks_cache = my_cache)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/error_on_softened.html","id":null,"dir":"Reference","previous_headings":"","what":"Throw an error if any safety checks have been disabled — error_on_softened","title":"Throw an error if any safety checks have been disabled — error_on_softened","text":"function checks safety checks disabled via options intended local development use . options detected, error thrown prevent accidental use production environments.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/error_on_softened.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Throw an error if any safety checks have been disabled — error_on_softened","text":"","code":"error_on_softened()"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/error_on_softened.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Throw an error if any safety checks have been disabled — error_on_softened","text":"Invisible TRUE safety checks disabled; otherwise, error thrown.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/error_on_softened.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Throw an error if any safety checks have been disabled — error_on_softened","text":"checks following options: shinyOAuth.skip_browser_token: Skips browser cookie presence check shinyOAuth.skip_id_sig: Skips ID token signature verification shinyOAuth.print_errors: Enables printing error messages shinyOAuth.print_traceback: Enables printing tracebacks (opt-; default FALSE) shinyOAuth.expose_error_body: Exposes HTTP response bodies Note: Tracebacks treated \"softened\" behavior shinyOAuth.print_traceback option explicitly set TRUE. default FALSE, even interactive test sessions.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/error_on_softened.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Throw an error if any safety checks have been disabled — error_on_softened","text":"","code":"# Throw an error if any developer-only softening options are enabled error_on_softened()  # Below call would error (code is not run because of that) if (FALSE) { # \\dontrun{ options(shinyOAuth.skip_id_sig = TRUE) error_on_softened() } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/get_userinfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Get user info from OAuth 2.0 provider — get_userinfo","title":"Get user info from OAuth 2.0 provider — get_userinfo","text":"Fetches user information provider's userinfo endpoint using provided access token. Emits audit event redacted details.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/get_userinfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get user info from OAuth 2.0 provider — get_userinfo","text":"","code":"get_userinfo(oauth_client, token)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/get_userinfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get user info from OAuth 2.0 provider — get_userinfo","text":"oauth_client OAuthClient object. client must userinfo_url configured OAuthProvider. token Either OAuthToken object raw access token string.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/get_userinfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get user info from OAuth 2.0 provider — get_userinfo","text":"list containing user information returned provider.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/get_userinfo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get user info from OAuth 2.0 provider — get_userinfo","text":"","code":"# Please note: `get_userinfo()`, `introspect_token()`, and `refresh_token()` # are typically not called by users of this package directly, but are called # internally by `oauth_module_server()`. These functions are exported # nonetheless for advanced use cases. Most users will not need to # call these functions directly  # Example requires a real token from a completed OAuth flow # (code is therefore not run; would require user interaction) if (FALSE) { # \\dontrun{ # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Have a valid OAuthToken object; fake example below # (typically provided by `oauth_module_server()` or `handle_callback()`) token <- handle_callback(client, \"<code>\", \"<payload>\", \"<browser_token>\")  # Get userinfo user_info <- get_userinfo(client, token)  # Introspect token (if supported by provider) introspection <- introspect_token(client, token)  # Refresh token new_token <- refresh_token(client, token, introspect = TRUE) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/handle_callback.html","id":null,"dir":"Reference","previous_headings":"","what":"Handle OAuth 2.0 callback: verify state, swap code for token, verify token — handle_callback","title":"Handle OAuth 2.0 callback: verify state, swap code for token, verify token — handle_callback","text":"Handle OAuth 2.0 callback: verify state, swap code token, verify token","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/handle_callback.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handle OAuth 2.0 callback: verify state, swap code for token, verify token — handle_callback","text":"","code":"handle_callback(   oauth_client,   code,   payload,   browser_token,   decrypted_payload = NULL,   state_store_values = NULL )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/handle_callback.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handle OAuth 2.0 callback: verify state, swap code for token, verify token — handle_callback","text":"oauth_client OAuthClient object representing OAuth client configuration. code authorization code received OAuth provider callback. payload encrypted state payload received OAuth provider callback (value generated sent prepare_call()). browser_token Browser token present user's session (managed oauth_module_server() match one used prepare_call()). decrypted_payload Optional pre-decrypted validated payload list (returned state_decrypt_gcm() followed internal validation). Supplying allows callers validate bind state main thread dispatching background worker async flows. state_store_values Optional pre-fetched state store entry (list browser_token, pkce_code_verifier, nonce). supplied, function skip reading/removing oauth_client@state_store use provided values instead. supports async flows prefetch remove single-use state entry main thread avoid cross-process cache visibility issues.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/handle_callback.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handle OAuth 2.0 callback: verify state, swap code for token, verify token — handle_callback","text":"OAuthToken` object containing access token, refresh token, expiration time, user information (requested), ID token (applicable). step process fails (e.g., state verification, token exchange, token validation), error thrown indicating failure reason.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/handle_callback.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Handle OAuth 2.0 callback: verify state, swap code for token, verify token — handle_callback","text":"","code":"# Please note: `prepare_callback()` & `handle_callback()` are typically # not called by users of this package directly, but are called  # internally by `oauth_module_server()`. These functions are exported # nonetheless for advanced use cases. Most users will not need to # call these functions directly  # Below code shows generic usage of `prepare_callback()` and `handle_callback()` # (code is not run because it would require user interaction) if (FALSE) { # \\dontrun{ # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Get authorization URL and and store state in client's state store # `<browser_token>` is a token that identifies the browser session #  and would typically be stored in a browser cookie #  (`oauth_module_server()` handles this typically) authorization_url <- prepare_callback(client, \"<browser_token>\")  # Redirect user to authorization URL; retrieve code & payload from query; # read also `<browser_token>` from browser cookie # (`oauth_module_server()` handles this typically) code <- \"...\" payload <- \"...\" browser_token <- \"...\"  # Handle callback, exchanging code for token and validating state # (`oauth_module_server()` handles this typically) token <- handle_callback(client, code, payload, browser_token) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/introspect_token.html","id":null,"dir":"Reference","previous_headings":"","what":"Introspect an OAuth 2.0 token — introspect_token","title":"Introspect an OAuth 2.0 token — introspect_token","text":"Introspects access refresh token using RFC 7662 provider exposes introspection endpoint. Returns list including least supported (logical) active (logical|NA) parsed response () raw. Authentication introspection endpoint mirrors provider's token_auth_style: \"header\" (default): HTTP Basic client_id/client_secret. \"body\": form fields client_id (available) client_secret. \"client_secret_jwt\" / \"private_key_jwt\": signed JWT client assertion generated (RFC 7523) sent via client_assertion_type client_assertion, aud set provider's introspection_url.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/introspect_token.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Introspect an OAuth 2.0 token — introspect_token","text":"","code":"introspect_token(   oauth_client,   oauth_token,   which = c(\"access\", \"refresh\"),   async = FALSE )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/introspect_token.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Introspect an OAuth 2.0 token — introspect_token","text":"oauth_client OAuthClient object oauth_token OAuthToken object introspect token introspect: \"access\" (default) \"refresh\". async Logical, default FALSE. TRUE promises available, run background return promise resolving result list","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/introspect_token.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Introspect an OAuth 2.0 token — introspect_token","text":"list fields: supported, active, raw, status","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/introspect_token.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Introspect an OAuth 2.0 token — introspect_token","text":"Best-effort semantics: provider expose introspection endpoint, function returns supported = FALSE, active = NA, status = \"introspection_unsupported\". endpoint responds HTTP error (e.g., 404/500) body parsed include usable active field, function throw. returns supported = TRUE, active = NA, descriptive status (example, \"http_404\"). context, NA means \"unknown\" break flows unless code explicitly requires definitive result (.e., isTRUE(result$active)). Providers vary encode RFC 7662 active field (logical, numeric, character variants like \"true\"/\"false\", 1/0). normalized logical TRUE/FALSE possible; otherwise active set NA.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/introspect_token.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Introspect an OAuth 2.0 token — introspect_token","text":"","code":"# Please note: `get_userinfo()`, `introspect_token()`, and `refresh_token()` # are typically not called by users of this package directly, but are called # internally by `oauth_module_server()`. These functions are exported # nonetheless for advanced use cases. Most users will not need to # call these functions directly  # Example requires a real token from a completed OAuth flow # (code is therefore not run; would require user interaction) if (FALSE) { # \\dontrun{ # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Have a valid OAuthToken object; fake example below # (typically provided by `oauth_module_server()` or `handle_callback()`) token <- handle_callback(client, \"<code>\", \"<payload>\", \"<browser_token>\")  # Get userinfo user_info <- get_userinfo(client, token)  # Introspect token (if supported by provider) introspection <- introspect_token(client, token)  # Refresh token new_token <- refresh_token(client, token, introspect = TRUE) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/is_ok_host.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if URL(s) are HTTPS and/or in allowed hosts lists — is_ok_host","title":"Check if URL(s) are HTTPS and/or in allowed hosts lists — is_ok_host","text":"Returns TRUE every input URL either: syntactically valid HTTPS URL, (set) whose host matches allowed_hosts, HTTP URL whose host matches allowed_non_https_hosts (e.g. localhost, 127.0.0.1, ::1), (set) also matches allowed_hosts. input omits scheme (e.g., \"localhost:8080/cb\"), function first attempt validate HTTP (useful loopback development), fails, HTTPS. mirrors helpers normalize inputs convenience still enforcing host scheme policies. allowed_hosts thus allowlist hosts/domains permitted, allowed_non_https_hosts defines hosts allowed use HTTP instead HTTPS. allowed_hosts NULL length 0, hosts allowed (subject scheme rules), HTTPS still required unless host allowed_non_https_hosts. Since allowed_hosts supports globs, value like \"*\" matches host therefore effectively disables endpoint host restrictions. use catch‑pattern truly intend allow host. deployments pin expected domain(s), e.g. c(\".example.com\") specific host name. Wildcards: allowed_hosts allowed_non_https_hosts support globs: * = chars, ? = one char. leading .example.com matches domain subdomain. non-URLs, NAs, empty strings cause FALSE result.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/is_ok_host.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if URL(s) are HTTPS and/or in allowed hosts lists — is_ok_host","text":"","code":"is_ok_host(   url,   allowed_non_https_hosts = getOption(\"shinyOAuth.allowed_non_https_hosts\", default =     c(\"localhost\", \"127.0.0.1\", \"::1\", \"[::1]\")),   allowed_hosts = getOption(\"shinyOAuth.allowed_hosts\", default = NULL) )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/is_ok_host.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if URL(s) are HTTPS and/or in allowed hosts lists — is_ok_host","text":"url Single URL vector URLs (character; length 1 ) allowed_non_https_hosts Character vector hostnames allowed use HTTP instead HTTPS. Defaults localhost equivalents. Supports globs allowed_hosts Optional allowlist hosts/domains; supplied (length > 0), hosts permitted. Supports globs","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/is_ok_host.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if URL(s) are HTTPS and/or in allowed hosts lists — is_ok_host","text":"Logical indicator (TRUE URLs pass checks; FALSE otherwise)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/is_ok_host.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check if URL(s) are HTTPS and/or in allowed hosts lists — is_ok_host","text":"function used internally validate redirect URIs OAuth clients, can used elsewhere test URLs allowed. Internally, always determine default values allowed_non_https_hosts allowed_hosts options shinyOAuth.allowed_non_https_hosts shinyOAuth.allowed_hosts, respectively.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/is_ok_host.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if URL(s) are HTTPS and/or in allowed hosts lists — is_ok_host","text":"","code":"# HTTPS allowed by default is_ok_host(\"https://example.com\") #> [1] TRUE  # HTTP allowed for localhost is_ok_host(\"http://localhost:8100\") #> [1] TRUE  # Restrict to a specific domain (allowlist) is_ok_host(\"https://api.example.com\", allowed_hosts = c(\".example.com\")) #> [1] TRUE  # Caution: a catch-all pattern disables host restrictions # (only scheme rules remain). Avoid unless you truly intend it is_ok_host(\"https://anywhere.example\", allowed_hosts = c(\"*\")) #> [1] TRUE"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_client.html","id":null,"dir":"Reference","previous_headings":"","what":"Create generic OAuthClient — oauth_client","title":"Create generic OAuthClient — oauth_client","text":"Create generic OAuthClient","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_client.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create generic OAuthClient — oauth_client","text":"","code":"oauth_client(   provider,   client_id = Sys.getenv(\"OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"OAUTH_CLIENT_SECRET\"),   redirect_uri,   scopes = character(0),   state_store = cachem::cache_mem(max_age = 300),   state_entropy = 64,   state_key = random_urlsafe(128),   client_private_key = NULL,   client_private_key_kid = NULL,   client_assertion_alg = NULL )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_client.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create generic OAuthClient — oauth_client","text":"provider OAuthProvider object client_id OAuth client ID client_secret OAuth client secret. Validation rules: Required (non-empty) provider authenticates client HTTP Basic auth token endpoint (token_auth_style = \"header\", also known client_secret_basic). Optional public PKCE-clients provider configured use_pkce = TRUE uses form-body client authentication token endpoint (token_auth_style = \"body\", also known client_secret_post). case, secret omitted token requests. Note: provider issues HS256 ID tokens id_token_validation enabled, non-empty client_secret required signature validation. redirect_uri Redirect URI registered provider scopes Vector scopes request state_store State storage backend. Defaults cachem::cache_mem(max_age = 300). Alternative backends include cachem::cache_disk() custom implementation (can create custom_cache(). backend must implement cachem-like methods $get(key, missing), $set(key, value), $remove(key); $info() optional. Trade-offs: cache_mem -memory thus scoped single R process (good default single Shiny process). cache_disk persists disk can shared across multiple R processes (useful multi-process deployments Shiny workers sticky). custom_cache() backend use database external store (e.g., Redis, Memcached). See also vignette(\"usage\", package = \"shinyOAuth\"). client automatically generates, persists (state_store), validates OAuth state parameter (OIDC nonce applicable) authorization code flow state_entropy Integer. length (characters) randomly generated state parameter. Higher values provide entropy better security CSRF attacks. Must 22 128 (align validate_state()'s default minimum targets ~128 bits base64url‑like strings). Default 64, provides approximately 384 bits entropy state_key Optional per-client secret used state sealing key AES-GCM AEAD (authenticated encryption) state payload travels via state query parameter. provides confidentiality integrity (via authentication tag) embedded data used callback verification. omit argument, random value generated via random_urlsafe(128). key distinct OAuth client_secret may used public clients. Type: character string (>= 32 bytes encoded) raw vector (>= 32 bytes). Raw keys enable direct use high-entropy secrets external stores. forms normalized internally cryptographic helpers. Multi-process deployments: app runs multiple R workers behind non-sticky load balancer, must configure shared state_store state_key across workers. Otherwise callbacks land different worker unable decrypt/validate state envelope authentication fail. environments, rely random per-process default: provide explicit, high-entropy key (example via secret store environment variable). Prefer values substantial entropy (e.g., 64–128 base64url characters raw 32+ byte key). Avoid human‑memorable passphrases. See also vignette(\"usage\", package = \"shinyOAuth\"). client_private_key Optional private key private_key_jwt client authentication token endpoint. Can openssl::key PEM string containing private key. Required provider's token_auth_style = 'private_key_jwt'. Ignored auth styles. client_private_key_kid Optional key identifier (kid) include JWT header private_key_jwt assertions. Useful authorization server uses kid select correct verification key. client_assertion_alg Optional JWT signing algorithm use client assertions. omitted, defaults HS256 client_secret_jwt. private_key_jwt, compatible default selected based private key type/curve (e.g., RS256 RSA, ES256/ES384/ES512 EC P-256/384/521, EdDSA Ed25519/Ed448). explicit value provided incompatible key, validation fails early configuration error. Supported values HS256, HS384, HS512 client_secret_jwt asymmetric algorithms supported jose::jwt_encode_sig (e.g., RS256, PS256, ES256, EdDSA) private keys.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_client.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create generic OAuthClient — oauth_client","text":"OAuthClient object","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_client.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create generic OAuthClient — oauth_client","text":"","code":"# Example requires a configured app & credentials # (code is therefore not run) # (go to https://github.com/settings/developers to create a GitHub OAuth app) if (FALSE) { # \\dontrun{ library(shiny) library(shinyOAuth)  # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Example app with auto-redirect (1) -----------------------------------------  ui_1 <- fluidPage(   use_shinyOAuth(),   uiOutput(\"login\") )  server_1 <- function(input, output, session) {   # Auto-redirect (default):   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = TRUE   )      output$login <- renderUI({     if (auth$authenticated) {       user_info <- auth$token@userinfo       tagList(         tags$p(\"You are logged in!\"),         tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))       )     } else {       tags$p(\"You are not logged in.\")     }   }) }  app_1 <- shinyApp(ui_1, server_1) runApp(app_1, port = 8100)   # Example app with manual login button (2) -----------------------------------  ui_2 <- fluidPage(   use_shinyOAuth(),   actionButton(\"login_btn\", \"Login\"),   uiOutput(\"login\") )  server_2 <- function(input, output, session) {   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = FALSE   )      observeEvent(input$login_btn, {     auth$request_login()   })      output$login <- renderUI({     if (auth$authenticated) {       user_info <- auth$token@userinfo       tagList(         tags$p(\"You are logged in!\"),         tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))       )     } else {       tags$p(\"You are not logged in.\")     }   }) }  app_2 <- shinyApp(ui_2, server_2) runApp(app_2, port = 8100)  # Example app requesting additional resource with access token ---------------  # Below app shows the authenticated username + their GitHub repositories, # fetched via GitHub API using the access token obtained during login  ui_3 <- fluidPage(   use_shinyOAuth(),   uiOutput(\"ui\") )  server_3 <- function(input, output, session) {   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = TRUE   )      repositories <- reactiveVal(NULL)      observe({     req(auth$authenticated)          # Example additional API request using the access token     # (e.g., fetch user repositories from GitHub)     req <- client_bearer_req(auth$token, \"https://api.github.com/user/repos\")     resp <- httr2::req_perform(req)          if (httr2::resp_is_error(resp)) {       repositories(NULL)     } else {       repos_data <- httr2::resp_body_json(resp, simplifyVector = TRUE)       repositories(repos_data)     }   })      # Render username + their repositories   output$ui <- renderUI({     if (isTRUE(auth$authenticated)) {       user_info <- auth$token@userinfo       repos <- repositories()              return(tagList(         tags$p(paste(\"You are logged in as:\", user_info$login)),         tags$h4(\"Your repositories:\"),         if (!is.null(repos)) {           tags$ul(             Map(function(url, name) {               tags$li(tags$a(href = url, target = \"_blank\", name))             }, repos$html_url, repos$full_name)           )         } else {           tags$p(\"Loading repositories...\")         }       ))     }          return(tags$p(\"You are not logged in.\"))   }) }  app_3 <- shinyApp(ui_3, server_3) runApp(app_3, port = 8100) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_module_server.html","id":null,"dir":"Reference","previous_headings":"","what":"OAuth 2.0 & OIDC authentication module for Shiny applications — oauth_module_server","title":"OAuth 2.0 & OIDC authentication module for Shiny applications — oauth_module_server","text":"function implements Shiny module server manages OAuth 2.0/OIDC authentication Shiny applications. handles OAuth 2.0/OIDC flow, including redirecting users authorization endpoint, securely processing callback, exchanging authorization codes tokens, verifying tokens, managing token refresh. also provides options automatic manual login flows, session expiry, proactive token refresh. Note: using module, must include shinyOAuth::use_shinyOAuth() UI definition load necessary JavaScript dependencies.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_module_server.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OAuth 2.0 & OIDC authentication module for Shiny applications — oauth_module_server","text":"","code":"oauth_module_server(   id,   client,   auto_redirect = TRUE,   async = FALSE,   indefinite_session = FALSE,   reauth_after_seconds = NULL,   refresh_proactively = FALSE,   refresh_lead_seconds = 60,   refresh_check_interval = 10000,   tab_title_cleaning = TRUE,   tab_title_replacement = NULL,   browser_cookie_path = NULL,   browser_cookie_samesite = c(\"Strict\", \"Lax\", \"None\") )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_module_server.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OAuth 2.0 & OIDC authentication module for Shiny applications — oauth_module_server","text":"id Shiny module id client OAuthClient object auto_redirect TRUE (default), unauthenticated sessions immediately initiate OAuth flow redirecting browser authorization endpoint. FALSE, module auto-redirect; instead, returned object exposes helpers triggering login manually (use: $request_login()) async TRUE, performs token exchange refresh background using promises package (future_promise), updates values promise resolves. Requires promises package suitable backend configured future::plan(). FALSE (default), token exchange refresh performed synchronously (may block Shiny event loop; thus strongly recommended set async = TRUE production apps) indefinite_session TRUE, module automatically clear token due access-token expiry reauth_after_seconds window, trigger automatic reauthentication token expires refresh fails. effectively makes sessions \"indefinite\" module's perspective user logged . Note API calls may still fail provider considers token expired; option affects module's automatic clearing/redirect behavior reauth_after_seconds Optional maximum session age seconds. set, module remove token (thus set authenticated FALSE) many seconds elapsed since authentication started. default NULL (forced re-authentication). value provided, timer reset successful refresh knob opt-counts rolling session age refresh_proactively TRUE, automatically refresh tokens expire (refresh token available). refresh scheduled adaptively executes approximately expires_at - refresh_lead_seconds rather coarse polling loop refresh_lead_seconds Number seconds expiry attempt proactive refresh (default: 60) refresh_check_interval Fallback check interval milliseconds expiry/refresh (default: 10000 ms). expiry known, module uses adaptive scheduling wake exactly needed; interval used safety net expiry unknown/infinite tab_title_cleaning TRUE (default), removes query string suffix browser tab title OAuth callback, titles like \"localhost:8100?code=...&state=...\" become \"localhost:8100\" tab_title_replacement Optional character string explicitly set browser tab title OAuth callback. provided, takes precedence tab_title_cleaning browser_cookie_path Optional cookie Path scope browser token cookie. default (NULL), path fixed \"/\" reliable clearing across route changes. Provide explicit path (e.g., \"/app\") narrow cookie's scope sub-route. Note: path \"/\" page served HTTPS, cookie name uses __Host- prefix (Secure, Path=/) additional hardening; path \"/\", regular cookie name used. apps deployed nested routes OAuth callback may land different route initial page, keeping default (root path) ensures browser token cookie available clearable across app routes. deliberately scope cookie sub-path, make sure relevant routes share prefix. browser_cookie_samesite SameSite value browser-token cookie. One \"Strict\", \"Lax\", \"None\". Defaults \"Strict\" maximum protection cross-site request forgery. Use \"Lax\" deployment requires cookie accompany top-level cross-site navigations (example, reverse-proxy flows), document associated risk. set \"None\", cookie marked SameSite=None; Secure browser, authentication error non-HTTPS origins browsers reject SameSite=None cookies without Secure attribute","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_module_server.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"OAuth 2.0 & OIDC authentication module for Shiny applications — oauth_module_server","text":"reactiveValues object token, error, error_description, authenticated, plus additional fields used module. returned reactiveValues contains following fields: authenticated: logical TRUE error token present valid (matching verifications enabled client provider); FALSE otherwise. token: OAuthToken object, NULL yet authenticated. contains access token, refresh token (), ID token (), userinfo (fetched). See OAuthToken details. Note since OAuthToken S7 object, access fields @, e.g., token@userinfo. error: error code string OAuth flow fails. careful exposing directly users, may contain sensitive information aid attacker. error_description: human-readable error detail available. extra careful exposing directly users, may contain even sensitive information aid attacker. browser_token: internal opaque browser cookie value; used state double-submit protection; NULL yet set pending_callback: internal list(code, state); used defer token exchange browser_token available; NULL otherwise. pending_login: internal logical; TRUE login requested must wait browser_token set, FALSE otherwise. auto_redirected: internal logical; TRUE module initiated automatic redirect session avoid duplicate redirects. reauth_triggered: internal logical; TRUE reauthentication attempt initiated (expiry failed refresh), avoid loops. auth_started_at: internal numeric timestamp (Sys.time()) authentication started; NA yet authenticated. Used enforce reauth_after_seconds set. token_stale: logical; TRUE token kept despite refresh failure indefinite_session = TRUE, access token past expiry indefinite_session = TRUE prevents automatic clearing. lets UIs warn users disable actions require fresh token. resets FALSE successful login, refresh, logout. last_login_async_used: internal logical; TRUE last login attempt used async = TRUE, FALSE synchronous. used testing diagnostics. refresh_in_progress: internal logical; TRUE token refresh currently flight (async sync). Used prevent concurrent refresh attempts proactive refresh logic wakes multiple times. also contains following helper functions, mainly useful auto_redirect = FALSE want implement manual login flow (e.g., button): request_login(): initiates login redirecting authorization endpoint, cookie-ensure semantics: browser_token missing, module sets cookie defers redirect browser_token present, redirects. main entry point login auto_redirect = FALSE want trigger login UI logout(): clears current token setting authenticated FALSE, clears browser token cookie. might call user clicks \"logout\" button build_auth_url(): internal; builds returns authorization URL, also storing relevant state client's state_store (validation callback). Note requires browser_token present, throw error called early (verify has_browser_token() first). Typically call directly, use request_login() instead, calls internally. set_browser_token(): internal; injects JS set browser token cookie missing. Normally called automatically first load, can call manually needed. token already present, return immediately without changing (call clear_browser_token() want force reset). Typically call directly, use request_login() instead, calls internally needed. clear_browser_token(): internal; injects JS clear browser token cookie clears browser_token. might call reset cookie suspect stale compromised. Typically call directly. has_browser_token(): internal; returns TRUE browser_token present (non-NULL, non-empty), FALSE otherwise. Typically call directly","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_module_server.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"OAuth 2.0 & OIDC authentication module for Shiny applications — oauth_module_server","text":"Blocking vs. async behavior: async = FALSE (default), network operations like token exchange refresh performed main R thread. Transient errors retried package's internal req_with_retry() helper, currently uses Sys.sleep() backoff. Shiny, Sys.sleep() blocks event loop entire worker process, potentially freezing UI updates sessions worker slow provider responses retry backoff. keep UI responsive: set async = TRUE network calls run background future via promises package (configure multisession/multicore backend), reduce/block retries (see vignette(\"usage\", package = \"shinyOAuth\")). Browser requirements: module relies browser's Web Crypto API generate secure, per-session browser token used state double-submit protection. Specifically, login flow requires window.crypto.getRandomValues available. present (example, old highly locked-browsers), module unable proceed authentication. case client-side error emitted surfaced server shinyOAuth_cookie_error containing message \"webcrypto_unavailable\". Use modern browser (enable Web Crypto) resolve . Browser cookie lifetime: opaque browser token cookie lifetime mirrors client's state_store TTL. Internally, module reads client@state_store$info()$max_age uses value cookie's Max-Age/Expires. cache expose finite max_age, conservative default 5 minutes (300 seconds) used align built-cachem::cache_mem(max_age = 300) default state payload's issued_at validation window. Watchdog missing browser token: catch misconfiguration early development, module includes short watchdog. browser token cookie set within 1500ms module initialization, warning emitted R console. likely means forgot include use_shinyOAuth() UI, may also indicate user app using browser JavaScript disabled. watchdog prints warning per R session, want suppress permanently, can set options(shinyOAuth.disable_watchdog_warning = TRUE).","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_module_server.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OAuth 2.0 & OIDC authentication module for Shiny applications — oauth_module_server","text":"","code":"# Example requires a configured app & credentials # (code is therefore not run) # (go to https://github.com/settings/developers to create a GitHub OAuth app) if (FALSE) { # \\dontrun{ library(shiny) library(shinyOAuth)  # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Example app with auto-redirect (1) -----------------------------------------  ui_1 <- fluidPage(   use_shinyOAuth(),   uiOutput(\"login\") )  server_1 <- function(input, output, session) {   # Auto-redirect (default):   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = TRUE   )      output$login <- renderUI({     if (auth$authenticated) {       user_info <- auth$token@userinfo       tagList(         tags$p(\"You are logged in!\"),         tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))       )     } else {       tags$p(\"You are not logged in.\")     }   }) }  app_1 <- shinyApp(ui_1, server_1) runApp(app_1, port = 8100)   # Example app with manual login button (2) -----------------------------------  ui_2 <- fluidPage(   use_shinyOAuth(),   actionButton(\"login_btn\", \"Login\"),   uiOutput(\"login\") )  server_2 <- function(input, output, session) {   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = FALSE   )      observeEvent(input$login_btn, {     auth$request_login()   })      output$login <- renderUI({     if (auth$authenticated) {       user_info <- auth$token@userinfo       tagList(         tags$p(\"You are logged in!\"),         tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))       )     } else {       tags$p(\"You are not logged in.\")     }   }) }  app_2 <- shinyApp(ui_2, server_2) runApp(app_2, port = 8100)  # Example app requesting additional resource with access token ---------------  # Below app shows the authenticated username + their GitHub repositories, # fetched via GitHub API using the access token obtained during login  ui_3 <- fluidPage(   use_shinyOAuth(),   uiOutput(\"ui\") )  server_3 <- function(input, output, session) {   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = TRUE   )      repositories <- reactiveVal(NULL)      observe({     req(auth$authenticated)          # Example additional API request using the access token     # (e.g., fetch user repositories from GitHub)     req <- client_bearer_req(auth$token, \"https://api.github.com/user/repos\")     resp <- httr2::req_perform(req)          if (httr2::resp_is_error(resp)) {       repositories(NULL)     } else {       repos_data <- httr2::resp_body_json(resp, simplifyVector = TRUE)       repositories(repos_data)     }   })      # Render username + their repositories   output$ui <- renderUI({     if (isTRUE(auth$authenticated)) {       user_info <- auth$token@userinfo       repos <- repositories()              return(tagList(         tags$p(paste(\"You are logged in as:\", user_info$login)),         tags$h4(\"Your repositories:\"),         if (!is.null(repos)) {           tags$ul(             Map(function(url, name) {               tags$li(tags$a(href = url, target = \"_blank\", name))             }, repos$html_url, repos$full_name)           )         } else {           tags$p(\"Loading repositories...\")         }       ))     }          return(tags$p(\"You are not logged in.\"))   }) }  app_3 <- shinyApp(ui_3, server_3) runApp(app_3, port = 8100) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider.html","id":null,"dir":"Reference","previous_headings":"","what":"Create generic OAuthProvider — oauth_provider","title":"Create generic OAuthProvider — oauth_provider","text":"Helper function create OAuthProvider object. function provides sensible defaults infers settings based provided parameters.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create generic OAuthProvider — oauth_provider","text":"","code":"oauth_provider(   name,   auth_url,   token_url,   userinfo_url = NA_character_,   introspection_url = NA_character_,   issuer = NA_character_,   use_nonce = NULL,   use_pkce = TRUE,   pkce_method = \"S256\",   userinfo_required = NULL,   userinfo_id_token_match = NULL,   userinfo_id_selector = function(userinfo) userinfo$sub,   id_token_required = NULL,   id_token_validation = NULL,   extra_auth_params = list(),   extra_token_params = list(),   extra_token_headers = character(),   token_auth_style = \"header\",   jwks_cache = NULL,   jwks_pins = character(),   jwks_pin_mode = \"any\",   jwks_host_issuer_match = NULL,   jwks_host_allow_only = NULL,   allowed_algs = c(\"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\",     \"ES384\", \"ES512\", \"EdDSA\"),   allowed_token_types = NULL,   leeway = getOption(\"shinyOAuth.leeway\", 30) )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create generic OAuthProvider — oauth_provider","text":"name Provider name (e.g., \"github\", \"google\"). Cosmetic ; used logging audit events auth_url Authorization endpoint URL token_url Token endpoint URL userinfo_url User info endpoint URL (optional) introspection_url Token introspection endpoint URL (optional; RFC 7662) issuer OIDC issuer URL (optional; required ID token validation). base URL identifies OpenID Provider (OP). used ID token validation verify iss claim ID token matches expected issuer. also used fetch provider's JSON Web Key Set (JWKS) verifying ID token signatures (typically via OIDC discovery document located /.well-known/openid-configuration relative issuer URL) use_nonce Whether use OIDC nonce. adds nonce parameter authorization request validates nonce claim ID token. recommended OIDC flows mitigate replay attacks use_pkce Whether use PKCE. adds code_challenge parameter authorization request requires code_verifier exchanging authorization code tokens. prevents authorization code interception attacks pkce_method PKCE code challenge method (\"S256\" \"plain\"). \"S256\" recommended. \"plain\" used non-compliant providers support \"S256\" userinfo_required Whether fetch userinfo token exchange. User information stored userinfo field returned OAuthToken object. requires valid userinfo_url set. fetching userinfo fails, token exchange fail. low-level constructor oauth_provider(), explicitly supplied, inferred presence non-empty userinfo_url: userinfo_url provided, userinfo_required defaults TRUE, otherwise defaults FALSE. avoids unexpected validation errors userinfo_url omitted (since optional). userinfo_id_token_match Whether verify user ID (\"sub\") ID token matches user ID extracted userinfo response. requires userinfo_required id_token_validation TRUE (thus valid userinfo_url issuer set, plus potentially setting client's scope include \"openid\", ID token returned). Furthermore, provider's userinfo_id_selector must configured extract user ID userinfo response. check helps ensure integrity user information confirming sources agree user's identity. oauth_provider(), explicitly supplied, inferred TRUE userinfo_required id_token_validation TRUE; otherwise defaults FALSE. userinfo_id_selector function extracts user ID userinfo response.#' take single argument (userinfo list) return user ID string. used userinfo_id_token_match TRUE. Optional otherwise; supplied, features (like subject matching) unavailable. Helper constructors like oauth_provider() oauth_provider_oidc() provide default selector extracts sub field. id_token_required Whether require ID token returned token exchange. ID token returned, token exchange fail. requires provider valid OpenID Connect provider may require setting client's scope include \"openid\". Note: S7 class level, defaults FALSE pure OAuth 2.0 providers can configured without OIDC. Helper constructors like oauth_provider() oauth_provider_oidc() enable issuer supplied OIDC explicitly requested. id_token_validation Whether perform ID token validation token exchange. requires provider valid OpenID Connect provider configured issuer token response include ID token (may require setting client's scope include \"openid\"). Note: S7 class level, defaults FALSE. Helper constructors like oauth_provider() oauth_provider_oidc() turn issuer provided OIDC used. extra_auth_params Extra parameters authorization URL extra_token_params Extra parameters token exchange extra_token_headers Extra headers token exchange requests (named character vector) token_auth_style authenticate exchanging tokens. One : \"header\": HTTP Basic (client_secret_basic) \"body\": Form body (client_secret_post) \"client_secret_jwt\": JWT client assertion signed HMAC using client_secret (RFC 7523) \"private_key_jwt\": JWT client assertion signed asymmetric key (RFC 7523) jwks_cache JWKS cache backend. provided, cachem::cache_mem(max_age = 3600) (1 hour) cache created. May cachem‑compatible backend, including cachem::cache_disk() filesystem cache shared across workers, custom implementation created via custom_cache() (e.g., database/Redis backed). TTL guidance: Choose max_age line identity platform’s JWKS rotation cache‑control cadence. range 15 minutes 2 hours typically sensible; default 1 hour. Shorter TTLs adopt new keys faster cost JWKS traffic; longer TTLs reduce traffic may delay new keys slightly. Signature verification automatically perform one‑time JWKS refresh new kid appears ID token. Cache keys internal, hashed issuer pinning configuration. Cache values lists elements jwks fetched_at (numeric epoch seconds) jwks_pins Optional character vector RFC 7638 JWK thumbprints (base64url) pin . non-empty, fetched JWKS must contain keys whose thumbprints match values depending jwks_pin_mode. Use reduce key substitution risks pre-authorizing expected keys jwks_pin_mode Pinning policy jwks_pins provided. Either \"\" (default; least one key JWKS must match) \"\" (every RSA/EC public key JWKS must match one configured pins) jwks_host_issuer_match TRUE, enforce discovery jwks_uri host matches issuer host (subdomain). Defaults FALSE class level, helper constructors OIDC (e.g., oauth_provider_oidc() oauth_provider_oidc_discover()) enable default safer config. generic helper oauth_provider() also automatically set TRUE issuer provided either id_token_validation id_token_required TRUE (OIDC-like configuration). Set explicitly FALSE opt . providers legitimately publish JWKS different host (e.g., Google), prefer setting jwks_host_allow_only exact hostname rather disabling check jwks_host_allow_only Optional explicit hostname jwks_uri must match. provided, jwks_uri host must equal value (exact match). can pass either just host (e.g., \"www.googleapis.com\") full URL; host component used. Takes precedence jwks_host_issuer_match allowed_algs Optional vector allowed JWT algorithms ID tokens. Use restrict acceptable alg values per-provider basis. Supported asymmetric algorithms include RS256, RS384, RS512, PS256, PS384, PS512, ES256, ES384, ES512, EdDSA (Ed25519/Ed448 via OKP). Symmetric HMAC algorithms HS256, HS384, HS512 also supported require supply client_secret explicitly enable HMAC verification via option options(shinyOAuth.allow_hs = TRUE). Defaults c(\"RS256\",\"RS384\",\"RS512\",\"PS256\",\"PS384\",\"PS512\", \"ES256\",\"ES384\",\"ES512\",\"EdDSA\"), intentionally excludes HS*. include HS* certain client_secret stored strictly server-side never shipped , derivable , browser untrusted environments. Prefer rotating secrets regularly enabling . allowed_token_types Character vector acceptable OAuth token types returned token endpoint (case-insensitive). non-empty, token response MUST include token_type must one allowed values; otherwise flow fails fast shinyOAuth_token_error. empty, check performed token_type may omitted provider. Helper constructors default strictly: oauth_provider() issuer supplied OIDC flags enabled, allowed_token_types defaults c(\"Bearer\") enforce Bearer default; otherwise remains empty. can override widen disable enforcement setting explicitly leeway Clock skew leeway (seconds) applied ID token exp/iat checks. Default 30. Can globally overridden via option shinyOAuth.leeway","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create generic OAuthProvider — oauth_provider","text":"OAuthProvider object","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create generic OAuthProvider — oauth_provider","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional; S   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure OIDC provider via OIDC discovery # (example requires network access; is therefore not run) if (FALSE) { # \\dontrun{ oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://accounts.google.com\" ) } # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Other providers # (all requiring network access; example is therefore not run) if (FALSE) { # \\dontrun{ # Slack via OIDC discovery slack_provider <- oauth_provider_slack()  # Keycloak # (requires configured Keycloak realm) oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\")  # Auth0 # (requires configured Auth0 domain) oauth_provider_auth0(domain = \"your-tenant.auth0.com\")  # Okta # (requires configured Okta domain) oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_auth0.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an Auth0 OAuthProvider (via OIDC discovery) — oauth_provider_auth0","title":"Create an Auth0 OAuthProvider (via OIDC discovery) — oauth_provider_auth0","text":"Create Auth0 OAuthProvider (via OIDC discovery)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_auth0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an Auth0 OAuthProvider (via OIDC discovery) — oauth_provider_auth0","text":"","code":"oauth_provider_auth0(domain, name = \"auth0\", audience = NULL)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_auth0.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an Auth0 OAuthProvider (via OIDC discovery) — oauth_provider_auth0","text":"domain Auth0 domain, e.g., \"-domain.auth0.com\" name Optional provider name (default \"auth0\") audience Optional audience request auth flows","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_auth0.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an Auth0 OAuthProvider (via OIDC discovery) — oauth_provider_auth0","text":"OAuthProvider object configured specified Auth0 domain","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_auth0.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an Auth0 OAuthProvider (via OIDC discovery) — oauth_provider_auth0","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional; S   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure OIDC provider via OIDC discovery # (example requires network access; is therefore not run) if (FALSE) { # \\dontrun{ oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://accounts.google.com\" ) } # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Other providers # (all requiring network access; example is therefore not run) if (FALSE) { # \\dontrun{ # Slack via OIDC discovery slack_provider <- oauth_provider_slack()  # Keycloak # (requires configured Keycloak realm) oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\")  # Auth0 # (requires configured Auth0 domain) oauth_provider_auth0(domain = \"your-tenant.auth0.com\")  # Okta # (requires configured Okta domain) oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_github.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a GitHub OAuthProvider — oauth_provider_github","title":"Create a GitHub OAuthProvider — oauth_provider_github","text":"Pre-configured OAuth 2.0 provider GitHub.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_github.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a GitHub OAuthProvider — oauth_provider_github","text":"","code":"oauth_provider_github(name = \"github\")"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_github.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a GitHub OAuthProvider — oauth_provider_github","text":"name Optional provider name (default \"github\")","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_github.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a GitHub OAuthProvider — oauth_provider_github","text":"OAuthProvider object use GitHub OAuth 2.0 app","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_github.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a GitHub OAuthProvider — oauth_provider_github","text":"can register new GitHub OAuth 2.0 app 'Developer Settings'.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_github.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a GitHub OAuthProvider — oauth_provider_github","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional; S   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure OIDC provider via OIDC discovery # (example requires network access; is therefore not run) if (FALSE) { # \\dontrun{ oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://accounts.google.com\" ) } # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Other providers # (all requiring network access; example is therefore not run) if (FALSE) { # \\dontrun{ # Slack via OIDC discovery slack_provider <- oauth_provider_slack()  # Keycloak # (requires configured Keycloak realm) oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\")  # Auth0 # (requires configured Auth0 domain) oauth_provider_auth0(domain = \"your-tenant.auth0.com\")  # Okta # (requires configured Okta domain) oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_google.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Google OAuthProvider — oauth_provider_google","title":"Create a Google OAuthProvider — oauth_provider_google","text":"Pre-configured OAuthProvider Google.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_google.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Google OAuthProvider — oauth_provider_google","text":"","code":"oauth_provider_google(name = \"google\")"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_google.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Google OAuthProvider — oauth_provider_google","text":"name Optional provider name (default \"google\")","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_google.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Google OAuthProvider — oauth_provider_google","text":"OAuthProvider object use Google OAuth 2.0 app","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_google.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Google OAuthProvider — oauth_provider_google","text":"can register new Google OAuth 2.0 app Google Cloud Console. Configure client ID & secret OAuthClient.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_google.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Google OAuthProvider — oauth_provider_google","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional; S   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure OIDC provider via OIDC discovery # (example requires network access; is therefore not run) if (FALSE) { # \\dontrun{ oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://accounts.google.com\" ) } # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Other providers # (all requiring network access; example is therefore not run) if (FALSE) { # \\dontrun{ # Slack via OIDC discovery slack_provider <- oauth_provider_slack()  # Keycloak # (requires configured Keycloak realm) oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\")  # Auth0 # (requires configured Auth0 domain) oauth_provider_auth0(domain = \"your-tenant.auth0.com\")  # Okta # (requires configured Okta domain) oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_keycloak.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Keycloak OAuthProvider (via OIDC discovery) — oauth_provider_keycloak","title":"Create a Keycloak OAuthProvider (via OIDC discovery) — oauth_provider_keycloak","text":"Create Keycloak OAuthProvider (via OIDC discovery)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_keycloak.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Keycloak OAuthProvider (via OIDC discovery) — oauth_provider_keycloak","text":"","code":"oauth_provider_keycloak(   base_url,   realm,   name = paste0(\"keycloak-\", realm),   token_auth_style = \"body\" )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_keycloak.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Keycloak OAuthProvider (via OIDC discovery) — oauth_provider_keycloak","text":"base_url Base URL Keycloak server, e.g., \"localhost:8080\" realm Keycloak realm name, e.g., \"myrealm\" name Optional provider name. Defaults paste0('keycloak-', realm) token_auth_style Optional override token endpoint authentication method. One \"header\" (client_secret_basic), \"body\" (client_secret_post), \"private_key_jwt\", \"client_secret_jwt\". Defaults \"body\" Keycloak, works confidential clients public PKCE clients (secretless). pass NULL, discovery infer method provider's token_endpoint_auth_methods_supported metadata.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_keycloak.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Keycloak OAuthProvider (via OIDC discovery) — oauth_provider_keycloak","text":"OAuthProvider object configured specified Keycloak realm","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_keycloak.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Keycloak OAuthProvider (via OIDC discovery) — oauth_provider_keycloak","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional; S   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure OIDC provider via OIDC discovery # (example requires network access; is therefore not run) if (FALSE) { # \\dontrun{ oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://accounts.google.com\" ) } # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Other providers # (all requiring network access; example is therefore not run) if (FALSE) { # \\dontrun{ # Slack via OIDC discovery slack_provider <- oauth_provider_slack()  # Keycloak # (requires configured Keycloak realm) oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\")  # Auth0 # (requires configured Auth0 domain) oauth_provider_auth0(domain = \"your-tenant.auth0.com\")  # Okta # (requires configured Okta domain) oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_microsoft.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Microsoft (Entra ID) OAuthProvider — oauth_provider_microsoft","title":"Create a Microsoft (Entra ID) OAuthProvider — oauth_provider_microsoft","text":"Pre-configured OAuthProvider Microsoft Entra ID (formerly Azure AD) using v2.0 endpoints. Accepts tenant identifier configures authorization, token, userinfo endpoints directly (discovery).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_microsoft.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Microsoft (Entra ID) OAuthProvider — oauth_provider_microsoft","text":"","code":"oauth_provider_microsoft(   name = \"microsoft\",   tenant = c(\"common\", \"organizations\", \"consumers\"),   id_token_validation = NULL )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_microsoft.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Microsoft (Entra ID) OAuthProvider — oauth_provider_microsoft","text":"name Optional friendly name provider. Defaults \"microsoft\" tenant Tenant identifier (\"common\", \"organizations\", \"consumers\", directory GUID). Defaults \"common\" id_token_validation Optional override (logical). NULL (default), enabled automatically tenant looks like GUID, otherwise disabled","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_microsoft.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Microsoft (Entra ID) OAuthProvider — oauth_provider_microsoft","text":"OAuthProvider object configured Microsoft identity platform","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_microsoft.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Microsoft (Entra ID) OAuthProvider — oauth_provider_microsoft","text":"tenant can one special values \"common\", \"organizations\", \"consumers\", specific directory (tenant) ID GUID (e.g., \"00000000-0000-0000-0000-000000000000\"). tenant specific GUID, provider enable strict ID token validation (issuer match). using multi-tenant aliases (\"common\", \"organizations\", \"consumers\"), exact issuer depends account signs therefore ID token validation disabled default avoid false negatives. can override via id_token_validation know environment guarantees fixed issuer. Microsoft issues RS256 ID tokens; allowed_algs restricted accordingly. userinfo endpoint provided Microsoft Graph (https://graph.microsoft.com/oidc/userinfo). configuring OAuthClient, option register app simply wish test development, may able use default Azure CLI public app, client_id '9391afd1-7129-4938-9e4d-633c688f93c0' (uses redirect_uri 'http://localhost:8100').","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_microsoft.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Microsoft (Entra ID) OAuthProvider — oauth_provider_microsoft","text":"","code":"# Example requires configured Microsoft Entra ID (Azure AD) tenant # (code is therefore not run) if (FALSE) { # \\dontrun{ library(shiny) library(shinyOAuth)  # Configure provider and client (Microsoft Entra ID with your tenant client <- oauth_client(   provider = oauth_provider_microsoft(     # Provide your own tenant ID here (set as environment variable MS_TENANT)     tenant = Sys.getenv(\"MS_TENANT\")   ),   # Default Azure CLI app ID (public client; activated in many tenants):   client_id = \"04b07795-8ddb-461a-bbee-02f9e1bf7b46\",    redirect_uri = \"http://localhost:8100\",   scopes = c(\"openid\", \"profile\", \"email\") )  # UI ui <- fluidPage(   use_shinyOAuth(),   h3(\"OAuth demo (Microsoft Entra ID)\"),   uiOutput(\"oauth_error\"),   tags$hr(),   h4(\"Auth object (summary)\"),   verbatimTextOutput(\"auth_print\"),   tags$hr(),   h4(\"User info\"),   verbatimTextOutput(\"user_info\") )  # Server server <- function(input, output, session) {   auth <- oauth_module_server(\"auth\", client)      output$auth_print <- renderText({     authenticated <- auth$authenticated     tok <- auth$token     err <- auth$error          paste0(       \"Authenticated?\",       if (isTRUE(authenticated)) \" YES\" else \" NO\",       \"\\n\",       \"Has token? \",       if (!is.null(tok)) \"YES\" else \"NO\",       \"\\n\",       \"Has error? \",       if (!is.null(err)) \"YES\" else \"NO\",       \"\\n\\n\",       \"Token (str):\\n\",       paste(capture.output(str(tok)), collapse = \"\\n\")     )   })      output$user_info <- renderPrint({     req(auth$token)     auth$token@userinfo   })      output$oauth_error <- renderUI({     if (!is.null(auth$error)) {       msg <- auth$error       if (!is.null(auth$error_description)) {         msg <- paste0(msg, \": \", auth$error_description)       }       div(class = \"alert alert-danger\", role = \"alert\", msg)     }   }) }  # Need to open app in 'localhost:8100' to match with redirect_uri # of the public Azure CLI app (above). Browser must use 'localhost' # too to properly set the browser cookie. But Shiny only redirects to # '127.0.0.1' & blocks process once it runs. So we disable browser # launch by Shiny & then use 'later::later()' to open the browser # ourselves a short moment after the app starts later::later(   function() {     utils::browseURL(\"http://localhost:8100\")   },   delay = 0.25 )  # Run app runApp(shinyApp(ui, server), port = 8100, launch.browser = FALSE) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a generic OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc","title":"Create a generic OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc","text":"Preconfigured OAuthProvider OpenID Connect (OIDC) compliant providers.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a generic OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc","text":"","code":"oauth_provider_oidc(   name,   base_url,   auth_path = \"/authorize\",   token_path = \"/token\",   userinfo_path = \"/userinfo\",   introspection_path = \"/introspect\",   use_nonce = TRUE,   id_token_validation = TRUE,   jwks_host_issuer_match = TRUE,   allowed_token_types = c(\"Bearer\"),   ... )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a generic OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc","text":"name Friendly name provider base_url Base URL OIDC endpoints auth_path Authorization endpoint path (default: \"/authorize\") token_path Token endpoint path (default: \"/token\") userinfo_path User info endpoint path (default: \"/userinfo\") introspection_path Token introspection endpoint path (default: \"/introspect\") use_nonce Logical, whether use OIDC nonce. Defaults TRUE id_token_validation Logical, whether validate ID tokens automatically provider. Defaults TRUE jwks_host_issuer_match TRUE (default), enforce JWKS host discovered provider matches issuer host (subdomain). providers serve JWKS different host (e.g., Google), set jwks_host_allow_only exact hostname instead disabling . Disabling (FALSE) recommended unless also pin JWKS via jwks_host_allow_only jwks_pins allowed_token_types Character vector allowed token types access tokens issued provider. Defaults 'Bearer' ... Additional arguments passed oauth_provider()","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a generic OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc","text":"OAuthProvider object","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a generic OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional; S   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure OIDC provider via OIDC discovery # (example requires network access; is therefore not run) if (FALSE) { # \\dontrun{ oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://accounts.google.com\" ) } # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Other providers # (all requiring network access; example is therefore not run) if (FALSE) { # \\dontrun{ # Slack via OIDC discovery slack_provider <- oauth_provider_slack()  # Keycloak # (requires configured Keycloak realm) oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\")  # Auth0 # (requires configured Auth0 domain) oauth_provider_auth0(domain = \"your-tenant.auth0.com\")  # Okta # (requires configured Okta domain) oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc_discover.html","id":null,"dir":"Reference","previous_headings":"","what":"Discover and create an OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc_discover","title":"Discover and create an OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc_discover","text":"Uses OpenID Connect discovery document /.well-known/openid-configuration auto-configure OAuthProvider. present, introspection_endpoint wired resulting provider RFC 7662 support.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc_discover.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discover and create an OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc_discover","text":"","code":"oauth_provider_oidc_discover(   issuer,   name = NULL,   use_pkce = TRUE,   use_nonce = TRUE,   id_token_validation = TRUE,   token_auth_style = NULL,   allowed_algs = c(\"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\",     \"ES384\", \"ES512\", \"EdDSA\"),   allowed_token_types = c(\"Bearer\"),   jwks_host_issuer_match = TRUE,   issuer_match = TRUE,   ... )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc_discover.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discover and create an OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc_discover","text":"issuer OIDC issuer base URL (including scheme), e.g., \"https://login.example.com\" name Optional friendly provider name. Defaults issuer hostname use_pkce Logical, whether use PKCE provider. Defaults TRUE. discovery document indicates token_endpoint_auth_methods_supported includes \"none\", PKCE required unless use_pkce explicitly set FALSE (recommended) use_nonce Logical, whether use OIDC nonce. Defaults TRUE id_token_validation Logical, whether validate ID tokens automatically provider. Defaults TRUE token_auth_style Authentication style token requests: \"header\" (client_secret_basic) \"body\" (client_secret_post). NULL (default), inferred conservatively discovery. PKCE enabled provider advertises support public clients via none, secretless flow preferred (modeled \"body\" without credentials). Otherwise, helper prefers \"header\" (client_secret_basic) available, \"body\" (client_secret_post). JWT-based methods auto-selected unless explicitly requested allowed_algs Character vector allowed ID token signing algorithms. Defaults broad set common algorithms, including RSA (RS*), RSA-PSS (PS*), ECDSA (ES*), EdDSA. discovery document advertises supported algorithms, intersection advertised caller-provided algorithms used avoid runtime mismatches. overlap, discovery fails configuration error (fallback) allowed_token_types Character vector allowed token types access tokens issued provider. Defaults 'Bearer' jwks_host_issuer_match TRUE (default), enforce JWKS host discovered provider matches issuer host (subdomain). providers serve JWKS different host, set jwks_host_allow_only exact hostname instead disabling . Disabling (FALSE) recommended unless also pin JWKS via jwks_host_allow_only jwks_pins issuer_match Logical, default TRUE. TRUE, requires discovery issuer's scheme/host match input issuer. FALSE, host mismatch allowed. Prefer tightening hosts via options(shinyOAuth.allowed_hosts) feasible ... Additional fields passed oauth_provider()","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc_discover.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discover and create an OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc_discover","text":"OAuthProvider object configured discovery","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc_discover.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Discover and create an OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc_discover","text":"ID token algorithms: default helper accepts common asymmetric algorithms RSA (RS*), RSA-PSS (PS*), ECDSA (ES*), EdDSA. provider advertises supported ID token signing algorithms via id_token_signing_alg_values_supported, helper uses intersection caller-provided allowed_algs. overlap, discovery fails configuration error. automatic fallback discovery-advertised set. Token endpoint authentication methods: supports client_secret_basic (header), client_secret_post (body), public clients using none (PKCE), well JWT-based methods private_key_jwt client_secret_jwt per RFC 7523. Important: discovery metadata lists methods supported across provider, per-client provisioning. helper automatically select JWT-based methods just advertised. default prefers client_secret_basic (header) available, otherwise client_secret_post (body), uses public none PKCE clients. provider advertises JWT methods, must explicitly set token_auth_style configure corresponding credentials OAuthClient (private key private_key_jwt, sufficiently strong client_secret client_secret_jwt). Host policy: default, discovered endpoints must absolute URLs whose host matches issuer host exactly. Subdomains implicitly allowed. want allow subdomains, add leading-dot glob options(shinyOAuth.allowed_hosts), e.g., .example.com *.example.com. global whitelist supplied via options(shinyOAuth.allowed_hosts), discovery restrict endpoints whitelist. Scheme policy (https/http loopback) delegated is_ok_host(), may allow non-HTTPS hosts options(shinyOAuth.allowed_non_https_hosts) (see ?is_ok_host).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc_discover.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discover and create an OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc_discover","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional; S   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure OIDC provider via OIDC discovery # (example requires network access; is therefore not run) if (FALSE) { # \\dontrun{ oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://accounts.google.com\" ) } # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Other providers # (all requiring network access; example is therefore not run) if (FALSE) { # \\dontrun{ # Slack via OIDC discovery slack_provider <- oauth_provider_slack()  # Keycloak # (requires configured Keycloak realm) oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\")  # Auth0 # (requires configured Auth0 domain) oauth_provider_auth0(domain = \"your-tenant.auth0.com\")  # Okta # (requires configured Okta domain) oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_okta.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an Okta OAuthProvider (via OIDC discovery) — oauth_provider_okta","title":"Create an Okta OAuthProvider (via OIDC discovery) — oauth_provider_okta","text":"Create Okta OAuthProvider (via OIDC discovery)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_okta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an Okta OAuthProvider (via OIDC discovery) — oauth_provider_okta","text":"","code":"oauth_provider_okta(domain, auth_server = \"default\", name = \"okta\")"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_okta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an Okta OAuthProvider (via OIDC discovery) — oauth_provider_okta","text":"domain Okta domain, e.g., \"dev-123456.okta.com\" auth_server Authorization server ID (default \"default\") name Optional provider name (default \"okta\")","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_okta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an Okta OAuthProvider (via OIDC discovery) — oauth_provider_okta","text":"OAuthProvider object configured specified Okta domain","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_okta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an Okta OAuthProvider (via OIDC discovery) — oauth_provider_okta","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional; S   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure OIDC provider via OIDC discovery # (example requires network access; is therefore not run) if (FALSE) { # \\dontrun{ oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://accounts.google.com\" ) } # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Other providers # (all requiring network access; example is therefore not run) if (FALSE) { # \\dontrun{ # Slack via OIDC discovery slack_provider <- oauth_provider_slack()  # Keycloak # (requires configured Keycloak realm) oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\")  # Auth0 # (requires configured Auth0 domain) oauth_provider_auth0(domain = \"your-tenant.auth0.com\")  # Okta # (requires configured Okta domain) oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_slack.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Slack OAuthProvider (via OIDC discovery) — oauth_provider_slack","title":"Create a Slack OAuthProvider (via OIDC discovery) — oauth_provider_slack","text":"Create Slack OAuthProvider (via OIDC discovery)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_slack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Slack OAuthProvider (via OIDC discovery) — oauth_provider_slack","text":"","code":"oauth_provider_slack(name = \"slack\")"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_slack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Slack OAuthProvider (via OIDC discovery) — oauth_provider_slack","text":"name Optional provider name (default \"slack\")","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_slack.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Slack OAuthProvider (via OIDC discovery) — oauth_provider_slack","text":"OAuthProvider object configured Slack","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_slack.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Slack OAuthProvider (via OIDC discovery) — oauth_provider_slack","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional; S   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure OIDC provider via OIDC discovery # (example requires network access; is therefore not run) if (FALSE) { # \\dontrun{ oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://accounts.google.com\" ) } # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Other providers # (all requiring network access; example is therefore not run) if (FALSE) { # \\dontrun{ # Slack via OIDC discovery slack_provider <- oauth_provider_slack()  # Keycloak # (requires configured Keycloak realm) oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\")  # Auth0 # (requires configured Auth0 domain) oauth_provider_auth0(domain = \"your-tenant.auth0.com\")  # Okta # (requires configured Okta domain) oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_spotify.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Spotify OAuthProvider — oauth_provider_spotify","title":"Create a Spotify OAuthProvider — oauth_provider_spotify","text":"Pre-configured OAuth 2.0 provider Spotify. Uses /v1/\"userinfo\". ID token (OIDC).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_spotify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Spotify OAuthProvider — oauth_provider_spotify","text":"","code":"oauth_provider_spotify(   name = \"spotify\",   scope = \"user-read-email user-read-private\" )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_spotify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Spotify OAuthProvider — oauth_provider_spotify","text":"name Optional provider name (default \"spotify\") scope Optional space-separated scope string (default \"user-read-email user-read-private\")","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_spotify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Spotify OAuthProvider — oauth_provider_spotify","text":"OAuthProvider object use Spotify OAuth 2.0 app","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_spotify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Spotify OAuthProvider — oauth_provider_spotify","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional; S   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure OIDC provider via OIDC discovery # (example requires network access; is therefore not run) if (FALSE) { # \\dontrun{ oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://accounts.google.com\" ) } # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Other providers # (all requiring network access; example is therefore not run) if (FALSE) { # \\dontrun{ # Slack via OIDC discovery slack_provider <- oauth_provider_slack()  # Keycloak # (requires configured Keycloak realm) oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\")  # Auth0 # (requires configured Auth0 domain) oauth_provider_auth0(domain = \"your-tenant.auth0.com\")  # Okta # (requires configured Okta domain) oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/prepare_call.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare a OAuth 2.0 authorization call and build an authorization URL — prepare_call","title":"Prepare a OAuth 2.0 authorization call and build an authorization URL — prepare_call","text":"function prepares OAuth 2.0 authorization call generating necessary state, PKCE, nonce values, storing securely, constructing authorization URL redirect user . state accompanying values stored client's state store later verification callback phase OAuth 2.0 flow.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/prepare_call.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare a OAuth 2.0 authorization call and build an authorization URL — prepare_call","text":"","code":"prepare_call(oauth_client, browser_token)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/prepare_call.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare a OAuth 2.0 authorization call and build an authorization URL — prepare_call","text":"oauth_client OAuthClient object representing OAuth client configuration. browser_token string token (e.g., browser cookie) identify user/session.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/prepare_call.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare a OAuth 2.0 authorization call and build an authorization URL — prepare_call","text":"string containing constructed authorization URL. URL used redirect user OAuth provider's authorization endpoint.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/prepare_call.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare a OAuth 2.0 authorization call and build an authorization URL — prepare_call","text":"","code":"# Please note: `prepare_callback()` & `handle_callback()` are typically # not called by users of this package directly, but are called  # internally by `oauth_module_server()`. These functions are exported # nonetheless for advanced use cases. Most users will not need to # call these functions directly  # Below code shows generic usage of `prepare_callback()` and `handle_callback()` # (code is not run because it would require user interaction) if (FALSE) { # \\dontrun{ # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Get authorization URL and and store state in client's state store # `<browser_token>` is a token that identifies the browser session #  and would typically be stored in a browser cookie #  (`oauth_module_server()` handles this typically) authorization_url <- prepare_callback(client, \"<browser_token>\")  # Redirect user to authorization URL; retrieve code & payload from query; # read also `<browser_token>` from browser cookie # (`oauth_module_server()` handles this typically) code <- \"...\" payload <- \"...\" browser_token <- \"...\"  # Handle callback, exchanging code for token and validating state # (`oauth_module_server()` handles this typically) token <- handle_callback(client, code, payload, browser_token) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/refresh_token.html","id":null,"dir":"Reference","previous_headings":"","what":"Refresh an OAuth 2.0 token — refresh_token","title":"Refresh an OAuth 2.0 token — refresh_token","text":"Refreshes OAuth 2.0 access token using refresh token.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/refresh_token.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refresh an OAuth 2.0 token — refresh_token","text":"","code":"refresh_token(oauth_client, token, async = FALSE, introspect = FALSE)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/refresh_token.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refresh an OAuth 2.0 token — refresh_token","text":"oauth_client OAuthClient object token OAuthToken object containing refresh token async Logical, default FALSE. TRUE promises package available, refresh performed main R session using promises::future_promise() function returns promise resolves updated OAuthToken. promises available, falls back synchronous behavior introspect Logical, default FALSE. successful refresh, provider exposes introspection endpoint, perform best-effort introspection new access token audit/diagnostics. result stored token object.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/refresh_token.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refresh an OAuth 2.0 token — refresh_token","text":"updated OAuthToken object new access token. provider issues new refresh token, replaces old one. provider returns ID token id_token_validation = TRUE, validated. userinfo_required = TRUE, fresh userinfo fetched stored token. expires_at computed expires_in provided; otherwise set Inf.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/refresh_token.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Refresh an OAuth 2.0 token — refresh_token","text":"","code":"# Please note: `get_userinfo()`, `introspect_token()`, and `refresh_token()` # are typically not called by users of this package directly, but are called # internally by `oauth_module_server()`. These functions are exported # nonetheless for advanced use cases. Most users will not need to # call these functions directly  # Example requires a real token from a completed OAuth flow # (code is therefore not run; would require user interaction) if (FALSE) { # \\dontrun{ # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Have a valid OAuthToken object; fake example below # (typically provided by `oauth_module_server()` or `handle_callback()`) token <- handle_callback(client, \"<code>\", \"<payload>\", \"<browser_token>\")  # Get userinfo user_info <- get_userinfo(client, token)  # Introspect token (if supported by provider) introspection <- introspect_token(client, token)  # Refresh token new_token <- refresh_token(client, token, introspect = TRUE) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/shinyOAuth-package.html","id":null,"dir":"Reference","previous_headings":"","what":"shinyOAuth: Provider-Agnostic OAuth Authentication for Shiny Applications — shinyOAuth-package","title":"shinyOAuth: Provider-Agnostic OAuth Authentication for Shiny Applications — shinyOAuth-package","text":"Provides simple, configurable, provider-agnostic 'OAuth 2.0' 'OpenID Connect' ('OIDC') authentication framework 'shiny' applications using 'S7' classes. Defines providers, clients, tokens, well various supporting functions 'shiny' module. Features include 'Cross Site Request Forgery' ('CSRF') protection, state encryption, 'Proof Key Code Exchange' ('PKCE') handling, validation 'OIDC' identity tokens (nonces, signatures, claims), automatic user info retrieval, asynchronous flows, hooks audit logging.","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/reference/shinyOAuth-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"shinyOAuth: Provider-Agnostic OAuth Authentication for Shiny Applications — shinyOAuth-package","text":"Maintainer: Luka Koning koningluka@gmail.com [copyright holder]","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_payload_decrypt_validate.html","id":null,"dir":"Reference","previous_headings":"","what":"Decrypt and validate OAuth state payload — state_payload_decrypt_validate","title":"Decrypt and validate OAuth state payload — state_payload_decrypt_validate","text":"Internal utility decrypts encrypted state payload using client's state_key, validates freshness client binding.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_payload_decrypt_validate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decrypt and validate OAuth state payload — state_payload_decrypt_validate","text":"","code":"state_payload_decrypt_validate(client, encrypted_payload)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_payload_decrypt_validate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Decrypt and validate OAuth state payload — state_payload_decrypt_validate","text":"client OAuthClient instance encrypted_payload Encrypted state payload string received via state query parameter.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_payload_decrypt_validate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Decrypt and validate OAuth state payload — state_payload_decrypt_validate","text":"named list payload (state, client_id, redirect_uri, scopes, provider, issued_at) success; otherwise throws error via err_invalid_state().","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_store_get_remove.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch and remove the single-use state entry — state_store_get_remove","title":"Fetch and remove the single-use state entry — state_store_get_remove","text":"Retrieves state-bound values client's state_store removes entry enforce single-use semantics.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_store_get_remove.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch and remove the single-use state entry — state_store_get_remove","text":"","code":"state_store_get_remove(client, state)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_store_get_remove.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch and remove the single-use state entry — state_store_get_remove","text":"client OAuthClient instance state Plain (decrypted) state string used logical key","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_store_get_remove.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch and remove the single-use state entry — state_store_get_remove","text":"list browser_token, pkce_code_verifier, nonce. Throws error via err_invalid_state() retrieval removal fails, retrieved value missing/malformed.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/use_shinyOAuth.html","id":null,"dir":"Reference","previous_headings":"","what":"Add JavaScript dependency to the UI of a Shiny app — use_shinyOAuth","title":"Add JavaScript dependency to the UI of a Shiny app — use_shinyOAuth","text":"Adds package's client-side JavaScript helpers htmlDependency Shiny UI. enables features redirection setting browser cookie token. Without adding UI app,  oauth_module_server() function.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/use_shinyOAuth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add JavaScript dependency to the UI of a Shiny app — use_shinyOAuth","text":"","code":"use_shinyOAuth()"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/use_shinyOAuth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add JavaScript dependency to the UI of a Shiny app — use_shinyOAuth","text":"tagList containing singleton dependency tag ensures JS file inst/www/shinyOAuth.js loaded","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/use_shinyOAuth.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add JavaScript dependency to the UI of a Shiny app — use_shinyOAuth","text":"Place near top-level UI (e.g., inside fluidPage() tagList()), similar use shinyjs::useShinyjs().","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/reference/use_shinyOAuth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add JavaScript dependency to the UI of a Shiny app — use_shinyOAuth","text":"","code":"ui <- shiny::fluidPage(   use_shinyOAuth(),   # ... )"},{"path":"https://lukakoning.github.io/shinyOAuth/news/index.html","id":"shinyoauth-010","dir":"Changelog","previous_headings":"","what":"shinyOAuth 0.1.0","title":"shinyOAuth 0.1.0","text":"Initial CRAN submission.","code":""}]

[{"path":"https://lukakoning.github.io/shinyOAuth/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 shinyOAuth authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Audit logging and hooks","text":"‘shinyOAuth’ emits structured audit events key steps OAuth 2.0/OIDC flow. may help detect anomalous activity (e.g., brute force, replay, configuration errors). vignette covers: - register audit hooks export/store events - audit events emitted & fields included event - Best practices","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"receiving-audit-events","dir":"Articles","previous_headings":"","what":"Receiving audit events","title":"Audit logging and hooks","text":"two hook options can set. receive event object (named list). functions register options fast, non-blocking, never throw errors. options(shinyOAuth.audit_hook = function(event) { ... }) - intended audit-specific sinks options(shinyOAuth.trace_hook = function(event) { ... }) - general-purpose tracing hook used audit events error traces Example printing audit events console: stop receiving events, unset option:","code":"options(shinyOAuth.audit_hook = function(event) {     cat(sprintf(\"[AUDIT] %s %s\\n\", event$type, event$trace_id))     str(event) }) options(shinyOAuth.audit_hook = NULL)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-structure","dir":"Articles","previous_headings":"","what":"Event structure","title":"Audit logging and hooks","text":"audit events share following base shape: type: string starting audit_... trace_id: short correlation id linking related records timestamp: POSIXct time event created (Sys.time()) Additional key/value fields depending event (see event catalog) events emitted within Shiny session, JSON-friendly shiny_session list attached every event correlate audit activity HTTP request session. structure designed directly serializable jsonlite::toJSON(): shiny_session$token: Shiny per-session token (session$token) available. shiny_session$is_async: logical indicating whether event emitted main R process (FALSE) async worker (TRUE). helps distinguish logs produced background tasks (e.g., async token exchange refresh) main reactive flow. shiny_session$process_id: process ID (PID) R process emitted event. shiny_session$main_process_id: (async events ) PID main R process spawned async worker. allows correlate events workers back originating main process. \"mirai_error\" — code threw R error inside worker \"mirai_timeout\" — task exceeded timeout cancelled dispatcher \"mirai_connection_reset\" — daemon process crashed terminated \"mirai_interrupt\" — task interrupted/cancelled via stop_mirai() NA — mirai-specific error (e.g., sync path future backend) method, path, query_string, host, scheme, remote_addr headers: list request headers derived HTTP_* environment variables, lowercase names (e.g., user_agent). Note: raw session$request Shiny included keep event JSON-serializable concise.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"http-context-sanitization","dir":"Articles","previous_headings":"Event structure","what":"HTTP context sanitization","title":"Audit logging and hooks","text":"safety, shiny_session$http summary automatically sanitized attached events. prevents accidental secret leakage forwarding events log sinks: OAuth query parameters redacted: code, state, access_token, refresh_token, id_token, token, session_state, code_verifier, nonce replaced [REDACTED]. Sensitive headers removed: Cookie, Set-Cookie, Authorization, Proxy_Authorization, Proxy_Authenticate, WWW-Authenticate headers stripped entirely. Proxy headers redacted: Headers starting x_ (e.g., x_forwarded_for, x_real_ip) replaced [REDACTED] avoid leaking internal infrastructure details. means can safely forward shiny_session$http object external logging systems without manually stripping secrets. need raw, unsanitized HTTP context audit events, can disable redaction:","code":"options(shinyOAuth.audit_redact_http = FALSE)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"excluding-http-context-entirely","dir":"Articles","previous_headings":"Event structure","what":"Excluding HTTP context entirely","title":"Audit logging and hooks","text":"completely exclude HTTP request details audit events: means shiny_session$http field NULL audit events.","code":"options(shinyOAuth.audit_include_http = FALSE)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"audit-events-from-async-workers-mirai-daemons","dir":"Articles","previous_headings":"Event structure","what":"Audit events from async workers (mirai daemons)","title":"Audit logging and hooks","text":"async = TRUE configured oauth_module_server(), set daemon workers mirai::daemons(), token exchange, refresh, revocation run background mirai daemon processes. package automatically propagates shinyOAuth.audit_hook shinyOAuth.trace_hook options workers, audit events fire also async worker processes hooks apply . Note audit hook function (objects referenced closure) must serializable. hook writes database connection, file handle, non-serializable resource, fail silently worker process. Use hooks create connections demand (e.g., open database connection inside hook body) rather capturing existing connection closure.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"digest-fields-and-keying","dir":"Articles","previous_headings":"Event structure","what":"Digest fields and keying","title":"Audit logging and hooks","text":"Many audit events include digest fields client_id_digest, state_digest, code_digest, browser_token_digest, sub_digest. intended let correlate events without emitting raw sensitive values. default, digests use HMAC-SHA256 auto-generated per-process key. reduces risk correlation dictionary reidentification logs leak. run multiple workers/processes want digests comparable across , configure shared key: disable keying (legacy deterministic SHA-256 digests): Note: unkeyed digests pseudonymous, anonymized—low-entropy identifiers (like email addresses) can dictionary-attacked.","code":"options(shinyOAuth.audit_digest_key = Sys.getenv(\"AUDIT_DIGEST_KEY\")) options(shinyOAuth.audit_digest_key = FALSE)"},{"path":[]},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_redirect_issued","dir":"Articles","previous_headings":"Event catalog > Authorization redirect issuance","what":"Event: audit_redirect_issued","title":"Audit logging and hooks","text":": prepare_call() builds authorization URL Context: provider, issuer client_id_digest state_digest browser_token_digest pkce_method (e.g., S256, plain, NA) nonce_present (logical) scopes_count redirect_uri","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_callback_query_rejected","dir":"Articles","previous_headings":"Event catalog > Callback query rejected","what":"Event: audit_callback_query_rejected","title":"Audit logging and hooks","text":": callback query parameters fail validation (e.g., large) Context: provider, issuer, client_id_digest, error_class","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_callback_received","dir":"Articles","previous_headings":"Event catalog > Callback received","what":"Event: audit_callback_received","title":"Audit logging and hooks","text":": handle_callback() begins processing callback Context: provider, issuer, client_id_digest, code_digest, state_digest, browser_token_digest","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"callback-validation","dir":"Articles","previous_headings":"Event catalog","what":"Callback validation","title":"Audit logging and hooks","text":"Callback validation spans decryption + freshness + binding encrypted payload well subsequent checks values bound state (browser token, PKCE code verifier, nonce). check emits either success (payload) failure audit event.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_callback_validation_success","dir":"Articles","previous_headings":"Event catalog > Callback validation","what":"Event: audit_callback_validation_success","title":"Audit logging and hooks","text":": encrypted state payload decrypted verified freshness client/provider binding (emitted state_payload_decrypt_validate()) Context: provider, issuer, client_id_digest, state_digest","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_callback_validation_failed","dir":"Articles","previous_headings":"Event catalog > Callback validation","what":"Event: audit_callback_validation_failed","title":"Audit logging and hooks","text":": validation step fails prior token exchange Context: provider, issuer, client_id_digest, state_digest, phase, error_class (+ browser_token_digest phase browser_token_validation) Phases include: payload_validation, browser_token_validation, pkce_verifier_validation, nonce_validation Note: Failures related state store access (lookup/removal) reported events (see ) rather using callback_validation_failed event.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"state-store-access","dir":"Articles","previous_headings":"Event catalog","what":"State store access","title":"Audit logging and hooks","text":"State retrieval removal single-use state entry emitted separate events state_store_get_remove().","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_state_store_lookup_failed","dir":"Articles","previous_headings":"Event catalog > State store access","what":"Event: audit_state_store_lookup_failed","title":"Audit logging and hooks","text":": retrieving single-use state entry configured state_store fails (missing, malformed, underlying cache error) Context: provider, issuer, client_id_digest, state_digest, error_class, phase (state_store_lookup) Notes: flow aborts invalid state error.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_state_store_removal_failed","dir":"Articles","previous_headings":"Event catalog > State store access","what":"Event: audit_state_store_removal_failed","title":"Audit logging and hooks","text":": removal single-use state entry (enforcing one-time use) fails Context: provider, issuer, client_id_digest, state_digest, error_class, phase (state_store_removal) Notes: failure remove also aborts flow invalid state error; event emitted best-effort never throw. Digest differences: audit_callback_validation_failed payload decryption (phase = \"payload_validation\") state_digest computed encrypted payload (plaintext yet available). state store events digest reflects plaintext state string.","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_token_exchange","dir":"Articles","previous_headings":"Event catalog > Token exchange","what":"Event: audit_token_exchange","title":"Audit logging and hooks","text":": authorization code successfully exchanged tokens Context: provider, issuer, client_id_digest, code_digest, used_pkce, received_id_token, received_refresh_token","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_token_exchange_error","dir":"Articles","previous_headings":"Event catalog > Token exchange","what":"Event: audit_token_exchange_error","title":"Audit logging and hooks","text":": token exchange fails Context: provider, issuer, client_id_digest, code_digest, error_class","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_token_introspection","dir":"Articles","previous_headings":"Event catalog > Token introspection","what":"Event: audit_token_introspection","title":"Audit logging and hooks","text":": introspect_token() called (e.g., login introspect = TRUE) provider, issuer, client_id_digest (“access” “refresh”) supported (logical), active (logical|NA), status sub_digest, introspected_client_id_digest, scope_digest (available)","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_login_success","dir":"Articles","previous_headings":"Event catalog > Login result","what":"Event: audit_login_success","title":"Audit logging and hooks","text":": token set verified OAuthToken created Context: provider, issuer, client_id_digest, sub_digest, sub_source, refresh_token_present, expires_at sub_source indicates sub_digest derived : userinfo: subject came userinfo response id_token: subject came ID token validated (signature + claims) id_token_unverified: subject came ID token payload parse ID token validation performed","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_login_failed","dir":"Articles","previous_headings":"Event catalog > Login result","what":"Event: audit_login_failed","title":"Audit logging and hooks","text":": surface-level login failure callback handling Shiny module Context: provider, issuer, client_id_digest, phase (sync_token_exchange|async_token_exchange), error_class, mirai_error_type","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_logout","dir":"Articles","previous_headings":"Event catalog > Logout and session clears","what":"Event: audit_logout","title":"Audit logging and hooks","text":": values$logout() called module Context: provider, issuer, client_id_digest, reason (default manual_logout)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_session_cleared","dir":"Articles","previous_headings":"Event catalog > Logout and session clears","what":"Event: audit_session_cleared","title":"Audit logging and hooks","text":": module clears token reactively Context: provider, issuer, client_id_digest, reason, mirai_error_type Reasons include: refresh_failed_async, refresh_failed_sync, reauth_window, token_expired","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_token_revocation","dir":"Articles","previous_headings":"Event catalog > Token revocation","what":"Event: audit_token_revocation","title":"Audit logging and hooks","text":": revoke_token() called (e.g., logout session end) provider, issuer, client_id_digest (“access” “refresh”) supported (logical), revoked (logical|NA), status","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_refresh_failed_but_kept_session","dir":"Articles","previous_headings":"Event catalog > Refresh failures while keeping the session (indefinite sessions)","what":"Event: audit_refresh_failed_but_kept_session","title":"Audit logging and hooks","text":": token refresh attempt fails module configured clear session (.e., indefinite_session = TRUE oauth_module_server()) Context: provider, issuer, client_id_digest, reason (refresh_failed_async|refresh_failed_sync), kept_token (TRUE), error_class, mirai_error_type","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_browser_cookie_error","dir":"Articles","previous_headings":"Event catalog > Browser cookie/WebCrypto error","what":"Event: audit_browser_cookie_error","title":"Audit logging and hooks","text":": browser reports set/read module cookie WebCrypto unavailable Context: provider, issuer, client_id_digest, reason, url_protocol Notes: typically indicates third-party cookies blocked, cookies disabled, WebCrypto API unavailable environment (e.g., old browsers restrictive embedded webviews).","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_invalid_browser_token","dir":"Articles","previous_headings":"Event catalog > Invalid browser token","what":"Event: audit_invalid_browser_token","title":"Audit logging and hooks","text":": module receives invalid shinyOAuth_sid value browser requests regeneration Context: provider, issuer, client_id_digest, reason, length","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_token_refresh","dir":"Articles","previous_headings":"Event catalog > Token refresh","what":"Event: audit_token_refresh","title":"Audit logging and hooks","text":": refresh_token() successfully refreshes access token Context: provider, issuer, client_id_digest, had_refresh_token, new_expires_at","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_userinfo","dir":"Articles","previous_headings":"Event catalog > Userinfo fetch","what":"Event: audit_userinfo","title":"Audit logging and hooks","text":": get_userinfo() successfully retrieves user information Context: provider, issuer, client_id_digest, sub_digest","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"state-parsing-failures","dir":"Articles","previous_headings":"Event catalog","what":"State parsing failures","title":"Audit logging and hooks","text":"State parsing failures occur decoding validating encrypted wrapper prior extracting logical state value.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_state_parse_failure","dir":"Articles","previous_headings":"Event catalog > State parsing failures","what":"Event: audit_state_parse_failure","title":"Audit logging and hooks","text":": encrypted state wrapper components fail validation/decoding Context: includes phase = decrypt, reason code (e.g., token_b64_invalid, iv_missing, tag_len_invalid), token_digest, additional details (lengths). Emitted best-effort parsing utilities never interferes control flow.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"error-response-state-consumption","dir":"Articles","previous_headings":"Event catalog","what":"Error response state consumption","title":"Audit logging and hooks","text":"provider returns error response (e.g., access_denied) includes state parameter, module attempts consume state prevent replay clean store.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_error_state_consumed","dir":"Articles","previous_headings":"Event catalog > Error response state consumption","what":"Event: audit_error_state_consumed","title":"Audit logging and hooks","text":": state error response successfully consumed Context: provider, issuer, client_id_digest, state_digest","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_error_state_consumption_failed","dir":"Articles","previous_headings":"Event catalog > Error response state consumption","what":"Event: audit_error_state_consumption_failed","title":"Audit logging and hooks","text":": consumption state error response fails Context: provider, issuer, client_id_digest, state_digest, error_class, error_message","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_session_started","dir":"Articles","previous_headings":"Event catalog > Module/session lifecycle","what":"Event: audit_session_started","title":"Audit logging and hooks","text":": authentication module (oauth_module_server()) initialized Shiny session Context: module_id, ns_prefix, client_provider, client_issuer, client_id_digest, plus standard shiny_session context described ","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_session_ended","dir":"Articles","previous_headings":"Event catalog > Module/session lifecycle","what":"Event: audit_session_ended","title":"Audit logging and hooks","text":": Shiny session ends (always emitted onSessionEnded, regardless configuration) Context: provider, issuer, client_id_digest, was_authenticated","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_session_ended_revoke","dir":"Articles","previous_headings":"Event catalog > Module/session lifecycle","what":"Event: audit_session_ended_revoke","title":"Audit logging and hooks","text":": Shiny session ends revoke_on_session_end = TRUE token present Context: provider, issuer, client_id_digest; actual revocation attempt logged separately audit_token_revocation events","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"event-audit_authenticated_changed","dir":"Articles","previous_headings":"Event catalog > Authentication state changes","what":"Event: audit_authenticated_changed","title":"Audit logging and hooks","text":": $authenticated reactive value changes (TRUE ↔︎ FALSE) Context: provider, issuer, client_id_digest, authenticated, previous_authenticated, reason Reasons include: login (becoming authenticated), error code/state caused de-authentication (e.g., token_expired, logged_out, token_cleared)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"where-to-find-these-in-code","dir":"Articles","previous_headings":"","what":"Where to find these in code","title":"Audit logging and hooks","text":"Redirect login audits emitted R/methods__login.R Module lifecycle/session audits emitted R/oauth_module_server.R events flow audit_event() defined R/errors.R, delegates hook options","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/audit-logging.html","id":"best-practices-for-audit-hooks","dir":"Articles","previous_headings":"","what":"Best practices for audit hooks","title":"Audit logging and hooks","text":"Keep hooks fast never throw; wrap internals try(..., silent = TRUE) needed Export logging backend JSON easy parsing attempt reverse digests; use correlation Consider adding host/app identifier record exporting also want error traces, set options(shinyOAuth.trace_hook=...) Example JSON export hook:","code":"json_hook <- function(event) {     try({         line <- jsonlite::toJSON(event, auto_unbox = TRUE, null = \"null\")         cat(line, \"\\n\", file = \"shinyOAuth-audit.log\", append = TRUE)     }, silent = TRUE) }  options(shinyOAuth.audit_hook = json_hook)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Authentication flow","text":"vignette provides step--step description happens authentication flow using oauth_module_server() Shiny module. maps protocol concepts (OAuth 2.0 Authorization Code + PKCE, OpenID Connect) concrete implementation details package. concise quick-start (minimal manual button examples, options, security checklist) see: vignette(\"usage\", package = \"shinyOAuth\"). explanation logging key events flow, see: vignette(\"audit-logging\", package = \"shinyOAuth\").","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"what-happens-during-the-authentication-flow","dir":"Articles","previous_headings":"","what":"What happens during the authentication flow?","title":"Authentication flow","text":"package implements OAuth 2.0 ‘Authorization Code’ flow optional ‘OpenID Connect’ (OIDC) checks end‑‑end. sequence operations rationale behind step.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"first-page-load-set-a-browser-token","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"1. First page load: set a browser token","title":"Authentication flow","text":"first load app, module sets small random cookie user’s browser (SameSite=Strict; Secure HTTPS). browser token mirrored Shiny input. purpose ensure browser starts OAuth 2.0 flow one finishes (“double-submit” style CSRF defense).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"decide-whether-to-start-login","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"2. Decide whether to start login","title":"Authentication flow","text":"oauth_module_server(auto_redirect = TRUE), unauthenticated session triggers immediate redirection provider authorization endpoint. oauth_module_server(auto_redirect = FALSE), manually call $request_login() (e.g., via button) .","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"build-the-authorization-url-prepare_call","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"3. Build the authorization URL (prepare_call())","title":"Authentication flow","text":"redirect user provider, module constructs authorization request URL. URL built provider’s authorization endpoint includes various query parameters ensure security proper context tracking: State: high-entropy random string prevent CSRF; package seals state enhance security (see ) PKCE: code_verifier (random) code_challenge (S256 hash) proving party finishes flow Nonce (OIDC): random string echoed back ID token, mitigating replay attacks package seals state, meaning encrypts authenticates (AES-GCM AEAD) payload containing: state, client_id, redirect_uri requested scopes provider fingerprint (issuer/auth/token URLs) issued_at timestamp Sealing state prevents tampering, stale callbacks, mix-ups providers/clients. server side, package store sealed state (cache-safe hash key) state store (e.g., ‘cachem’ backend) along following data: browser token code_verifier nonce (OIDC) data used validation callback processing.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"app-redirects-to-the-provider","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"4. App redirects to the provider","title":"Authentication flow","text":"browser app user redirected provider’s authorization endpoint following parameters: response_type=code, client_id, redirect_uri, state=<sealed state>, PKCE parameters, nonce (OIDC), scope, plus configured extra parameters.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"user-authenticates-and-authorizes","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"5. User authenticates and authorizes","title":"Authentication flow","text":"provider’s authorization page, user prompted log authorize app access requested scopes.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"provider-redirects-user-back-to-the-app","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"6. Provider redirects user back to the app","title":"Authentication flow","text":"provider redirects user’s browser back Shiny app (redirect_uri), including code state parameters (optionally error error_description failure).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"callback-processing-state-verification-handle_callback","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"7. Callback processing & state verification (handle_callback())","title":"Authentication flow","text":"user redirected back app, module processes callback. consists following steps: Wait browser token input yet visible Decrypt verify sealed state, ensuring integrity, authenticity, freshness (using issued_at window) Check embedded context matches expected client/provider (defends misconfiguration/multi-tenant mix-ups) entry missing, malformed, deletion fails, flow aborts shinyOAuth_state_error Audit events emitted failures (e.g., state_store_lookup_failed, state_store_removal_failed) Verify user’s browser token matches previously stored browser token Ensure PKCE components available required Note: asynchronous token exchange mode, module may pre‑decrypt sealed state prefetch plus remove state store entry main thread handing work async worker, preserving single‑use strict failure behavior.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"exchange-authorization-code-for-tokens","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"8. Exchange authorization code for tokens","title":"Authentication flow","text":"callback verified, module proceeds exchange authorization code tokens. POST request made token endpoint grant_type=authorization_code, code, redirect_uri, code_verifier (PKCE). Client authentication method depends provider style: HTTP Basic header (client_secret_basic), body params (client_secret_post), JWT-based assertions (client_secret_jwt, private_key_jwt) configured. response must include least access_token. Malformed error responses abort flow. successful, package also applies two safety rails: token response includes scope, shinyOAuth can reconcile requested scopes (defaults strict enforcement; configurable via client scope_validation setting) provider configured non-empty allowed_token_types, token response must include token_type value must one allowed types (case-insensitive, e.g., Bearer)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"validate-id-token-oidc-only","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"9. Validate ID token (OIDC only)","title":"Authentication flow","text":"using oauth_provider(id_token_validation = TRUE), following verifications performed userinfo fetch ensure cryptographic validation occurs prior making external calls: Signature: verified provider JWKS (optional pinning) standard asymmetric algorithms (RSA-PKCS1, RSA-PSS, ECDSA, EdDSA). HMAC algorithms (HS256/384/512) allowed explicit opt-(options(shinyOAuth.allow_hs = TRUE)) sufficiently strong server-held secret Claims: iss matches expected issuer; aud vector contains client_id; sub present; iat required must single finite numeric; time-based claims (exp required, nbf optional) evaluated small configurable leeway; tokens issued future rejected Header typ (present): must indicate JWT (JWT, case-insensitive). values (e.g., +jwt) rejected ID tokens Nonce: must match previously stored value (configured)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"fetch-userinfo-optional","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"10. Fetch userinfo (optional)","title":"Authentication flow","text":"userinfo requested via oauth_provider(userinfo_required = TRUE) (userinfo_url configured), module calls userinfo endpoint access token stores returned claims. happens ID token validation ensure cryptographic checks pass making external calls. request fails, flow aborts error. - Subject match: oauth_provider(userinfo_id_token_match = TRUE), checked sub userinfo equals sub ID token","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"token-introspection-optional","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"11. Token introspection (optional)","title":"Authentication flow","text":"providers support RFC 7662 token introspection (additional endpoint server can ask provider whether access token currently active retrieve related metadata). enable introspect = TRUE creating oauth_client(), module calls provider’s introspection endpoint callback processing requires response indicate active = TRUE. introspection unsupported provider introspection request fails, login aborted $authenticated set TRUE. can optionally enforce additional provider-dependent fields via oauth_client(introspect_elements = ...): \"sub\" – require introspection sub match session subject \"client_id\" – require introspection client_id match OAuth client id \"scope\" – validate introspection scope requested scopes (respects client’s scope_validation mode) (Note providers may return fields introspection responses.)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"build-the-oauthtoken-object","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"12. Build the OAuthToken object","title":"Authentication flow","text":"Now verifications passed, module builds final token object. S7 OAuthToken object contains: access_token (string) refresh_token (optional string) expires_at (numeric timestamp, seconds since epoch; Inf non-expiring tokens) id_token (optional string) userinfo (optional list) $authenticated value returned oauth_module_server() now becomes TRUE, meaning requested verifications passed.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"clean-url-tidy-ui-clear-browser-token","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"13. Clean URL & tidy UI; clear browser token","title":"Authentication flow","text":"user’s browser redirected app OAuth 2.0 query parameters (code, state, etc.). improve UX avoid leaking sensitive data, values removed address bar JavaScript. Optionally, page title may also adjusted (see tab_title_ arguments oauth_module_server()). browser token cookie also cleared immediately re-issued fresh value, future flow can start new per-session token.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"post-flow-session-management","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"14. Post-flow session management","title":"Authentication flow","text":"Now flow complete, module manage token lifetime active session. may consist : Proactive refresh: enabled refresh token exists, access token refreshed expiry Expiration: expired tokens cleared automatically, setting $authenticated flag FALSE Re-authentication: optionally, oauth_module_server(reauth_after_seconds = ...) can force periodic re-authentication","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"refresh-behavior-refresh_token","dir":"Articles","previous_headings":"What happens during the authentication flow? > 14. Post-flow session management","what":"Refresh behavior (refresh_token())","title":"Authentication flow","text":"module refreshes session (call refresh_token() directly), performs OAuth 2.0 refresh token grant provider’s token endpoint updates OAuthToken object. works follows: token request sent grant_type=refresh_token current refresh_token response must include new access_token. expires_at updated expires_in present; otherwise set Inf provider rotates refresh token (returns new refresh_token), stored; otherwise original preserved oauth_provider(userinfo_required = TRUE), userinfo re-fetched using fresh access token respect OIDC ID token handling: Per OIDC Core Section 12.2, refresh responses may omit id_token. omitted, original id_token initial login preserved. Thus, refresh necessarily revalidate identity original id_token exist session, refresh return one, refresh fails (establish subject claim match baseline) id_token_validation = TRUE, refresh-returned id_token fully validated (signature + claims); sub claim match enforced part validation id_token_validation = FALSE, shinyOAuth still enforces sub match parsing JWT payload (ensuring sub claim still matches without full validation) refresh fails inside oauth_module_server(), module exposes failure via reactive state (example, token_refresh_error). default also clears current session token; oauth_module_server(indefinite_session = TRUE), token kept marked stale. cases, $authenticated flag becomes FALSE error present.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/authentication-flow.html","id":"logout-and-token-revocation","dir":"Articles","previous_headings":"What happens during the authentication flow?","what":"15. Logout and token revocation","title":"Authentication flow","text":"auth$logout() called, module: Attempts revoke refresh access tokens provider (RFC 7009) revocation_url configured. runs asynchronously oauth_module_server(async = TRUE) Clears local session (OAuthToken, browser cookie) Emits \"logout\" audit event Re-issues fresh browser token subsequent logins can also revoke tokens directly via revoke_token(client, token, = \"refresh\"). automatically attempt revocation Shiny session ends (example, tab close session timeout), set revoke_on_session_end = TRUE: best-effort: session may end provider unavailable, revocation failures block session cleanup.","code":"auth <- oauth_module_server(   \"auth\",   client = client,   revoke_on_session_end = TRUE )"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/example-spotify.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Example: Spotify login to display listening data","text":"vignette demonstrates code example Shiny application uses shinyOAuth package authenticate users via Spotify’s OAuth 2.0 service. logging , app fetches displays data user listening behaviour form simple dashboard built ‘bslib’. shows user’s profile information avatar, live view currently playing, top tracks artists, history recently played songs. detailed explanation use ‘shinyOAuth’ features, see: vignette(\"usage\", package = \"shinyOAuth\").","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/example-spotify.html","id":"code","dir":"Articles","previous_headings":"","what":"Code","title":"Example: Spotify login to display listening data","text":"","code":"# Example Shiny app using shinyOAuth to connect to Spotify API # # This app demonstrates logging into Spotify with shinyOAuth and fetching # various user statistics via the Spotify Web API. We then build a simple # dashboard to display this information # # Requirements: # - Create a Spotify OAuth 2.0 application at https://developer.spotify.com # - Add a redirect URI that matches redirect_uri below (default: http://127.0.0.1:8100) # - Set environment variables `SPOTIFY_OAUTH_CLIENT_ID` and `SPOTIFY_OAUTH_CLIENT_SECRET`  # Load packages & configure OAuth 2.0 client for Spotify -----------------------  library(shiny) library(shinyOAuth) library(bslib) library(ggplot2) library(DT)  # Configure provider and client for Spotify  provider <- oauth_provider_spotify()  client <- oauth_client(   provider = provider,   client_id = Sys.getenv(\"SPOTIFY_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"SPOTIFY_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\",   scopes = c(     \"user-read-email\",     \"user-read-private\",     \"user-top-read\",     \"user-read-recently-played\",     \"user-read-playback-state\",     \"user-read-currently-playing\"   ) )   # Spotify API helpers ----------------------------------------------------------  # Small helpers to call Spotify API with the user's access token # We define a few specialized functions for common endpoints  spotify_get <- function(token, path, query = list()) {   url <- paste0(\"https://api.spotify.com\", path)    req <- client_bearer_req(token, url, query = query)   resp <- httr2::req_perform(req)    if (httr2::resp_is_error(resp)) {     msg <- sprintf(\"Spotify API error: HTTP %s\", httr2::resp_status(resp))     stop(msg, call. = FALSE)   }    httr2::resp_body_json(resp, simplifyVector = TRUE) }  # Specialized helper for endpoints that may return 204 (e.g., currently-playing) spotify_get_maybe_empty <- function(token, path, query = list()) {   url <- paste0(\"https://api.spotify.com\", path)      req <- client_bearer_req(token, url, query = query)   resp <- httr2::req_perform(req)      status <- httr2::resp_status(resp)   if (status == 204L) {     return(NULL)   }      if (httr2::resp_is_error(resp)) {     msg <- sprintf(\"Spotify API error: HTTP %s\", status)     stop(msg, call. = FALSE)   }      httr2::resp_body_json(resp, simplifyVector = TRUE) }  # Fetch top tracks and artists (short_term: last 4 weeks) get_top_tracks <- function(token, limit = 10, time_range = \"short_term\") {   out <- spotify_get(     token,     \"/v1/me/top/tracks\",     query = list(limit = limit, time_range = time_range)   )    items <- out$items %||% list()   if (length(items) == 0) {     return(data.frame())   }    df <- purrr::map(seq_along(items), function(i) {     item <- items[i, ]     data.frame(       name = item$name %||% NA_character_,       artist = paste(item$artists[[1]]$name, collapse = \", \"),       album = item$album$name %||% NA_character_,       popularity = as.numeric(item$popularity) %||% NA_real_,       stringsAsFactors = FALSE     )   }) |>      dplyr::bind_rows()    df }  # Fetch top artists get_top_artists <- function(token, limit = 10, time_range = \"short_term\") {   out <- spotify_get(     token,     \"/v1/me/top/artists\",     query = list(limit = limit, time_range = time_range)   )    items <- out$items %||% list()   if (length(items) == 0) {     return(data.frame())   }    df <- purrr::map(seq_along(items), function(i) {     item <- items[i, ]     data.frame(       name = item$name %||% NA_character_,       genres = paste(         as.character(item$genres |> purrr::flatten() %||% character()),         collapse = \", \"       ),       popularity = as.numeric(item$popularity) %||% NA_real_,       followers = as.numeric(item$followers$total %||% NA_real_),       stringsAsFactors = FALSE     )   }) |>     dplyr::bind_rows()    df }  # Get recently played tracks get_recently_played <- function(token, limit = 20) {   out <- spotify_get(     token,     \"/v1/me/player/recently-played\",     query = list(limit = limit)   )    items <- out$items %||% list()   if (length(items) == 0) {     return(data.frame())   }    df <- purrr::map(seq_along(items), function(i) {     item <- items[i, ]     data.frame(       played_at = as.POSIXct(item$played_at %||% NA_character_, tz = \"UTC\"),       track = item$track$name %||% NA_character_,       artist = paste(item$track$artists[[1]]$name, collapse = \", \"),       album = item$track$album$name %||% NA_character_,       stringsAsFactors = FALSE     )   }) |>     dplyr::bind_rows()    df }  # Currently playing (may be NULL if nothing is playing) get_currently_playing <- function(token) {   out <- spotify_get_maybe_empty(token, \"/v1/me/player/currently-playing\")    if (is.null(out)) {     return(NULL)   }      # Normalize essential fields with guards   item <- out$item    if (is.null(item)) {     return(NULL)   }      artists <- tryCatch(     {       if (!is.null(item$artists) && length(item$artists) > 0) {         paste(item$artists$name, collapse = \", \")       } else {         \"—\"       }     },     error = function(e) \"—\"   )      art_url <- tryCatch(     {       item$album$images$url[[1]]     },     error = function(e) NULL   )      list(     is_playing = isTRUE(out$is_playing),     progress_ms = as.numeric(out$progress_ms %||% NA_real_),     duration_ms = as.numeric(item$duration_ms %||% NA_real_),     track = item$name %||% \"—\",     artist = artists,     album = item$album$name %||% \"—\",     art = art_url   ) }  # Helper to safely validate data frames returned from API calls safe_df <- function(x) {   if (inherits(x, \"try-error\")) {     return(NULL)   }      if (is.null(x) || !is.data.frame(x) || nrow(x) == 0) {     return(NULL)   }      x }  # Format milliseconds to m:ss format_ms <- function(ms) {   if (is.null(ms) || is.na(ms)) {     return(\"—\")   }      s <- round(as.numeric(ms) / 1000)      sprintf(\"%d:%02d\", s %/% 60, s %% 60) }   # Shiny app --------------------------------------------------------------------  ## Theme & CSS -----------------------------------------------------------------  # Some basic Bootstrap theming spotify_theme <- bs_theme(   version = 5,   base_font = font_google(\"Inter\"),   heading_font = font_google(\"Space Grotesk\"),   bg = \"#121212\",   fg = \"#F5F6F8\",   primary = \"#1DB954\",   secondary = \"#191414\",   success = \"#1ED760\",   \"navbar-bg\" = \"#0F0F0F\",   \"card-border-color\" = \"#1DB95433\" )  # Add CSS spotify_theme <- bs_add_rules(   spotify_theme,   paste(     \"body { background: radial-gradient(circle at top left, #1DB95411, #121212 55%); }\",     \".navbar-dark { border-bottom: 1px solid #1DB95422; }\",     \".card { background-color: #181818; border-radius: 18px; box-shadow: 0 18px 30px -24px rgba(0,0,0,0.7); transition: transform 0.2s, box-shadow 0.2s; }\",     \".card:hover { box-shadow: 0 20px 35px -20px rgba(29, 185, 84, 0.3); }\",     \".card-header { background-color: rgba(29, 185, 84, 0.08); border-bottom: 1px solid rgba(29, 185, 84, 0.2); font-weight: 600; }\",     \".profile-avatar { width: 72px; height: 72px; border-radius: 50%; object-fit: cover; box-shadow: 0 0 0 3px #1DB95455; transition: box-shadow 0.3s; }\",     \".profile-avatar:hover { box-shadow: 0 0 0 4px #1DB954; }\",     \".login-hero { min-height: 60vh; }\",     \".login-card { background: linear-gradient(130deg, #1DB954 0%, #1AA34A 55%, #121212 100%); color: #0C0C0C; border: none; }\",     \".login-card .btn { background-color: #121212; color: #F5F6F8; border: none; transition: all 0.3s; }\",     \".login-card .btn:hover { background-color: #0f0f0f; color: #1DB954; transform: scale(1.05); }\",     \".value-box { background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%); border: 1px solid #1DB95433; border-radius: 12px; transition: border-color 0.3s; padding: 0.6rem 0.9rem !important; }\",     \".value-box:hover { border-color: #1DB95466; }\",     \".value-box .value { font-size: 1.3rem; font-weight: 700; color: #1DB954; line-height: 1.2; }\",     \".value-box .value-box-title, .value-box h6, .value-box .title { font-size: 0.85rem; letter-spacing: .02em; opacity: .95; }\",     \".value-box p { margin-bottom: 0; font-size: 0.9rem; }\",     \".value-box .showcase-icon { color: #1DB954; opacity: 0.7; }\",     \".table { color: #F5F6F8; margin-bottom: 0; }\",     \".table thead { color: #1DB954; font-weight: 600; border-bottom: 2px solid #1DB95444; }\",     \".table tbody tr { transition: background-color 0.2s; }\",     \".table tbody tr:hover { background-color: rgba(29, 185, 84, 0.15); }\",     \".table td { vertical-align: middle; padding: 0.75rem; }\",     \".table td:first-child { color: #1DB954; font-weight: 600; width: 40px; text-align: center; }\",     \".control-card { background: rgba(16, 16, 16, 0.7); border: 1px solid #1DB95422; }\",     \".badge { font-size: 0.85rem; padding: 0.4em 0.8em; }\",     \".play-count-badge { background: linear-gradient(135deg, #1DB954 0%, #1AA34A 100%); color: #000; font-weight: 700; }\",     \".navbar .navbar-nav { display: none !important; }\",     sep = \"\\n\"   ) )  # Subtle readability and responsive polish overrides spotify_theme <- bs_add_rules(   spotify_theme,   paste(     \"/* Ensure cards don't collapse too small on narrow screens */\",     \".card { min-width: 300px; }\",     \"/* Avoid horizontal scroll within cards */\",     \".card .card-body { overflow-x: hidden; }\",     \"/* Add gap between cards in layout_columns */\",     \".bslib-grid { gap: 1rem !important; }\",     \"/* Ensure proper wrapping for cards - prevent cards from becoming too narrow */\",     \".bslib-grid > div { min-width: 300px; flex: 1 1 300px; }\",     \"/* Prevent value box containers from collapsing */\",     \".card-body .bslib-grid { display: flex; flex-wrap: wrap; }\",      \"/* Softer login gradient and better contrast */\",     \".login-card { background: linear-gradient(145deg, rgba(29,185,84,0.18) 0%, rgba(29,185,84,0.08) 38%, #1a1a1a 100%); color: #F5F6F8; border: 1px solid #1DB95422; overflow: hidden; }\",     \".login-card .btn { background-color: #121212; color: #F5F6F8; border: 1px solid #1DB95444; transition: background-color 0.25s, color 0.25s, box-shadow 0.25s; }\",     \".login-card .btn:hover { background-color: #0f0f0f; color: #1DB954; box-shadow: 0 8px 22px rgba(29,185,84,0.22); }\",     \".login-card .btn:focus, .login-card .btn:focus-visible { outline: none; box-shadow: 0 0 0 0.2rem rgba(29,185,84,0.35); }\",      \"/* Improve muted text contrast inside cards/value boxes */\",     \".card .text-muted, .value-box .text-muted { color: #CFD3D8 !important; }\",      \"/* DataTables dark theme tweaks */\",     \".dataTables_wrapper .dataTables_length select, .dataTables_wrapper .dataTables_filter input { background-color: #0f0f0f; color: #F5F6F8; border: 1px solid #1DB95433; }\",     \".dataTables_wrapper .dataTables_paginate .paginate_button { color: #F5F6F8 !important; border: 1px solid transparent; }\",     \".dataTables_wrapper .dataTables_paginate .paginate_button.current, .dataTables_wrapper .dataTables_paginate .paginate_button:hover { color: #1DB954 !important; background: #0f0f0f; border-color: #1DB95433; }\",     \".dataTables_wrapper .dataTables_info { color: #E4E7EB; }\",      \"/* Slightly more visible table header border for clarity */\",     \".table thead { border-bottom: 2px solid #1DB95455; }\",      \"/* Custom Spotify outline button (for Sign out) */\",     \".btn-spotify-outline { color: #1DB954; border: 1px solid #1DB95499; background: transparent; }\",     \".btn-spotify-outline:hover { color: #0b0b0b; background: #1DB954; border-color: #1DB954; }\",      \"/* Plan badge for better readability */\",     \".badge-plan { background: transparent; border: 1px solid #1DB95466; color: #F5F6F8; }\",      \"/* Sidebar toggle visibility */\",     \".layout-sidebar .collapse-toggle, .layout-sidebar .sidebar-toggle, .bslib-sidebar-layout .collapse-toggle { color: #F5F6F8; border: 1px solid #1DB95455; background: #0f0f0f; }\",     \".layout-sidebar .collapse-toggle:hover, .layout-sidebar .sidebar-toggle:hover, .bslib-sidebar-layout .collapse-toggle:hover { border-color: #1DB954aa; color: #1DB954; }\",      \"/* Value box compact sizing and min width with proper wrapping */\",     \".value-box { min-width: 220px; margin-bottom: 0.75rem; flex: 1 1 220px; }\",     \".value-box .showcase-top, .value-box .showcase-bottom, .value-box .showcase-area { gap: .5rem; }\",     \".value-box .showcase-icon { font-size: 0.95rem; }\",     \"/* Prevent value box text overflow */\",     \".value-box .value { word-break: break-word; font-size: 1.1rem !important; }\",     \".value-box p { word-break: break-word; overflow-wrap: break-word; font-size: 0.85rem; }\",     \".value-box .title, .value-box h6 { font-size: 0.8rem; }\",      \"/* Now playing artwork sizing */\",     \".now-playing-art { width: 80px; height: 80px; object-fit: cover; border-radius: 8px; box-shadow: 0 8px 18px rgba(0,0,0,.35); }\",      sep = \"\\n\"   ) )   ## UI --------------------------------------------------------------------------  ui <- bslib::page_fluid(   title = tags$span(     class = \"d-flex align-items-center gap-2\",     icon(\"headphones\"),     span(class = \"fw-semibold\", \"Spotify Listening Studio\")   ),   theme = spotify_theme,   use_shinyOAuth(),   div(     class = \"pt-4 pb-5\",     uiOutput(\"oauth_error\"),     conditionalPanel(       condition = \"output.isAuthenticated\",       layout_sidebar(         sidebar = sidebar(           card(             class = \"control-card\",             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"sliders-h\"),               span(\"Personalize view\")             )),             card_body(               selectInput(                 \"time_range\",                 \"Listening window\",                 choices = c(                   \"Last 4 weeks\" = \"short_term\",                   \"Last 6 months\" = \"medium_term\",                   \"All-time favorites\" = \"long_term\"                 ),                 selected = \"short_term\"               ),               sliderInput(                 \"top_limit\",                 \"Top items\",                 min = 5,                 max = 20,                 value = 10,                 step = 1               )             ),             card_footer(tags$small(               class = \"text-muted\",               \"Adjust filters to explore different eras of your listening.\"             ))           ),           width = 320,           open = TRUE         ),         fillable = TRUE,         layout_column_wrap(           width = \"350px\",           heights_equal = \"row\",           card(             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"user\"),               span(\"Profile\")             )),             card_body(uiOutput(\"profile\"))           ),           card(             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"play-circle\"),               span(\"Listening sessions\")             )),             card_body(uiOutput(\"summary_boxes\"))           ),           card(             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"broadcast-tower\"),               span(\"Now playing\")             )),             card_body(uiOutput(\"now_playing\"))           )         ),         layout_column_wrap(           width = \"400px\",           fill = TRUE,           card(             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"music\"),               span(\"Top tracks\")             )),             card_body(DTOutput(\"top_tracks\"))           ),           card(             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"users\"),               span(\"Top artists\")             )),             card_body(DTOutput(\"top_artists\"))           )         ),         layout_column_wrap(           width = NULL,           fill = TRUE,           style = css(grid_template_columns = \"3fr 2fr\"),           card(             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"history\"),               span(\"Recent plays\")             )),             card_body(DTOutput(\"recent\"))           ),           card(             card_header(div(               class = \"d-flex align-items-center gap-2\",               icon(\"chart-bar\"),               span(\"Artists on repeat\")             )),             card_body(plotOutput(\"recent_artist_plot\", height = \"400px\"))           )         )       )     ),     conditionalPanel(       condition = \"!output.isAuthenticated\",       div(         class = \"login-hero d-flex justify-content-center align-items-center\",         card(           class = \"login-card text-center p-5\",           card_body(             icon(\"headphones\", class = \"display-4 mb-3\"),             h2(\"Spotify Listening Studio\"),             p(               class = \"lead\",               \"Sign in to reveal your personal soundtrack: relive your top tracks, spotlight your favorite artists, and surface the songs you can't stop replaying.\"             ),             actionButton(               \"login\",               \"Sign in with Spotify\",               class = \"btn btn-lg px-4 py-3 mt-2\"             ),             div(               class = \"mt-3 small\",               tags$strong(\"Scopes:\"),               \" user-top-read • user-read-recently-played • user-read-email • user-read-private\"             )           )         )       )     )   ) )   ## Server ----------------------------------------------------------------------  server <- function(input, output, session) {   # Handle Spotify login -------------------------------------------------------    auth <- oauth_module_server(\"auth\", client, auto_redirect = FALSE)    # Expose auth state to JS for our conditionalPanel   output$isAuthenticated <- shiny::reactive({     isTRUE(auth$authenticated)   })   shiny::outputOptions(output, \"isAuthenticated\", suspendWhenHidden = FALSE)    observeEvent(input$login, {     auth$request_login()   })    observeEvent(input$logout, {     req(isTRUE(auth$authenticated))     auth$logout()   })    output$oauth_error <- renderUI({     if (!is.null(auth$error)) {       msg <- auth$error       if (!is.null(auth$error_description)) {         msg <- paste0(msg, \": \", auth$error_description)       }       div(class = \"alert alert-danger\", role = \"alert\", msg)     }   })    # Show user profile ----------------------------------------------------------    output$profile <- renderUI({     req(auth$token)     user_info <- auth$token@userinfo     if (length(user_info) == 0) {       return(div(class = \"text-muted\", \"No user info\"))     }      avatar <- NULL     if (       !is.null(user_info$images) &&         is.data.frame(user_info$images) &&         nrow(user_info$images) > 0     ) {       img_url <- user_info$images$url[[1]]       if (!is.null(img_url) && nzchar(img_url)) {         avatar <- tags$img(           src = img_url,           class = \"profile-avatar\",           alt = \"User avatar\"         )       }     }      display_name <- user_info$display_name %||% user_info$id %||% \"<unknown>\"      followers_badge <- NULL     if (       !is.null(user_info$followers) &&         is.list(user_info$followers) &&         !is.null(user_info$followers$total)     ) {       followers_badge <- span(         class = \"badge bg-success-subtle text-success-emphasis\",         \"Followers:\",         tags$span(           class = \"ms-1\",           format(user_info$followers$total, big.mark = \",\")         )       )     }      plan_badge <- NULL     if (!is.null(user_info$product)) {       plan_badge <- span(         class = \"badge badge-plan\",         paste(\"Plan:\", user_info$product)       )     }      country_badge <- NULL     if (!is.null(user_info$country)) {       country_badge <- span(         class = \"badge bg-dark border border-success\",         paste(\"Country:\", user_info$country)       )     }      spotify_link <- NULL     if (       !is.null(user_info$external_urls) &&         is.list(user_info$external_urls) &&         !is.null(user_info$external_urls$spotify)     ) {       spotify_link <- a(         icon(\"external-link-alt\", class = \"ms-2\"),         href = user_info$external_urls$spotify,         class = \"text-decoration-none text-success\",         target = \"_blank\",         title = \"Open in Spotify\"       )     }      tagList(       div(         class = \"d-flex align-items-center gap-3 flex-wrap\",         avatar,         div(           h4(class = \"mb-1\", display_name, spotify_link),           if (!is.null(user_info$email)) {             span(class = \"text-muted\", user_info$email)           }         ),         div(           class = \"ms-auto\",           actionButton(             \"logout\",             \"Sign out\",             class = \"btn btn-spotify-outline btn-sm\"           )         )       ),       hr(class = \"border-success-subtle\"),       div(         class = \"d-flex flex-wrap gap-2\",         followers_badge,         plan_badge,         country_badge       )     )   })    # Reactives containing Spotify data ------------------------------------------    # Data fetch reactives   top_tracks <- reactive({     req(auth$token, input$time_range, input$top_limit)     try(       get_top_tracks(         auth$token,         limit = input$top_limit,         time_range = input$time_range       ),       silent = FALSE     )   })    top_artists <- reactive({     req(auth$token, input$time_range, input$top_limit)     try(       get_top_artists(         auth$token,         limit = input$top_limit,         time_range = input$time_range       ),       silent = FALSE     )   })    recent <- reactive({     req(auth$token)     try(get_recently_played(auth$token, limit = 50), silent = FALSE)   })    summary_data <- reactive({     tracks_df <- safe_df(top_tracks())     artists_df <- safe_df(top_artists())     recent_df <- safe_df(recent())      list(       top_track = if (!is.null(tracks_df)) {         list(           name = tracks_df$name[1] %||% \"—\",           artist = tracks_df$artist[1] %||% \"—\"         )       } else {         NULL       },       top_artist = if (!is.null(artists_df)) {         list(           name = artists_df$name[1] %||% \"—\",           genres = if (             !is.null(artists_df$genres[1]) && nzchar(artists_df$genres[1])           ) {             artists_df$genres[1]           } else {             \"—\"           }         )       } else {         NULL       },       last_play = if (!is.null(recent_df)) {         list(           track = recent_df$track[1] %||% \"—\",           artist = recent_df$artist[1] %||% \"—\",           played_at = recent_df$played_at[1]         )       } else {         NULL       },       unique_recent = if (!is.null(recent_df)) {         dplyr::n_distinct(recent_df$artist)       } else {         NA_integer_       }     )   })    # Summary cards --------------------------------------------------------------    # These show a few different summary stats about the user's listening    output$summary_boxes <- renderUI({     data <- summary_data()      top_track <- data$top_track     top_artist <- data$top_artist     last_play <- data$last_play      top_track_name <- if (!is.null(top_track)) top_track$name else \"—\"     top_track_artist <- if (!is.null(top_track)) {       top_track$artist     } else {       \"No data for this window\"     }      top_artist_name <- if (!is.null(top_artist)) top_artist$name else \"—\"     top_artist_genres <- if (!is.null(top_artist)) {       top_artist$genres     } else {       \"No genres available\"     }      last_track_name <- if (!is.null(last_play)) last_play$track else \"—\"     last_track_details <- if (!is.null(last_play)) {       parts <- c(last_play$artist %||% \"—\")       if (!is.null(last_play$played_at) && !is.na(last_play$played_at)) {         parts <- c(parts, format(last_play$played_at, \"%b %d • %H:%M\", tz = \"\"))       }       paste(parts, collapse = \"  |  \")     } else {       \"No recent playback\"     }      unique_recent <- data$unique_recent     unique_recent_value <- if (!is.na(unique_recent)) unique_recent else \"—\"      layout_column_wrap(       width = \"220px\",       value_box(         title = \"Top Track\",         value = top_track_name,         showcase = icon(\"music\"),         p(class = \"text-muted\", top_track_artist)       ),       value_box(         title = \"Top Artist\",         value = top_artist_name,         showcase = icon(\"star\"),         p(class = \"text-muted\", top_artist_genres)       ),       value_box(         title = \"Recent Session\",         value = last_track_name,         showcase = icon(\"clock\"),         p(class = \"text-muted\", last_track_details)       ),       value_box(         title = \"Unique Artists (recent)\",         value = unique_recent_value,         showcase = icon(\"users\"),         p(class = \"text-muted\", \"Across your latest 50 plays\")       )     )   })    # Top tracks -----------------------------------------------------------------    # Shows the user's top tracks in a data table    output$top_tracks <- renderDT({     df <- top_tracks()     shiny::validate(       need(!inherits(df, \"try-error\"), \"Failed to load top tracks\"),       need(!is.null(df) && nrow(df) > 0, \"No tracks returned for this window\")     )      # Calculate play counts from recent plays     recent_df <- safe_df(recent())     if (!is.null(recent_df)) {       recent_df$key <- paste0(recent_df$track, \" — \", recent_df$artist)       df$key <- paste0(df$name, \" — \", df$artist)       play_counts <- table(recent_df$key)       df$plays <- vapply(         df$key,         function(k) {           count <- suppressWarnings(play_counts[k])           if (is.na(count)) 0L else as.integer(count)         },         integer(1)       )     } else {       df$plays <- 0L     }      # Drop rows that are entirely missing name & artist     keep <- (!is.na(df$name) & nzchar(df$name)) |       (!is.na(df$artist) & nzchar(df$artist))     df <- df[keep, , drop = FALSE]      df <- df[, c(\"name\", \"artist\", \"album\", \"plays\", \"popularity\")]     df$plays <- ifelse(df$plays > 0, sprintf(\"🔁 %d\", df$plays), \"—\")     df$popularity <- ifelse(       is.na(df$popularity),       \"—\",       sprintf(\"⭐ %d\", round(df$popularity))     )      # Add rank numbers     df <- cbind(`#` = seq_len(nrow(df)), df)      df <- stats::setNames(       df,       c(\"#\", \"Track\", \"Artist\", \"Album\", \"Recent Plays\", \"Popularity\")     )     datatable(       df,       rownames = FALSE,       escape = FALSE,       options = list(         pageLength = 10,         lengthChange = FALSE,         order = list(list(0, 'asc')),         columnDefs = list(           list(orderable = FALSE, targets = 0)         )       )     )   })    # Top artists ----------------------------------------------------------------    # Shows the user's top artists in a data table    output$top_artists <- renderDT({     df <- top_artists()     shiny::validate(       need(!inherits(df, \"try-error\"), \"Failed to load top artists\"),       need(!is.null(df) && nrow(df) > 0, \"No artists returned for this window\")     )     df <- df[, c(\"name\", \"genres\", \"popularity\", \"followers\")]     df$genres[df$genres == \"\"] <- \"—\"     df$genres <- vapply(       df$genres,       function(g) {         if (nchar(g) > 50) paste0(substr(g, 1, 47), \"...\") else g       },       character(1)     )     df$popularity <- ifelse(       is.na(df$popularity),       \"—\",       sprintf(\"⭐ %d\", round(df$popularity))     )     df$followers <- ifelse(       is.na(df$followers),       \"—\",       paste0(\"👥 \", format(round(df$followers), big.mark = \",\"))     )      # Add rank numbers     df <- cbind(`#` = seq_len(nrow(df)), df)      df <- stats::setNames(       df,       c(\"#\", \"Artist\", \"Genres\", \"Popularity\", \"Followers\")     )     datatable(       df,       rownames = FALSE,       escape = FALSE,       options = list(         pageLength = 10,         lengthChange = FALSE,         order = list(list(0, 'asc')),         columnDefs = list(           list(orderable = FALSE, targets = 0)         )       )     )   })    # Recent plays ---------------------------------------------------------------    # Shows the user's recent plays in a data table    output$recent <- renderDT({     df <- recent()     shiny::validate(       need(!inherits(df, \"try-error\"), \"Failed to load recent plays\"),       need(!is.null(df) && nrow(df) > 0, \"No recent plays available\")     )     df$played <- format(df$played_at, \"%b %d • %H:%M\", tz = \"\")     df <- df[, c(\"played\", \"track\", \"artist\", \"album\")]      # Add rank numbers     df <- cbind(`#` = seq_len(nrow(df)), df)     df <- stats::setNames(df, c(\"#\", \"Played\", \"Track\", \"Artist\", \"Album\"))     datatable(       df,       rownames = FALSE,       options = list(         pageLength = 10,         lengthChange = FALSE,         order = list(list(0, 'desc')),         columnDefs = list(           list(orderable = FALSE, targets = 0)         )       )     )   })    # Recent artists plot --------------------------------------------------------    # Bar plot of most frequently played artists in recent plays    output$recent_artist_plot <- renderPlot({     df_recent <- recent()     shiny::validate(       need(!inherits(df_recent, \"try-error\"), \"Failed to load recent plays\"),       need(         !is.null(df_recent) && nrow(df_recent) > 0,         \"No recent plays available\"       )     )      # Primary: counts from recent plays     counts <- sort(table(df_recent$artist), decreasing = TRUE)     counts_df <- data.frame(       artist = names(counts),       plays = as.numeric(counts),       stringsAsFactors = FALSE     )      # If the recent signal is weak (<= 3 artists or max <= 1), fall back to time-range top artists by popularity     use_fallback <- nrow(counts_df) <= 3 ||       max(counts_df$plays, na.rm = TRUE) <= 1     if (isTRUE(use_fallback)) {       df_top <- safe_df(top_artists())       if (!is.null(df_top) && nrow(df_top) > 0) {         counts_df <- df_top[, c(\"name\", \"popularity\")]         names(counts_df) <- c(\"artist\", \"plays\")       }     }      # Take top 10 and order for plotting     counts_df <- utils::head(       counts_df[order(counts_df$plays, decreasing = TRUE), ],       10L     )     counts_df$artist <- factor(counts_df$artist, levels = rev(counts_df$artist))      x_lab <- if (isTRUE(use_fallback)) \"Popularity\" else \"Plays (last 50)\"      ggplot(counts_df, aes_string(x = \"plays\", y = \"artist\")) +       geom_col(fill = \"#1DB954\", width = 0.65) +       geom_text(aes(label = plays), hjust = -0.2, color = \"#F5F6F8\", size = 4) +       scale_x_continuous(expand = expansion(mult = c(0, 0.08))) +       labs(x = x_lab, y = NULL) +       theme_minimal(base_family = \"Inter\", base_size = 13) +       theme(         plot.background = element_rect(fill = \"#181818\", colour = NA),         panel.background = element_rect(fill = \"#181818\", colour = NA),         panel.grid.major.y = element_blank(),         panel.grid.major.x = element_line(colour = \"#FFFFFF22\"),         text = element_text(colour = \"#F5F6F8\"),         axis.text.y = element_text(colour = \"#F5F6F8\", size = 12),         axis.text.x = element_text(colour = \"#F5F6F8\", size = 11),         plot.margin = margin(10, 20, 10, 20)       )   })    # Now playing ----------------------------------------------------------------    # Shows the user's currently playing track with a progress bar    output$now_playing <- renderUI({     req(auth$token)     # refresh every 5 seconds     invalidateLater(5000, session)     playing <- try(get_currently_playing(auth$token), silent = FALSE)     if (inherits(playing, \"try-error\") || is.null(playing)) {       return(div(class = \"text-muted\", \"Nothing playing right now\"))     }      pct <- NA_real_     if (       !is.na(playing$progress_ms) &&         !is.na(playing$duration_ms) &&         playing$duration_ms > 0     ) {       pct <- max(         0,         min(100, round(playing$progress_ms / playing$duration_ms * 100))       )     }      progress_bar <- NULL     if (!is.na(pct)) {       progress_bar <- div(         class = \"progress mt-2\",         div(           class = \"progress-bar bg-success\",           role = \"progressbar\",           style = paste0(\"width: \", pct, \"%\"),           `aria-valuenow` = pct,           `aria-valuemin` = 0,           `aria-valuemax` = 100         )       )     }      time_label <- span(       class = \"small text-muted\",       paste(format_ms(playing$progress_ms), \"/\", format_ms(playing$duration_ms))     )      tagList(       div(         class = \"d-flex gap-3 align-items-center\",         if (!is.null(playing$art)) {           tags$img(             src = playing$art,             class = \"now-playing-art\",             alt = \"Album art\"           )         },         div(           div(class = \"fw-semibold\", playing$track),           div(class = \"text-muted\", paste(playing$artist, \"•\", playing$album))         )       ),       progress_bar,       div(class = \"d-flex justify-content-end\", time_label)     )   }) }   # Run app ----------------------------------------------------------------------  shiny::runApp(   shinyApp(ui, server), port = 8100,   launch.browser = FALSE )  # Open the app in your regular browser at http://127.0.0.1:8100 # (viewers in RStudio/Positron/etc. cannot perform necessary redirects)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Usage","text":"‘shinyOAuth’ implements provider‑agnostic OAuth 2.0 OpenID Connect (OIDC) authorization/authentication Shiny apps, modern S7 classes secure defaults. streamlines full authorization/authentication flow, including: Building authorization URLs redirecting unauthenticated users State, nonce, PKCE generation, sealing, verification Authorization code exchange token validation Optional userinfo retrieval & ID token signature/claims validation Proactive token refresh re‑authentication triggers full step--step protocol breakdown, see separate vignette: vignette(\"authentication-flow\", package = \"shinyOAuth\"). detailed explanation audit logging key events flow, see: vignette(\"audit-logging\", package = \"shinyOAuth\").","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"minimal-shiny-module-example","dir":"Articles","previous_headings":"","what":"Minimal Shiny module example","title":"Usage","text":"minimal example using GitHub’s OAuth 2.0 app (shown README). Register OAuth 2.0 application https://github.com/settings/developers set environment variables GITHUB_OAUTH_CLIENT_ID GITHUB_OAUTH_CLIENT_SECRET. Note ui includes use_shinyOAuth() load necessary JavaScript dependency. Always place use_shinyOAuth() UI; otherwise, module function. may place near top-level UI (e.g., inside fluidPage(), tagList(), bslib::page()). Note also must access app regular browser. necesarry redirects browser must perform can usually handled inside embedded viewers IDEs like RStudio Positron.","code":"library(shiny) library(shinyOAuth)  provider <- oauth_provider_github()  client <- oauth_client(   provider = provider,   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\",   scopes = c(\"read:user\", \"user:email\") )  ui <- fluidPage(   # Include JavaScript dependency:   use_shinyOAuth(),   # Render login status & user info:   uiOutput(\"login\") )  server <- function(input, output, session) {   auth <- oauth_module_server(\"auth\", client, auto_redirect = TRUE)   output$login <- renderUI({     if (auth$authenticated) {       user_info <- auth$token@userinfo       tagList(         tags$p(\"You are logged in!\"),         tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))       )     } else {       tags$p(\"You are not logged in.\")     }   }) }  runApp(   shinyApp(ui, server),   port = 8100,   launch.browser = FALSE )  # Open the app in your regular browser at http://127.0.0.1:8100 # (viewers in RStudio/Positron/etc. cannot perform necessary redirects)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"manual-login-button-variant","dir":"Articles","previous_headings":"","what":"Manual login button variant","title":"Usage","text":"example user clicks button start login process instead redirected immediately page load.","code":"library(shiny) library(shinyOAuth)  provider <- oauth_provider_github()  client <- oauth_client(   provider = provider,   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\",   scopes = c(\"read:user\", \"user:email\") )  ui <- fluidPage(   use_shinyOAuth(),   actionButton(\"login_btn\", \"Login\"),   uiOutput(\"login\") )  server <- function(input, output, session) {   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = FALSE   )    observeEvent(input$login_btn, {     auth$request_login()   })    output$login <- renderUI({     if (auth$authenticated) {       user_info <- auth$token@userinfo       tagList(         tags$p(\"You are logged in!\"),         tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))       )     } else {       tags$p(\"You are not logged in.\")     }   }) }  runApp(   shinyApp(ui, server),   port = 8100,   launch.browser = FALSE )  # Open the app in your regular browser at http://127.0.0.1:8100 # (viewers in RStudio/Positron/etc. cannot perform necessary redirects)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"making-authenticated-api-calls","dir":"Articles","previous_headings":"","what":"Making authenticated API calls","title":"Usage","text":"authenticated, may want call API behalf user using access token. Use client_bearer_req() quickly build authorized ‘httr2’ request correct Bearer token. See example app ; calls GitHub API obtain user’s repositories. example application fetches data Spotify web API, see: vignette(\"example-spotify\", package = \"shinyOAuth\").","code":"library(shiny) library(shinyOAuth)  provider <- oauth_provider_github()  client <- oauth_client(   provider = provider,   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\",   scopes = c(\"read:user\", \"user:email\") )  ui <- fluidPage(   use_shinyOAuth(),   uiOutput(\"ui\") )  server <- function(input, output, session) {   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = TRUE   )    repositories <- reactiveVal(NULL)    observe({     req(auth$authenticated)      # Example additional API request using the access token     # (e.g., fetch user repositories from GitHub)     req <- client_bearer_req(auth$token, \"https://api.github.com/user/repos\")     resp <- httr2::req_perform(req)      if (httr2::resp_is_error(resp)) {       repositories(NULL)     } else {       repos_data <- httr2::resp_body_json(resp, simplifyVector = TRUE)       repositories(repos_data)     }   })    # Render username + their repositories   output$ui <- renderUI({     if (isTRUE(auth$authenticated)) {       user_info <- auth$token@userinfo       repos <- repositories()        return(tagList(         tags$p(paste(\"You are logged in as:\", user_info$login)),         tags$h4(\"Your repositories:\"),         if (!is.null(repos)) {           tags$ul(             Map(function(url, name) {               tags$li(tags$a(href = url, target = \"_blank\", name))             }, repos$html_url, repos$full_name)           )         } else {           tags$p(\"Loading repositories...\")         }       ))     }      return(tags$p(\"You are not logged in.\"))   }) }  runApp(   shinyApp(ui, server),   port = 8100,   launch.browser = FALSE )  # Open the app in your regular browser at http://127.0.0.1:8100 # (viewers in RStudio/Positron/etc. cannot perform necessary redirects)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"token-introspection-optional","dir":"Articles","previous_headings":"","what":"Token introspection (optional)","title":"Usage","text":"default, oauth_module_server() considers login complete callback validated token retrieval plus configured OIDC checks succeeded. provider supports RFC 7662 token introspection, can optionally add extra login-time validation step enabling introspect = TRUE creating oauth_client(). enabled, module calls provider introspection endpoint callback processing requires response indicate active = TRUE. introspection unsupported provider introspection request fails, login aborted $authenticated set TRUE. can optionally request additional checks via introspect_elements: \"sub\" – require introspected sub match session subject (ID token sub available; otherwise userinfo sub available) \"client_id\" – require introspected client_id match OAuth client id \"scope\" – validate returned scopes requested scopes; follows client’s scope_validation mode (\"strict\" errors, \"warn\" warns, \"none\" skips scope checks) (Note providers may return fields introspection responses.)","code":"# Example with introspection enabled client <- oauth_client(   provider = provider,   client_id = Sys.getenv(\"OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\",   introspect = TRUE,   introspect_elements = c(\"sub\", \"client_id\", \"scope\") )  auth <- oauth_module_server(\"auth\", client, auto_redirect = TRUE)"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"async-mode-to-keep-ui-responsive","dir":"Articles","previous_headings":"","what":"Async mode to keep UI responsive","title":"Usage","text":"default, oauth_module_server() performs network operations (authorization code exchange, refresh, userinfo) main R thread. transient network errors package retries backoff, sleeping main thread can block Shiny event loop worker process. avoid blocking, enable async mode configure async backend. package supports ‘mirai’ ‘future’ async execution (see ). package auto-detects backend configured. set , mirai takes precedence (offers lower overhead non-blocking dispatch). need keep async = FALSE, may consider reducing retry behaviour limit blocking provider incidents. See ‘Global options’ ‘HTTP timeout/retries’.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"mirai-async-backend-recommended","dir":"Articles","previous_headings":"Async mode to keep UI responsive","what":"‘mirai’ async backend (recommended)","title":"Usage","text":"","code":"# Set up daemons at the top of your app (or in global.R) mirai::daemons(2)  # Clean up daemons when the app stops onStop(function() mirai::daemons(0))  server <- function(input, output, session) {   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = TRUE,     async = TRUE # Run token exchange & refresh off the main thread   )      # ... }"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"future-async-backend","dir":"Articles","previous_headings":"Async mode to keep UI responsive","what":"‘future’ async backend","title":"Usage","text":"","code":"# Set up workers at the top of your app future::plan(future::multisession, workers = 2)  server <- function(input, output, session) {   auth <- oauth_module_server(     \"auth\",     client,     auto_redirect = TRUE,     async = TRUE # Run token exchange & refresh off the main thread   )      # ... }"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"logout","dir":"Articles","previous_headings":"","what":"Logout","title":"Usage","text":"log user, call auth$logout(). clears local session attempts revoke tokens provider (revocation endpoint available): Revocation uses RFC 7009 runs asynchronously oauth_module_server(async = TRUE). See ?revoke_token programmatic use outside module.","code":"observeEvent(input$logout_btn, {   auth$logout() })"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"automatic-revocation-on-session-end","dir":"Articles","previous_headings":"Logout","what":"Automatic revocation on session end","title":"Usage","text":"revoke tokens Shiny session ends (e.g., browser tab closed, timeout), set revoke_on_session_end = TRUE: Note: best-effort operation; network failures provider unavailability may prevent revocation. Combine appropriate token lifetimes provider side defense depth.","code":"auth <- oauth_module_server(   \"auth\",   client = client,   revoke_on_session_end = TRUE )"},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"global-options","dir":"Articles","previous_headings":"","what":"Global options","title":"Usage","text":"package provides several global options customize behavior. list available options.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"observabilitylogging","dir":"Articles","previous_headings":"Global options","what":"Observability/logging","title":"Usage","text":"options(shinyOAuth.print_errors = TRUE) – concise error lines (interactive / tests ) options(shinyOAuth.print_traceback = TRUE) – include backtraces (interactive / tests ) options(shinyOAuth.expose_error_body = TRUE) – include sanitized HTTP bodies (may reveal details) options(shinyOAuth.trace_hook = function(event){ ... }) – structured events (errors, http, etc.) options(shinyOAuth.audit_hook = function(event){ ... }) – separate audit stream options(shinyOAuth.audit_include_http = FALSE) – exclude HTTP request details audit events (default: TRUE) options(shinyOAuth.audit_redact_http = FALSE) – disable automatic redaction sensitive data audit events (default: TRUE) options(shinyOAuth.audit_digest_key = ...) – key HMAC-SHA256 audit digests See vignette(\"audit-logging\", package = \"shinyOAuth\") details audit trace hooks.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"networkingsecurity","dir":"Articles","previous_headings":"Global options","what":"Networking/security","title":"Usage","text":"options(shinyOAuth.leeway = 30) – default clock skew leeway (seconds) ID token exp/iat/nbf checks state payload issued_at future check options(shinyOAuth.allowed_non_https_hosts = c(\"localhost\", \"127.0.0.1\", \"::1\")) - allows hosts use http:// scheme instead https:// options(shinyOAuth.allowed_hosts = c()) – non‑empty, restricts accepted hosts whitelist options(shinyOAuth.allow_hs = TRUE) – opt‑HMAC validation ID tokens (HS256/HS384/HS512). Requires strictly server‑side client_secret options(shinyOAuth.client_assertion_ttl = 120L) – lifetime seconds JWT client assertions used client_secret_jwt private_key_jwt token endpoint authentication. Values 60 seconds coerced safe minimum; default 120 seconds options(shinyOAuth.state_fail_delay_ms = c(10, 30)) – adds small randomized delay (milliseconds) state validation failure (e.g., malformed token, IV/tag/ciphertext issues, GCM authentication failure). helps reduce timing side‑channels different failure modes Note allowed_hosts: patterns support globs (*, ?). Using catch‑like \"*\" matches host effectively disables endpoint host restrictions (scheme rules still apply). Avoid unless truly intend accept host; prefer pinning domain(s), e.g., c(\".example.com\").","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"extra-parameter-overrides","dir":"Articles","previous_headings":"Global options","what":"Extra parameter overrides","title":"Usage","text":"default, shinyOAuth blocks certain security‑critical parameters passed via extra_auth_params, extra_token_params, extra_token_headers. prevents accidental misconfiguration break state binding, PKCE integrity, client authentication. specific, advanced use case need override one blocked parameters, can unblock using following options: options(shinyOAuth.unblock_auth_params = c(\"redirect_uri\")) – allows overriding specified authorization URL parameters. Default blocked: response_type, client_id, redirect_uri, state, scope, code_challenge, code_challenge_method, nonce options(shinyOAuth.unblock_token_params = c(...)) – allows overriding specified token exchange parameters. Default blocked: grant_type, code, redirect_uri, code_verifier, client_id, client_secret, client_assertion, client_assertion_type options(shinyOAuth.unblock_token_headers = c(\"authorization\")) – allows overriding specified token exchange headers (case-insensitive). Default blocked: Authorization, Cookie","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"async-timeout-mirai","dir":"Articles","previous_headings":"Global options","what":"Async timeout (mirai)","title":"Usage","text":"options(shinyOAuth.async_timeout = 10000) – per-task timeout milliseconds mirai async tasks. using mirai dispatcher (default), timed-tasks automatically cancelled resolve mirai error. Default NULL (timeout). Ignored falling back ‘future’ backend","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"http-settings-timeout-retries-user-agent","dir":"Articles","previous_headings":"Global options","what":"HTTP settings (timeout, retries, user agent)","title":"Usage","text":"options(shinyOAuth.timeout = 5) – default HTTP timeout (seconds) applied outbound requests (discovery, JWKS, token exchange, userinfo). Increase provider/network slow options(shinyOAuth.retry_max_tries = 3L) – maximum attempts transient failures (network errors, 408, 429, 5xx) options(shinyOAuth.retry_backoff_base = 0.5) – base backoff seconds used exponential backoff jitter options(shinyOAuth.retry_backoff_cap = 5) – per‑attempt cap backoff seconds (jitter) options(shinyOAuth.retry_status = c(408L, 429L, 500:599)) – HTTP statuses considered transient retried options(shinyOAuth.user_agent = \"shinyOAuth/<version> R/<version> httr2/<version>\") – override default User‑Agent header applied outbound requests. default string built dynamically installed package/runtime versions; set custom string organization requires specific format options(shinyOAuth.allow_redirect = FALSE) – FALSE (default), sensitive HTTP requests (token exchange, refresh, introspection, revocation, userinfo, OIDC discovery, JWKS) refuse follow redirects reject 3xx responses. prevents authorization codes, tokens, PKCE verifiers leaking redirect targets. set TRUE provider legitimately requires redirect-following","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"developmentdebugging","dir":"Articles","previous_headings":"Global options","what":"Development/debugging","title":"Usage","text":"options(shinyOAuth.skip_browser_token = TRUE) – skip browser cookie binding options(shinyOAuth.skip_id_sig = TRUE) – skip ID token signature verification options(shinyOAuth.debug = TRUE) – re‑raise errors token exchange Don’t enable production. disable key security checks alter error behavior, intended local testing/debugging . Use error_on_softened() startup fail fast softening flags enabled environment .","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"state-envelope","dir":"Articles","previous_headings":"Global options > Size caps","what":"State envelope","title":"Usage","text":"options(shinyOAuth.state_max_token_chars = 8192) – maximum allowed length base64url-encoded state query parameter options(shinyOAuth.state_max_wrapper_bytes = 8192) – maximum decoded byte size outer JSON wrapper (parsing) options(shinyOAuth.state_max_ct_b64_chars = 8192) – maximum allowed length base64url-encoded ciphertext inside wrapper options(shinyOAuth.state_max_ct_bytes = 8192) – maximum decoded byte size ciphertext attempting AES-GCM decrypt prevent maliciously large state parameters causing excessive CPU memory usage decoding decryption.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"callback-query","dir":"Articles","previous_headings":"Global options > Size caps","what":"Callback query","title":"Usage","text":"options(shinyOAuth.callback_max_code_bytes = 4096) – maximum byte length code query parameter options(shinyOAuth.callback_max_state_bytes = 8192) – maximum byte length state query parameter (outer token string) options(shinyOAuth.callback_max_error_bytes = 256) – maximum byte length error query parameter options(shinyOAuth.callback_max_error_description_bytes = 4096) – maximum byte length error_description query parameter options(shinyOAuth.callback_max_query_bytes = <derived>) – maximum total byte length raw callback query string (pre-parse guard) options(shinyOAuth.callback_max_browser_token_bytes = 256) – maximum byte length browser_token argument accepted handle_callback() apply hashing/auditing/state parsing, exist prevent memory/log amplification extremely large callback URLs.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"browser-cookie-preventing-xss","dir":"Articles","previous_headings":"","what":"Browser cookie & preventing XSS","title":"Usage","text":"oauth_module_server() binds browser server session short‑lived cookie must readable client‑side JavaScript bridge values Shiny. cookie ensures browser initiated login one receiving callback. specifically prevents attack attacker tricks user clicking link initiates login attacker’s account, confusing user logging attacker (login confusion). cookie set HttpOnly flag disabled can read JavaScript. necessary bridge cookie value Shiny. However, means app XSS vulnerabilities, attacker read cookie . relatively limited attack vector, still take care prevent XSS vulnerabilities app. important mitigation sanitize user inputs rendering UI (e.g., using htmltools::htmlEscape()).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"multiprocess-deployments-share-state-store-key","dir":"Articles","previous_headings":"","what":"Multi‑process deployments: share state store & key","title":"Usage","text":"run multiple Shiny R processes (e.g., multiple workers, Shiny Server Pro, RStudio Connect, Docker/Kubernetes replicas, non‑sticky load balancer), must ensure : workers share state store (e.g., cachem::cache_disk() pointing shared directory, custom cachem backend; default cachem::cache_mem() per‑process shared) workers share state key (e.g., read environment variable; default, random key generated per client instance shared) authorization code + PKCE flow, ‘shinyOAuth’ creates encrypted “state envelope” stored cache (state_store) echoed back via state query parameter. envelope sealed AES‑GCM using state_key. callback lands different worker one initiated login, worker must able read cached entry decrypt envelope using key. workers different keys, decryption fail login flow abort state error. providing custom state key, please ensure high entropy (minimum 32 characters 32 raw bytes; recommended 64–128 characters) prevent offline guessing attacks encrypted state. use short human‑memorable passphrases.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/articles/usage.html","id":"security-checklist","dir":"Articles","previous_headings":"","what":"Security checklist","title":"Usage","text":"checklist things may want think bringing app production: Use HTTPS everywhere production Verify issuer used provider correct OAuthProvider, set many security options possible; instance, set jwks_host_issuer_match/jwks_host_allow_only (provider uses different host JWKS) OAuthClient request minimum scopes necessary; give app registration permissions needs show $error_description users; never expose tokens UI logs Keep secrets safe environment variables (e.g., OAUTH_CLIENT_ID, OAUTH_CLIENT_SECRET) Sanitize user inputs rendering UI (e.g., using htmltools::htmlEscape()) Make use audit logging (see vignette(\"audit-logging\", package = \"shinyOAuth\")) monitor logs Consider enabling automatic revocation session end (revoke_on_session_end = TRUE) Use provider enforces strong authentication (e.g., multi-factor authentication) Set Content Security Policy (CSP) headers restrict resource loading mitigate XSS attacks; (requires middleware; can’t done Shiny) Log IP addresses accessing app (requires middleware; can’t done Shiny) R package developed care OAuth 2.0/OIDC protocols contain many security features, guarantees can made realm cybersecurity. highly sensitive applications, consider layered (‘defense--depth’) approach security (example, adding IP whitelist additional safeguard).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Luka Koning. Author, maintainer, copyright holder.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Koning L (2026). shinyOAuth: Provider-Agnostic OAuth Authentication 'shiny' Applications. R package version 0.3.0.9000, https://github.com/lukakoning/shinyOAuth.","code":"@Manual{,   title = {shinyOAuth: Provider-Agnostic OAuth Authentication for 'shiny' Applications},   author = {Luka Koning},   year = {2026},   note = {R package version 0.3.0.9000},   url = {https://github.com/lukakoning/shinyOAuth}, }"},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"id_-basic-usage-of-s7-taken-from-the-s7-package-vignettes","dir":"","previous_headings":"","what":"# Basic usage of S7 (taken from the S7 package vignettes)","title":"NA","text":"title: “S7 basics” output: rmarkdown::html_vignette vignette: > % % % — {r, include = FALSE} knitr::opts_chunk$set(   collapse = TRUE,   comment = \"#>\" ) S7 package provides new OOP system designed successor S3 S4. designed implemented collaboratively RConsortium Object-Oriented Programming Working Group, includes representatives R-Core, BioConductor, RStudio/tidyverse, wider R community. vignette gives overview important parts S7: classes objects, generics methods, basics method dispatch inheritance. {r setup} library(S7)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"classes-and-objects","dir":"","previous_headings":"","what":"Classes and objects","title":"NA","text":"S7 classes formal definition create new_class(). two arguments ’ll use almost every class: name class, supplied first argument. class properties, data associated instance class. easiest way define properties supply named list values define valid types property. following code defines simple dog class two properties: character name numeric age. {r} Dog <- new_class(\"Dog\", properties = list(   name = class_character,   age = class_numeric )) Dog S7 provides number built-definitions allow refer existing base types S7 classes. can recognize definitions start class_. Note ’ve assigned return value new_class() object name class. important! object represents class use construct instances class: {r} lola <- Dog(name = \"Lola\", age = 11) lola S7 object, can get set properties using @: {r} lola@age <- 12 lola@age S7 automatically validates type property using type supplied new_class(): {r, error = TRUE} lola@age <- \"twelve\" Given object, can retrieve class S7_class(): {r} S7_class(lola) S7 objects also S3 class(). used compatibility existing S3 generics can learn vignette(\"compatibility\"). {r} class(lola) want learn details S7 classes objects, including validation methods details properties, please see vignette(\"classes-objects\").","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"generics-and-methods","dir":"","previous_headings":"","what":"Generics and methods","title":"NA","text":"S7, like S3 S4, built around idea generic functions, generics short. generic defines interface, uses different implementation depending class one arguments. implementation specific class called method, generic finds appropriate method performing method dispatch. Use new_generic() create S7 generic. simplest form, needs two arguments: name generic (used error messages) name argument used method dispatch: {r} speak <- new_generic(\"speak\", \"x\") Like new_class(), always assign result new_generic() variable name first argument. generic, can register methods specific classes method(generic, class) <- implementation. {r} method(speak, Dog) <- function(x) {   \"Woof\" } method registered, generic use appropriate: {r} speak(lola) Let’s define another class, one cats, define another method speak(): ```{r} Cat <- new_class(“Cat”, properties = list( name = class_character, age = class_double )) method(speak, Cat) <- function(x) { “Meow” } fluffy <- Cat(name = “Fluffy”, age = 5) speak(fluffy)","code":"You get an error if you call the generic with a class that doesn't have a method:  ```{r, error = TRUE} speak(1)"},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"method-dispatch-and-inheritance","dir":"","previous_headings":"","what":"Method dispatch and inheritance","title":"NA","text":"cat dog classes share properties, use common parent class extract duplicated specification. first define parent class: {r} Pet <- new_class(\"Pet\",   properties = list(     name = class_character,     age = class_numeric   ) ) use parent argument new_class: ```{r} Cat <- new_class(“Cat”, parent = Pet) Dog <- new_class(“Dog”, parent = Pet) Cat Dog Method dispatch takes advantage hierarchy parent classes: method defined class, try method parent class, finds method gives error. inheritance powerful mechanism sharing code across classes. ```{r} describe <- new_generic(“describe”, “x”) method(describe, Pet) <- function(x) { paste0(x@name, ” “, x@age,” years old”) } describe(lola) describe(fluffy) method(describe, Dog) <- function(x) { paste0(x@name, ” “, x@age,” year old dog”) } describe(lola) describe(fluffy) Printing generic show methods currently defined: {r} describe can use method() retrieve implementation one methods: {r} method(describe, Pet)","code":"Because we have created new classes, we need to recreate the existing `lola` and `fluffy` objects:  ```{r} lola <- Dog(name = \"Lola\", age = 11) fluffy <- Cat(name = \"Fluffy\", age = 5) You can define a fallback method for any S7 object by registering a method for `S7_object`:  ```{r} method(describe, S7_object) <- function(x) {   \"An S7 object\" }  Cocktail <- new_class(\"Cocktail\",   properties = list(     ingredients = class_character   ) ) martini <- Cocktail(ingredients = c(\"gin\", \"vermouth\")) describe(martini)"},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"id_-using-s7-in-a-package-taken-from-the-s7-package-vignettes","dir":"","previous_headings":"","what":"# Using S7 in a package (taken from the S7 package vignettes)","title":"NA","text":"title: “Using S7 package” output: rmarkdown::html_vignette vignette: > % % % — {r, include = FALSE} knitr::opts_chunk$set(   collapse = TRUE,   comment = \"#>\" ) vignette outlines important things need know using S7 package. S7 new, people used package yet; means vignette likely incomplete, ’d love help make better. Please let us know questions vignette doesn’t answer. {r setup} library(S7)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"method-registration","dir":"","previous_headings":"","what":"Method registration","title":"NA","text":"always call methods_register() .onLoad(): {r} .onLoad <- function(...) {   S7::methods_register() } S7’s way registering methods, rather using export directives NAMESPACE like S3 S4 . strictly necessary registering methods generics packages, ’s harm adding ensures won’t forget later. (’re importing S7 namespace quiet R CMD check NOTE.)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"documentation-and-exports","dir":"","previous_headings":"","what":"Documentation and exports","title":"NA","text":"want users create instances class, need export class constructor. means also need document , since constructor function, means document arguments properties class (unless customised constructor). export class, must also set package argument, ensuring classes name disambiguated across packages. document generics like regular functions (since !). expect others create methods generic, may want include section describing properties expect methods . plan provide easy way document methods generic, yet implemented . can track progress https://github.com/RConsortium/S7/issues/167. don’t currently recommendations documenting methods. ’s need document order pass R CMD check, obviously cases ’s nice provide additional details method, particularly takes extra arguments compared generic. ’re tracking issue https://github.com/RConsortium/S7/issues/315.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilit-instructions-S7.html","id":"backward-compatibility","dir":"","previous_headings":"","what":"Backward compatibility","title":"NA","text":"using S7 package want package work versions R 4.3.0, need know versions R @ works S4 objects. two workarounds. easiest least convenient workaround just prop() instead @. Otherwise, can conditionally make S7-aware @ available package custom NAMESPACE directive: @ work users package S7 automatically attaches environment containing needed definition ’s loaded.","code":"# enable usage of <S7_object>@name in package code #' @rawNamespace if (getRversion() < \"4.3.0\") importFrom(\"S7\", \"@\") NULL"},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/copilot-instructions.html","id":"project-snapshot","dir":"","previous_headings":"","what":"Project Snapshot","title":"AI Coding Guide","text":"shinyOAuth S7-based OAuth/OIDC toolkit Shiny; top-level flow lives R/oauth_module_server.R supporting UI glue R/use_shinyOAuth.R. Core domain objects S7 classes R/classes__OAuthProvider.R, R/classes__OAuthClient.R, R/classes__OAuthToken.R; prefer helper constructors (oauth_provider_*(), oauth_client()) manual new_class calls. S7 modern OOP system R; follow existing patterns generics, methods, validation extending adding classes. See https://rconsortium.github.io/S7/ documentation.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilot-instructions.html","id":"core-code-paths","dir":"","previous_headings":"","what":"Core Code Paths","title":"AI Coding Guide","text":"oauth_module_server() orchestrates redirect→callback→token→refresh, exposing reactiveValues API (request_login(), logout(), build_auth_url()) watchdogs missing JS/browser tokens. Token exchange, refresh, userinfo logic live R/methods__login.R, R/methods__token.R, R/methods__userinfo.R; rely swap_code_for_token_set() expect httr2 requests pass add_req_defaults() req_with_retry(). UI resources ship via inst/www/shinyOAuth.js must loaded per app via use_shinyOAuth(); watchdog warning fires oauth_module_server() runs helper sets flag.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilot-instructions.html","id":"security--state","dir":"","previous_headings":"","what":"Security & State","title":"AI Coding Guide","text":"OAuthClient instances seal state payloads AES-GCM using client@state_key single-use cache entries (state_store_get_remove()); share key cache across workers production deployments. Host validation centralized is_ok_host() enforced OAuthProvider validators; always pipe new endpoints helpers avoid bypassing checks. Provider objects gate PKCE/nonce/id-token policies token_type enforcement; align new provider helpers existing defaults R/providers.R (e.g., allowed_algs, allowed_token_types).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilot-instructions.html","id":"http--external-providers","dir":"","previous_headings":"","what":"HTTP & External Providers","title":"AI Coding Guide","text":"Every outbound call wrap httr2::request() add_req_defaults() timeout/UA req_with_retry() transient handling; tune via options(shinyOAuth.timeout, shinyOAuth.retry_*). oauth_provider_oidc_discover() intersects discovery metadata caller allowed_algs infers token_auth_style; surface configuration failures err_config()/err_http() retain trace ids. Built-providers (oauth_provider_github/google/microsoft/...) illustrate extra_token_headers, JWKS pinning, fingerprinting; mirror structure adding providers tests can stub with_mocked_bindings().","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilot-instructions.html","id":"shiny-integration","dir":"","previous_headings":"","what":"Shiny Integration","title":"AI Coding Guide","text":"Module cookies bind browser sessions using Web Crypto; tests headless contexts can skip requirement options(shinyOAuth.skip_browser_token = TRUE) stubbing values via helper functions. Async flows require promises, future, later; configure plan (e.g., future::plan(multisession)) enabling async = TRUE tests degrade synchronous warnings. Tab title cleanup, cookie scope, proactive refresh configurable arguments oauth_module_server(); document new parameters roxygen comments guard stopifnot validations.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilot-instructions.html","id":"auditing--diagnostics","dir":"","previous_headings":"","what":"Auditing & Diagnostics","title":"AI Coding Guide","text":"audit_event()/emit_trace_event() R/errors.R send redacted telemetry options(shinyOAuth.trace_hook) options(shinyOAuth.audit_hook); preserve hashed identifiers via string_digest() logging new fields. error paths raise via err_abort wrappers (err_token(), err_invalid_state(), err_userinfo(), etc.) trace ids structured context propagate Shiny logs audit hooks. Options like shinyOAuth.print_errors shinyOAuth.print_traceback let operators tune verbosity; respect flags instead printing directly.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilot-instructions.html","id":"error-handling","dir":"","previous_headings":"","what":"Error Handling","title":"AI Coding Guide","text":"Throw failures typed helpers R/errors.R (err_abort() plus err_token()/err_invalid_state()/err_http(), etc.); wrap rlang::abort package-specific classes inject trace ids, avoid base stop(). recoverable notices use rlang::warn()/inform() cli-style bullet vectors frequency guards (see warn_about_missing_js_dependency() client_state_store_max_age()) instead message()/warning(); surface structured context via context = list(). Prefer adding new err_* warn_* helpers next existing ones tests can assert condition classes message formats. Default rlang/cli idioms developer messaging: use cli::cli_warn()/cli_inform() rlang::warn()/inform() cli bullets, avoid cat()/print()/message() unless tests explicitly stub paths.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilot-instructions.html","id":"testing-workflow","dir":"","previous_headings":"","what":"Testing Workflow","title":"AI Coding Guide","text":"Run tests: Rscript -e \"testthat::test_local()\" repo root. Tests extensively mock network calls testthat::with_mocked_bindings() spin webfakes servers HTTP integration tests; keep new HTTP helpers injectable return httr2 responses mocks remain simple. Use existing test helpers tests/testthat/helper-login.R: make_test_client(), make_test_provider(), valid_browser_token() instead reimplementing fixtures. Async module tests reset future::plan(future::sequential) poll later::run_now(); ensure state-store logic exposes get/set/remove/missing signatures duck-typing checks OAuthClient/OAuthProvider validators pass. Integration tests (Docker-based Keycloak, GCP) live integration/; separate unit tests run via CI workflows.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilot-instructions.html","id":"documentation--examples","dir":"","previous_headings":"","what":"Documentation & Examples","title":"AI Coding Guide","text":"Roxygen comments R/ generate man/ via Rscript -e \"devtools::document()\"; never hand-edit .Rd files. Example Shiny integrations live inst/examples/ long-form guidance vignettes/*.Rmd; update alongside API changes pkgdown docs stay accurate. .onLoad() already registers S7 methods (R/zzz.R); adding generics ensure S7::methods_register() triggered namespace imports remain consistent.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilot-instructions.html","id":"backwards-compatibility","dir":"","previous_headings":"","what":"Backwards Compatibility","title":"AI Coding Guide","text":"Pre-release stage: previous release maintain backwards compatibility . Breaking changes acceptable; leave leftover compatibility shims. think backwards compatibility code needed, discuss first.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/copilot-instructions.html","id":"global-options","dir":"","previous_headings":"","what":"Global Options","title":"AI Coding Guide","text":"add new global options unless specifically requested. options must documented ‘usage’ vignette.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"shinyoauth","dir":"","previous_headings":"","what":"Provider-Agnostic OAuth Authentication for shiny Applications","title":"Provider-Agnostic OAuth Authentication for shiny Applications","text":"‘shinyOAuth’ R package implementing provider‑agnostic OAuth 2.0 OpenID Connect (OIDC) authorization authentication Shiny apps. built modern S7 classes security mind. OAuth 2.0/OIDC lets users sign app using accounts already (e.g., Google, Microsoft, GitHub, many ), via self-hosted identity provider (e.g., Keycloak), via identity---service provider (e.g., Auth0, Okta). achieve , app redirects unauthenticated users identity provider, authenticate , redirected back app authorization code. app exchanges code tokens prove user’s identity, optionally allow app call provider’s APIs user’s behalf (e.g., fetch data associated user’s account). package streamlines flow Shiny applications, enabling developers add OAuth 2.0/OIDC authorization/authentication apps minimal code. provided Shiny module handles redirecting unauthenticated users, managing state/PKCE/nonce secure code-token exchange, verifying OIDC tokens, automatically fetching user info performing token refresh, using asynchronous execution, . package highly configurable works various OAuth 2.0/OIDC providers protocol features.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Provider-Agnostic OAuth Authentication for shiny Applications","text":"Shiny module: oauth_module_server() gives ready‑‑use OAuth 2.0/OIDC authentication flow secure defaults. Easily read authentication status, token details, & user info reactive values Shiny server logic S7 classes: OAuthProvider, OAuthClient, OAuthToken, structured representation key elements OAuth 2.0/OIDC flow Functions: prepare_call(), handle_callback(), introspect_token(), refresh_token(), , wish manually implement parts OAuth 2.0/OIDC flow Provider helpers: can configure OAuth 2.0/OIDC providers, package also includes oauth_provider_oidc_discover() function quick OIDC setup, contains built-configurations popular providers (e.g., GitHub, Google, Microsoft, Keycloak, Auth0). Security best practices: AES-GCM–sealed state payloads (AEAD), server-side state validation coupled local cookie verification, HTTPS enforcement, PKCE (S256), ID token signature/claims validation (including nonce), userinfo subject match, (see vignette(\"authentication-flow\", package = \"shinyOAuth\") (link) details) Provides hooks auditing & logging key events, like login successes failures (see vignette(\"audit-logging\", package = \"shinyOAuth\") (link) details)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Provider-Agnostic OAuth Authentication for shiny Applications","text":"Install CRAN: Install development version GitHub:","code":"install.packages(\"shinyOAuth\") if (!requireNamespace(\"remotes\", quietly = TRUE)) {   install.packages(\"remotes\") }  remotes::install_github(\"lukakoning/shinyOAuth\")"},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Provider-Agnostic OAuth Authentication for shiny Applications","text":"complete usage documentation (.e., making manual login button, making authenticated API calls, setting various options, security checklist) see: vignette(\"usage\", package = \"shinyOAuth\") (link).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"minimal-example","dir":"","previous_headings":"Usage","what":"Minimal example","title":"Provider-Agnostic OAuth Authentication for shiny Applications","text":"minimal example using GitHub OAuth 2.0 app. want try example , can register app GitHub Developer Settings.","code":"library(shiny) library(shinyOAuth)  # GitHub OAuth 2.0 provider has been preconfigured in the package #  - You can quickly configure OIDC providers with `oauth_provider_oidc_discover()` #  - You can manually configure every other provider with `oauth_provider()` provider <- oauth_provider_github()  # Build client using your app's ID, secret, & redirect URI: client <- oauth_client(   provider = provider,   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\",   scopes = c(\"read:user\", \"user:email\") )  # Simple UI ui <- fluidPage(   # Include JavaScript dependency:   use_shinyOAuth(),   # Show login information:   uiOutput(\"login_information\") )  # Server which obtains authentication  server <- function(input, output, session) {   # Start authentication module; will automatically redirect unauthenticated users   #   to the provider's login page and handle the callback   # Returns reactive values with authentication status, token details, user info,   #   etc.   auth <- oauth_module_server(\"auth\", client)    # Render login information:   output$login_information <- renderUI({     if (auth$authenticated) {       user_info <- auth$token@userinfo       tagList(         tags$p(\"You are logged in! Your details:\"),         tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))       )     } else {       tags$p(\"You are not logged in.\")     }   }) }  runApp(   shinyApp(ui, server), port = 8100,    launch.browser = FALSE )  # Open the app in your regular browser at http://127.0.0.1:8100 # (viewers in RStudio/Positron/etc. cannot perform necessary redirects)"},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"loggingauditing","dir":"","previous_headings":"Usage","what":"Logging/auditing","title":"Provider-Agnostic OAuth Authentication for shiny Applications","text":"package provides hooks logging/auditing crucial events (e.g., callbacks issued & received, login success/failures). See vignette(\"audit-logging\", package = \"shinyOAuth\") (link) details.","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"what-happens-during-the-authentication-flow","dir":"","previous_headings":"More information","what":"What happens during the authentication flow?","title":"Provider-Agnostic OAuth Authentication for shiny Applications","text":"-depth step--step explanation happens authentication flow, see: vignette(\"authentication-flow\", package = \"shinyOAuth\") (link).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"what-do-i-need-to-consider-for-production-use","dir":"","previous_headings":"More information","what":"What do I need to consider for production use?","title":"Provider-Agnostic OAuth Authentication for shiny Applications","text":"checklist security considerations best practices production use, see: vignette(\"usage\", package = \"shinyOAuth\") (link).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/index.html","id":"for-developers-tests--integration-tests","dir":"","previous_headings":"More information","what":"For developers: tests & integration tests","title":"Provider-Agnostic OAuth Authentication for shiny Applications","text":"package standard ‘testthat’ test suite tests/testthat/. additional set integration tests local Keycloak instance (Docker/Podman) provided integration/keycloak/. integration tests also include browser-driven end--end tests using ‘shinytest2’ ‘chromote’. Finally, minimal demo app deployment provided integration/gcp/ Google Cloud Run using GitHub OAuth 2.0 app.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthClient.html","id":null,"dir":"Reference","previous_headings":"","what":"OAuthClient S7 class — OAuthClient","title":"OAuthClient S7 class — OAuthClient","text":"S7 class representing OAuth 2.0 client configuration, including provider, client credentials, redirect URI, requested scopes, state management. low-level constructor intended advanced use. users prefer helper constructor oauth_client().","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthClient.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OAuthClient S7 class — OAuthClient","text":"","code":"OAuthClient(   provider = NULL,   client_id = character(0),   client_secret = character(0),   client_private_key = NULL,   client_private_key_kid = NA_character_,   client_assertion_alg = NA_character_,   client_assertion_audience = NA_character_,   redirect_uri = character(0),   scopes = character(0),   state_store = cachem::cache_mem(max_age = 300),   state_payload_max_age = 300,   state_entropy = 64,   state_key = random_urlsafe(n = 128),   scope_validation = \"strict\",   introspect = FALSE,   introspect_elements = character(0) )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthClient.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OAuthClient S7 class — OAuthClient","text":"provider OAuthProvider object client_id OAuth client ID client_secret OAuth client secret. Validation rules: Required (non-empty) provider authenticates client HTTP Basic auth token endpoint (token_auth_style = \"header\", also known client_secret_basic). Optional public PKCE-clients provider configured use_pkce = TRUE uses form-body client authentication token endpoint (token_auth_style = \"body\", also known client_secret_post). case, secret omitted token requests. Note: provider issues HS256 ID tokens id_token_validation enabled, non-empty client_secret required signature validation. client_private_key Optional private key private_key_jwt client authentication token endpoint. Can openssl::key PEM string containing private key. Required provider's token_auth_style = 'private_key_jwt'. Ignored auth styles. client_private_key_kid Optional key identifier (kid) include JWT header private_key_jwt assertions. Useful authorization server uses kid select correct verification key. client_assertion_alg Optional JWT signing algorithm use client assertions. omitted, defaults HS256 client_secret_jwt. private_key_jwt, compatible default selected based private key type/curve (e.g., RS256 RSA, ES256/ES384/ES512 EC P-256/384/521, EdDSA Ed25519/Ed448). explicit value provided incompatible key, validation fails early configuration error. Supported values HS256, HS384, HS512 client_secret_jwt asymmetric algorithms supported jose::jwt_encode_sig (e.g., RS256, PS256, ES256, EdDSA) private keys. client_assertion_audience Optional override aud claim used building JWT client assertions (client_secret_jwt / private_key_jwt). default, shinyOAuth uses exact token endpoint request URL. identity providers require different audience value; set exact value IdP expects. redirect_uri Redirect URI registered provider scopes Vector scopes request state_store State storage backend. Defaults cachem::cache_mem(max_age = 300). Alternative backends include cachem::cache_disk() custom implementation (can create custom_cache(). backend must implement cachem-like methods $get(key, missing), $set(key, value), $remove(key); $info() optional. Trade-offs: cache_mem -memory thus scoped single R process (good default single Shiny process). cache_disk persists disk can shared across multiple R processes (useful multi-process deployments Shiny workers sticky). custom_cache() backend use database external store (e.g., Redis, Memcached). See also vignette(\"usage\", package = \"shinyOAuth\"). client automatically generates, persists (state_store), validates OAuth state parameter (OIDC nonce applicable) authorization code flow state_payload_max_age Positive number seconds. Maximum allowed age decrypted state payload's issued_at timestamp callback validation. value independent freshness backstop replay attacks encrypted state payload. intentionally decoupled state_store TTL (controls long single-use state entry can exist server-side cache, also drives browser cookie max-age oauth_module_server()). Default 300 seconds. state_entropy Integer. length (characters) randomly generated state parameter. Higher values provide entropy better security CSRF attacks. Must 22 128 (align validate_state()'s default minimum targets ~128 bits base64url‑like strings). Default 64, provides approximately 384 bits entropy state_key Optional per-client secret used state sealing key AES-GCM AEAD (authenticated encryption) state payload travels via state query parameter. provides confidentiality integrity (via authentication tag) embedded data used callback verification. omit argument, random value generated via random_urlsafe(128). key distinct OAuth client_secret may used public clients. Type: character string (>= 32 bytes encoded) raw vector (>= 32 bytes). Raw keys enable direct use high-entropy secrets external stores. forms normalized internally cryptographic helpers. Multi-process deployments: app runs multiple R workers behind non-sticky load balancer, must configure shared state_store state_key across workers. Otherwise callbacks land different worker unable decrypt/validate state envelope authentication fail. environments, rely random per-process default: provide explicit, high-entropy key (example via secret store environment variable). Prefer values substantial entropy (e.g., 64–128 base64url characters raw 32+ byte key). Avoid human‑memorable passphrases. See also vignette(\"usage\", package = \"shinyOAuth\"). scope_validation Controls scope discrepancies handled authorization server grants fewer scopes requested. RFC 6749 Section 3.3 permits servers issue tokens reduced scope. \"strict\" (default): Throws error requested scope missing granted scopes. \"warn\": Emits warning continues authentication scopes missing. \"none\": Skips scope validation entirely. introspect TRUE, login flow call provider's token introspection endpoint (RFC 7662) validate access token. login considered complete unless introspection succeeds returns active = TRUE; otherwise login fails authenticated remains FALSE. Default FALSE. Requires provider introspection_url configured. introspect_elements Optional character vector additional requirements enforce introspection response introspect = TRUE. Supported values: \"sub\": require introspected sub match session subject (ID token sub available, else userinfo sub). \"client_id\": require introspected client_id match OAuth client id. \"scope\": validate introspected scope requested scopes (respects client's scope_validation mode). Default character(0). (Note providers may return fields introspection responses.)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthClient.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OAuthClient S7 class — OAuthClient","text":"","code":"if (   # Example requires configured GitHub OAuth 2.0 app   # (go to https://github.com/settings/developers to create one):   nzchar(Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\")) &&     nzchar(Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\")) &&     interactive() ) {   library(shiny)   library(shinyOAuth)    # Define client   client <- oauth_client(     provider = oauth_provider_github(),     client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),     client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),     redirect_uri = \"http://127.0.0.1:8100\"   )    # Choose which app you want to run   app_to_run <- NULL   while (!isTRUE(app_to_run %in% c(1:4))) {     app_to_run <- readline(       prompt = paste0(         \"Which example app do you want to run?\\n\",         \"  1: Auto-redirect login\\n\",         \"  2: Manual login button\\n\",         \"  3: Fetch additional resource with access token\\n\",         \"  4: No app (all will be defined but none run)\\n\",         \"Enter 1, 2, 3, or 4... \"       )     )   }    if (app_to_run %in% c(1:3)) {     cli::cli_alert_info(paste0(       \"Will run example app {app_to_run} on {.url http://127.0.0.1:8100}\\n\",       \"Open this URL in a regular browser (viewers in RStudio/Positron/etc. \",       \"cannot perform necessary redirects)\"     ))   }    # Example app with auto-redirect (1) -----------------------------------------    ui_1 <- fluidPage(     use_shinyOAuth(),     uiOutput(\"login\")   )    server_1 <- function(input, output, session) {     # Auto-redirect (default):     auth <- oauth_module_server(       \"auth\",       client,       auto_redirect = TRUE     )      output$login <- renderUI({       if (auth$authenticated) {         user_info <- auth$token@userinfo         tagList(           tags$p(\"You are logged in!\"),           tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))         )       } else {         tags$p(\"You are not logged in.\")       }     })   }    app_1 <- shinyApp(ui_1, server_1)   if (app_to_run == \"1\") {     runApp(       app_1,       port = 8100,       launch.browser = FALSE     )   }    # Example app with manual login button (2) -----------------------------------    ui_2 <- fluidPage(     use_shinyOAuth(),     actionButton(\"login_btn\", \"Login\"),     uiOutput(\"login\")   )    server_2 <- function(input, output, session) {     auth <- oauth_module_server(       \"auth\",       client,       auto_redirect = FALSE     )      observeEvent(input$login_btn, {       auth$request_login()     })      output$login <- renderUI({       if (auth$authenticated) {         user_info <- auth$token@userinfo         tagList(           tags$p(\"You are logged in!\"),           tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))         )       } else {         tags$p(\"You are not logged in.\")       }     })   }    app_2 <- shinyApp(ui_2, server_2)   if (app_to_run == \"2\") {     runApp(       app_2,       port = 8100,       launch.browser = FALSE     )   }    # Example app requesting additional resource with access token (3) -----------    # Below app shows the authenticated username + their GitHub repositories,   # fetched via GitHub API using the access token obtained during login    ui_3 <- fluidPage(     use_shinyOAuth(),     uiOutput(\"ui\")   )    server_3 <- function(input, output, session) {     auth <- oauth_module_server(       \"auth\",       client,       auto_redirect = TRUE     )      repositories <- reactiveVal(NULL)      observe({       req(auth$authenticated)        # Example additional API request using the access token       # (e.g., fetch user repositories from GitHub)       req <- client_bearer_req(auth$token, \"https://api.github.com/user/repos\")       resp <- httr2::req_perform(req)        if (httr2::resp_is_error(resp)) {         repositories(NULL)       } else {         repos_data <- httr2::resp_body_json(resp, simplifyVector = TRUE)         repositories(repos_data)       }     })      # Render username + their repositories     output$ui <- renderUI({       if (isTRUE(auth$authenticated)) {         user_info <- auth$token@userinfo         repos <- repositories()          return(tagList(           tags$p(paste(\"You are logged in as:\", user_info$login)),           tags$h4(\"Your repositories:\"),           if (!is.null(repos)) {             tags$ul(               Map(                 function(url, name) {                   tags$li(tags$a(href = url, target = \"_blank\", name))                 },                 repos$html_url,                 repos$full_name               )             )           } else {             tags$p(\"Loading repositories...\")           }         ))       }        return(tags$p(\"You are not logged in.\"))     })   }    app_3 <- shinyApp(ui_3, server_3)   if (app_to_run == \"3\") {     runApp(       app_3,       port = 8100,       launch.browser = FALSE     )   } }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthProvider.html","id":null,"dir":"Reference","previous_headings":"","what":"OAuthProvider S7 class — OAuthProvider","title":"OAuthProvider S7 class — OAuthProvider","text":"S7 class representing OAuth 2.0 provider configuration. Includes endpoints, OIDC settings, various security options govern OAuth OIDC flows. low-level constructor intended advanced use. users prefer helper constructors oauth_provider() generic OAuth 2.0 providers oauth_provider_oidc() / oauth_provider_oidc_discover() OpenID Connect providers. helpers enable secure defaults based presence issuer available endpoints.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthProvider.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OAuthProvider S7 class — OAuthProvider","text":"","code":"OAuthProvider(   name = character(0),   auth_url = character(0),   token_url = character(0),   userinfo_url = NA_character_,   introspection_url = NA_character_,   revocation_url = NA_character_,   issuer = NA_character_,   use_nonce = FALSE,   use_pkce = TRUE,   pkce_method = \"S256\",   userinfo_required = FALSE,   userinfo_id_selector = function(userinfo) userinfo$sub,   userinfo_id_token_match = FALSE,   id_token_required = FALSE,   id_token_validation = FALSE,   extra_auth_params = list(),   extra_token_params = list(),   extra_token_headers = character(0),   token_auth_style = \"header\",   jwks_cache = cachem::cache_mem(max_age = 3600),   jwks_pins = character(0),   jwks_pin_mode = \"any\",   jwks_host_issuer_match = FALSE,   jwks_host_allow_only = NA_character_,   allowed_algs = c(\"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\",     \"ES384\", \"ES512\", \"EdDSA\"),   allowed_token_types = \"Bearer\",   leeway = getOption(\"shinyOAuth.leeway\", 30) )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthProvider.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OAuthProvider S7 class — OAuthProvider","text":"name Provider name (e.g., \"github\", \"google\"). Cosmetic ; used logging audit events auth_url Authorization endpoint URL token_url Token endpoint URL userinfo_url User info endpoint URL (optional) introspection_url Token introspection endpoint URL (optional; RFC 7662) revocation_url Token revocation endpoint URL (optional; RFC 7009) issuer OIDC issuer URL (optional; required ID token validation). base URL identifies OpenID Provider (OP). used ID token validation verify iss claim ID token matches expected issuer. also used fetch provider's JSON Web Key Set (JWKS) verifying ID token signatures (typically via OIDC discovery document located /.well-known/openid-configuration relative issuer URL) use_nonce Whether use OIDC nonce. adds nonce parameter authorization request validates nonce claim ID token. recommended OIDC flows mitigate replay attacks use_pkce Whether use PKCE. adds code_challenge parameter authorization request requires code_verifier exchanging authorization code tokens. prevents authorization code interception attacks pkce_method PKCE code challenge method (\"S256\" \"plain\"). \"S256\" recommended. \"plain\" used non-compliant providers support \"S256\" userinfo_required Whether fetch userinfo token exchange. User information stored userinfo field returned OAuthToken object. requires valid userinfo_url set. fetching userinfo fails, token exchange fail. low-level constructor oauth_provider(), explicitly supplied, inferred presence non-empty userinfo_url: userinfo_url provided, userinfo_required defaults TRUE, otherwise defaults FALSE. avoids unexpected validation errors userinfo_url omitted (since optional). userinfo_id_selector function extracts user ID userinfo response.#' take single argument (userinfo list) return user ID string. used userinfo_id_token_match TRUE. Optional otherwise; supplied, features (like subject matching) unavailable. Helper constructors like oauth_provider() oauth_provider_oidc() provide default selector extracts sub field. userinfo_id_token_match Whether verify user ID (\"sub\") ID token matches user ID extracted userinfo response. requires userinfo_required id_token_validation TRUE (thus valid userinfo_url issuer set, plus potentially setting client's scope include \"openid\", ID token returned). Furthermore, provider's userinfo_id_selector must configured extract user ID userinfo response. check helps ensure integrity user information confirming sources agree user's identity. oauth_provider(), explicitly supplied, inferred TRUE userinfo_required id_token_validation TRUE; otherwise defaults FALSE. id_token_required Whether require ID token returned token exchange. ID token returned, token exchange fail. requires provider valid OpenID Connect provider may require setting client's scope include \"openid\". Note: S7 class level, defaults FALSE pure OAuth 2.0 providers can configured without OIDC. Helper constructors like oauth_provider() oauth_provider_oidc() enable issuer supplied OIDC explicitly requested. id_token_validation Whether perform ID token validation token exchange. requires provider valid OpenID Connect provider configured issuer token response include ID token (may require setting client's scope include \"openid\"). Note: S7 class level, defaults FALSE. Helper constructors like oauth_provider() oauth_provider_oidc() turn issuer provided OIDC used. extra_auth_params Extra parameters authorization URL extra_token_params Extra parameters token exchange extra_token_headers Extra headers token exchange requests (named character vector) token_auth_style authenticate exchanging tokens. One : \"header\": HTTP Basic (client_secret_basic) \"body\": Form body (client_secret_post) \"client_secret_jwt\": JWT client assertion signed HMAC using client_secret (RFC 7523) \"private_key_jwt\": JWT client assertion signed asymmetric key (RFC 7523) jwks_cache JWKS cache backend. provided, cachem::cache_mem(max_age = 3600) (1 hour) cache created. May cachem‑compatible backend, including cachem::cache_disk() filesystem cache shared across workers, custom implementation created via custom_cache() (e.g., database/Redis backed). TTL guidance: Choose max_age line identity platform’s JWKS rotation cache‑control cadence. range 15 minutes 2 hours typically sensible; default 1 hour. Shorter TTLs adopt new keys faster cost JWKS traffic; longer TTLs reduce traffic may delay new keys slightly. Signature verification automatically perform one‑time JWKS refresh new kid appears ID token. Cache keys internal, hashed issuer pinning configuration. Cache values lists elements jwks fetched_at (numeric epoch seconds) jwks_pins Optional character vector RFC 7638 JWK thumbprints (base64url) pin . non-empty, fetched JWKS must contain keys whose thumbprints match values depending jwks_pin_mode. Use reduce key substitution risks pre-authorizing expected keys jwks_pin_mode Pinning policy jwks_pins provided. Either \"\" (default; least one key JWKS must match) \"\" (every RSA/EC/OKP public key JWKS must match one configured pins) jwks_host_issuer_match TRUE, enforce discovery jwks_uri host matches issuer host (subdomain). Defaults FALSE class level, helper constructors OIDC (e.g., oauth_provider_oidc() oauth_provider_oidc_discover()) enable default safer config. generic helper oauth_provider() also automatically set TRUE issuer provided either id_token_validation id_token_required TRUE (OIDC-like configuration). Set explicitly FALSE opt . providers legitimately publish JWKS different host (e.g., Google), prefer setting jwks_host_allow_only exact hostname rather disabling check jwks_host_allow_only Optional explicit hostname jwks_uri must match. provided, jwks_uri host must equal value (exact match). can pass either just host (e.g., \"www.googleapis.com\") full URL; host component used. need include port IPv6 literal, pass full URL (e.g., https://[::1]:8443) — port ignored hostname part used matching. Takes precedence jwks_host_issuer_match allowed_algs Optional vector allowed JWT algorithms ID tokens. Use restrict acceptable alg values per-provider basis. Supported asymmetric algorithms include RS256, RS384, RS512, PS256, PS384, PS512, ES256, ES384, ES512, EdDSA (Ed25519/Ed448 via OKP). Symmetric HMAC algorithms HS256, HS384, HS512 also supported require supply client_secret explicitly enable HMAC verification via option options(shinyOAuth.allow_hs = TRUE). Defaults c(\"RS256\",\"RS384\",\"RS512\",\"PS256\",\"PS384\",\"PS512\", \"ES256\",\"ES384\",\"ES512\",\"EdDSA\"), intentionally excludes HS*. include HS* certain client_secret stored strictly server-side never shipped , derivable , browser untrusted environments. Prefer rotating secrets regularly enabling . allowed_token_types Character vector acceptable OAuth token types returned token endpoint (case-insensitive). non-empty, token response MUST include token_type must one allowed values; otherwise flow fails fast shinyOAuth_token_error. empty, check performed token_type may omitted provider. oauth_provider() helper defaults c(\"Bearer\") providers package supports Bearer tokens (.e., client_bearer_req() sends Authorization: Bearer). ensures provider returns non-Bearer token type (e.g., DPoP, MAC), flow fails fast rather misusing token. Set allowed_token_types = character() explicitly opt enforcement. leeway Clock skew leeway (seconds) applied ID token exp/iat/nbf checks state payload issued_at future check. Default 30. Can globally overridden via option shinyOAuth.leeway","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthProvider.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OAuthProvider S7 class — OAuthProvider","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional URL for fetching user info:   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" ) #> Warning: [shinyOAuth] - Configure allowed hosts for production #> ! No host allowlist configured via `options(shinyOAuth.allowed_hosts = #>   c(\".example.com\", \"api.example.com\"))`. #> ℹ Restricting hosts hardens redirect and API endpoint validation. #> ℹ See `?is_ok_host` for policy details and review the 'authentication-flow' #>   vignette #> This warning is displayed once per session.  # Configure a OIDC provider via OIDC discovery # (requires network access) # \\donttest{ # Using Auth0 sample issuer as an example oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://samples.auth0.com\" ) # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Slack via OIDC discovery # (requires network access) # \\donttest{ slack_provider <- oauth_provider_slack() # }    # Keycloak # (requires configured Keycloak realm; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\") } # }  # Auth0 # (requires configured Auth0 domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_auth0(domain = \"your-tenant.auth0.com\") } # }  # Okta # (requires configured Okta domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthToken.html","id":null,"dir":"Reference","previous_headings":"","what":"OAuthToken S7 class — OAuthToken","title":"OAuthToken S7 class — OAuthToken","text":"S7 class representing OAuth tokens (optionally) user information.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthToken.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OAuthToken S7 class — OAuthToken","text":"","code":"OAuthToken(   access_token = character(0),   refresh_token = NA_character_,   id_token = NA_character_,   expires_at = Inf,   userinfo = list() )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthToken.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OAuthToken S7 class — OAuthToken","text":"access_token Access token refresh_token Refresh token (provided provider) id_token ID token (provided provider; OpenID Connect) expires_at Numeric timestamp (seconds since epoch) access token expires. Inf non-expiring tokens userinfo List containing user information fetched provider's userinfo endpoint (fetched)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/OAuthToken.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OAuthToken S7 class — OAuthToken","text":"","code":"# Please note: `get_userinfo()`, `introspect_token()`, and `refresh_token()` # are typically not called by users of this package directly, but are called # internally by `oauth_module_server()`. These functions are exported # nonetheless for advanced use cases. Most users will not need to # call these functions directly  # Example requires a real token from a completed OAuth flow # (code is therefore not run; would error with placeholder values below) if (FALSE) { # \\dontrun{ # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Have a valid OAuthToken object; fake example below # (typically provided by `oauth_module_server()` or `handle_callback()`) token <- handle_callback(client, \"<code>\", \"<payload>\", \"<browser_token>\")  # Get userinfo user_info <- get_userinfo(client, token)  # Introspect token (if supported by provider) introspection <- introspect_token(client, token)  # Refresh token new_token <- refresh_token(client, token, introspect = TRUE) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/client_bearer_req.html","id":null,"dir":"Reference","previous_headings":"","what":"Build an authorized httr2 request with Bearer token — client_bearer_req","title":"Build an authorized httr2 request with Bearer token — client_bearer_req","text":"Convenience helper reduce boilerplate calling downstream APIs. creates httr2::request() given URL, attaches Authorization: Bearer <token> header, applies package's standard HTTP defaults (timeout User-Agent). Accepts either raw access token string OAuthToken object.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/client_bearer_req.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build an authorized httr2 request with Bearer token — client_bearer_req","text":"","code":"client_bearer_req(   token,   url,   method = \"GET\",   headers = NULL,   query = NULL,   follow_redirect = FALSE )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/client_bearer_req.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build an authorized httr2 request with Bearer token — client_bearer_req","text":"token Either OAuthToken object raw access token string. url absolute URL call. method Optional HTTP method (character). Defaults \"GET\". headers Optional named list named character vector extra headers set request. Header names case-insensitive. user-supplied Authorization header ignored ensure Bearer token set function overridden. query Optional named list query parameters append URL. follow_redirect Logical. FALSE (default), HTTP redirects disabled prevent leaking Bearer token unexpected hosts. Set TRUE trust possible redirect targets understand security implications.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/client_bearer_req.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build an authorized httr2 request with Bearer token — client_bearer_req","text":"httr2 request object, ready customized performed httr2::req_perform().","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/client_bearer_req.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build an authorized httr2 request with Bearer token — client_bearer_req","text":"","code":"# Make request using OAuthToken object # (code is not run because it requires a real token from user interaction) if (FALSE) { # \\dontrun{ # Get an OAuthToken # (typically provided as reactive return value by `oauth_module_server()`) token <- OAuthToken()  # Build request request <- client_bearer_req(   token,    \"https://api.example.com/resource\",    query = list(limit = 5) )  # Perform request response <- httr2::req_perform(request) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/custom_cache.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a custom cache backend (cachem-like) — custom_cache","title":"Create a custom cache backend (cachem-like) — custom_cache","text":"Builds minimal cachem-like cache backend object exposes cachem-compatible methods: $get(key, missing), $set(key, value), $remove(key), $info(). Use helper want plug custom state store JWKS cache 'shinyOAuth', cachem::cache_mem() cachem::cache_disk() suitable. may useful specifically deploy Shiny app multi-process environment non-sticky workers. cases, may want use shared external cache (e.g., database, Redis, Memcached). resulting object can used places 'shinyOAuth' accepts cache-like object: OAuthClient@state_store (requires $get, $set, $remove; optional $info) OAuthProvider@jwks_cache (requires $get, $set; optional $remove, $info) $info() method optional, provided returns list max_age (seconds), shinyOAuth align browser cookie max-age oauth_module_server() value.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/custom_cache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a custom cache backend (cachem-like) — custom_cache","text":"","code":"custom_cache(get, set, remove, info = NULL)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/custom_cache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a custom cache backend (cachem-like) — custom_cache","text":"get function(key, missing = NULL) -> value. Required. return stored value, missing argument key present. missing parameter mandatory OAuthClient OAuthProvider validators pass explicitly. set function(key, value) -> invisible(NULL). Required. store value given key remove function(key) -> logical sentinel. Required. state stores, enforces single-use eviction. backend performs atomic \"get--delete\" (e.g., SQL DELETE .. RETURNING), may supply function nothing returns TRUE. (login flow always attempt call $remove() $get() best-effort cleanup.) Recommended contract interoperability strong replay protection: Return TRUE key actually deleted already exist Return FALSE key deleted unknown key deleted return value TRUE, 'shinyOAuth' attempt retrieve value state store check may still present; fails (.e., key present), treat removal succesful. find key, produce error indicating removal succeed. info Function() -> list(max_age = seconds, ...). Optional may provided TTL information $info() used align browser cookie max age oauth_module_server()","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/custom_cache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a custom cache backend (cachem-like) — custom_cache","text":"R6 object exposing cachem-like $get/$set/$remove/$info methods","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/custom_cache.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a custom cache backend (cachem-like) — custom_cache","text":"","code":"mem <- new.env(parent = emptyenv())  my_cache <- custom_cache(   get = function(key, missing = NULL) {     base::get0(key, envir = mem, ifnotfound = missing, inherits = FALSE)   },    set = function(key, value) {     assign(key, value, envir = mem)     invisible(NULL)   },    remove = function(key) {     if (exists(key, envir = mem, inherits = FALSE)) {       rm(list = key, envir = mem)       return(TRUE) # signal successful deletion     }     return(TRUE) # key did not exist   },    info = function() list(max_age = 600) )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/error_on_softened.html","id":null,"dir":"Reference","previous_headings":"","what":"Throw an error if any safety checks have been disabled — error_on_softened","title":"Throw an error if any safety checks have been disabled — error_on_softened","text":"function checks safety checks disabled via options intended local development use . options detected, error thrown prevent accidental use production environments.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/error_on_softened.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Throw an error if any safety checks have been disabled — error_on_softened","text":"","code":"error_on_softened()"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/error_on_softened.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Throw an error if any safety checks have been disabled — error_on_softened","text":"Invisible TRUE safety checks disabled; otherwise, error thrown.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/error_on_softened.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Throw an error if any safety checks have been disabled — error_on_softened","text":"checks following options: shinyOAuth.skip_browser_token: Skips browser cookie presence check shinyOAuth.skip_id_sig: Skips ID token signature verification shinyOAuth.print_errors: Enables printing error messages shinyOAuth.print_traceback: Enables printing tracebacks (opt-; default FALSE) shinyOAuth.expose_error_body: Exposes HTTP response bodies Note: Tracebacks treated \"softened\" behavior shinyOAuth.print_traceback option explicitly set TRUE. default FALSE, even interactive test sessions.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/error_on_softened.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Throw an error if any safety checks have been disabled — error_on_softened","text":"","code":"# Throw an error if any developer-only softening options are enabled # Below call does not error if run with default options: error_on_softened()  # Below call would error (is therefore not run): if (FALSE) { # \\dontrun{ options(shinyOAuth.skip_id_sig = TRUE) error_on_softened() } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/get_userinfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Get user info from OAuth 2.0 provider — get_userinfo","title":"Get user info from OAuth 2.0 provider — get_userinfo","text":"Fetches user information provider's userinfo endpoint using provided access token. Emits audit event redacted details.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/get_userinfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get user info from OAuth 2.0 provider — get_userinfo","text":"","code":"get_userinfo(oauth_client, token)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/get_userinfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get user info from OAuth 2.0 provider — get_userinfo","text":"oauth_client OAuthClient object. client must userinfo_url configured OAuthProvider. token Either OAuthToken object raw access token string.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/get_userinfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get user info from OAuth 2.0 provider — get_userinfo","text":"list containing user information returned provider.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/get_userinfo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get user info from OAuth 2.0 provider — get_userinfo","text":"","code":"# Please note: `get_userinfo()`, `introspect_token()`, and `refresh_token()` # are typically not called by users of this package directly, but are called # internally by `oauth_module_server()`. These functions are exported # nonetheless for advanced use cases. Most users will not need to # call these functions directly  # Example requires a real token from a completed OAuth flow # (code is therefore not run; would error with placeholder values below) if (FALSE) { # \\dontrun{ # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Have a valid OAuthToken object; fake example below # (typically provided by `oauth_module_server()` or `handle_callback()`) token <- handle_callback(client, \"<code>\", \"<payload>\", \"<browser_token>\")  # Get userinfo user_info <- get_userinfo(client, token)  # Introspect token (if supported by provider) introspection <- introspect_token(client, token)  # Refresh token new_token <- refresh_token(client, token, introspect = TRUE) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/handle_callback.html","id":null,"dir":"Reference","previous_headings":"","what":"Handle OAuth 2.0 callback: verify state, swap code for token, verify token — handle_callback","title":"Handle OAuth 2.0 callback: verify state, swap code for token, verify token — handle_callback","text":"Handle OAuth 2.0 callback: verify state, swap code token, verify token","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/handle_callback.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handle OAuth 2.0 callback: verify state, swap code for token, verify token — handle_callback","text":"","code":"handle_callback(   oauth_client,   code,   payload,   browser_token,   decrypted_payload = NULL,   state_store_values = NULL,   shiny_session = NULL )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/handle_callback.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handle OAuth 2.0 callback: verify state, swap code for token, verify token — handle_callback","text":"oauth_client OAuthClient object representing OAuth client configuration. code authorization code received OAuth provider callback. payload encrypted state payload received OAuth provider callback (value generated sent prepare_call()). browser_token Browser token present user's session (managed oauth_module_server() match one used prepare_call()). decrypted_payload Optional pre-decrypted validated payload list (returned state_decrypt_gcm() followed internal validation). Supplying allows callers validate bind state main thread dispatching background worker async flows. state_store_values Optional pre-fetched state store entry (list browser_token, pkce_code_verifier, nonce). supplied, function skip reading/removing oauth_client@state_store use provided values instead. supports async flows prefetch remove single-use state entry main thread avoid cross-process cache visibility issues. shiny_session Optional pre-captured Shiny session context (capture_shiny_session_context()) include audit events. Used calling async workers lack access reactive domain.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/handle_callback.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handle OAuth 2.0 callback: verify state, swap code for token, verify token — handle_callback","text":"OAuthToken` object containing access token, refresh token, expiration time, user information (requested), ID token (applicable). step process fails (e.g., state verification, token exchange, token validation), error thrown indicating failure reason.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/handle_callback.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Handle OAuth 2.0 callback: verify state, swap code for token, verify token — handle_callback","text":"","code":"# Please note: `prepare_call()` & `handle_callback()` are typically # not called by users of this package directly, but are called  # internally by `oauth_module_server()`. These functions are exported # nonetheless for advanced use cases. Most users will not need to # call these functions directly  # Below code shows generic usage of `prepare_call()` and `handle_callback()` # (code is not run because it would require user interaction) if (FALSE) { # \\dontrun{ # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Get authorization URL and and store state in client's state store # `<browser_token>` is a token that identifies the browser session #  and would typically be stored in a browser cookie #  (`oauth_module_server()` handles this typically) authorization_url <- prepare_call(client, \"<browser_token>\")  # Redirect user to authorization URL; retrieve code & payload from query; # read also `<browser_token>` from browser cookie # (`oauth_module_server()` handles this typically) code <- \"...\" payload <- \"...\" browser_token <- \"...\"  # Handle callback, exchanging code for token and validating state # (`oauth_module_server()` handles this typically) token <- handle_callback(client, code, payload, browser_token) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/introspect_token.html","id":null,"dir":"Reference","previous_headings":"","what":"Introspect an OAuth 2.0 token — introspect_token","title":"Introspect an OAuth 2.0 token — introspect_token","text":"Introspects access refresh token using RFC 7662 provider exposes introspection endpoint. Returns list including least supported (logical) active (logical|NA) parsed response () raw. Authentication introspection endpoint mirrors provider's token_auth_style: \"header\" (default): HTTP Basic client_id/client_secret. \"body\": form fields client_id (available) client_secret. \"client_secret_jwt\" / \"private_key_jwt\": signed JWT client assertion generated (RFC 7523) sent via client_assertion_type client_assertion, aud resolved via resolve_client_assertion_audience() (client_assertion_audience overrides honored).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/introspect_token.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Introspect an OAuth 2.0 token — introspect_token","text":"","code":"introspect_token(   oauth_client,   oauth_token,   which = c(\"access\", \"refresh\"),   async = FALSE,   shiny_session = NULL )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/introspect_token.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Introspect an OAuth 2.0 token — introspect_token","text":"oauth_client OAuthClient object oauth_token OAuthToken object introspect token introspect: \"access\" (default) \"refresh\". async Logical, default FALSE. TRUE mirai::mirai package available, operation performed main R session using mirai::mirai() function returns mirai (implements .promise()) resolves result list. Requires mirai daemons configured mirai::daemons(). shiny_session Optional pre-captured Shiny session context (capture_shiny_session_context()) include audit events. Used calling async workers lack access reactive domain.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/introspect_token.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Introspect an OAuth 2.0 token — introspect_token","text":"list fields: supported, active, raw, status","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/introspect_token.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Introspect an OAuth 2.0 token — introspect_token","text":"Best-effort semantics: provider expose introspection endpoint, function returns supported = FALSE, active = NA, status = \"introspection_unsupported\". endpoint responds HTTP error (e.g., 404/500) body parsed include usable active field, function throw. returns supported = TRUE, active = NA, descriptive status (example, \"http_404\", \"invalid_json\", \"missing_active\"). context, NA means \"unknown\" break flows unless code explicitly requires definitive result (.e., isTRUE(result$active)). Providers vary encode RFC 7662 active field (logical, numeric, character variants like \"true\"/\"false\", 1/0). normalized logical TRUE/FALSE possible; otherwise active set NA.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/introspect_token.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Introspect an OAuth 2.0 token — introspect_token","text":"","code":"# Please note: `get_userinfo()`, `introspect_token()`, and `refresh_token()` # are typically not called by users of this package directly, but are called # internally by `oauth_module_server()`. These functions are exported # nonetheless for advanced use cases. Most users will not need to # call these functions directly  # Example requires a real token from a completed OAuth flow # (code is therefore not run; would error with placeholder values below) if (FALSE) { # \\dontrun{ # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Have a valid OAuthToken object; fake example below # (typically provided by `oauth_module_server()` or `handle_callback()`) token <- handle_callback(client, \"<code>\", \"<payload>\", \"<browser_token>\")  # Get userinfo user_info <- get_userinfo(client, token)  # Introspect token (if supported by provider) introspection <- introspect_token(client, token)  # Refresh token new_token <- refresh_token(client, token, introspect = TRUE) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/is_ok_host.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if URL(s) are HTTPS and/or in allowed hosts lists — is_ok_host","title":"Check if URL(s) are HTTPS and/or in allowed hosts lists — is_ok_host","text":"Returns TRUE every input URL either: syntactically valid HTTPS URL, (set) whose host matches allowed_hosts, HTTP URL whose host matches allowed_non_https_hosts (e.g. localhost, 127.0.0.1, ::1), (set) also matches allowed_hosts. input omits scheme (e.g., \"localhost:8080/cb\"), function first attempt validate HTTP (useful loopback development), fails, HTTPS. mirrors helpers normalize inputs convenience still enforcing host scheme policies. allowed_hosts thus allowlist hosts/domains permitted, allowed_non_https_hosts defines hosts allowed use HTTP instead HTTPS. allowed_hosts NULL length 0, hosts allowed (subject scheme rules), HTTPS still required unless host allowed_non_https_hosts. Since allowed_hosts supports globs, value like \"*\" matches host therefore effectively disables endpoint host restrictions. use catch‑pattern truly intend allow host. deployments pin expected domain(s), e.g. c(\".example.com\") specific host name. Wildcards: allowed_hosts allowed_non_https_hosts support globs: * = chars, ? = one char. leading .example.com matches domain subdomain. non-URLs, NAs, empty strings cause FALSE result.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/is_ok_host.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if URL(s) are HTTPS and/or in allowed hosts lists — is_ok_host","text":"","code":"is_ok_host(   url,   allowed_non_https_hosts = getOption(\"shinyOAuth.allowed_non_https_hosts\", default =     c(\"localhost\", \"127.0.0.1\", \"::1\", \"[::1]\")),   allowed_hosts = getOption(\"shinyOAuth.allowed_hosts\", default = NULL) )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/is_ok_host.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if URL(s) are HTTPS and/or in allowed hosts lists — is_ok_host","text":"url Single URL vector URLs (character; length 1 ) allowed_non_https_hosts Character vector hostnames allowed use HTTP instead HTTPS. Defaults localhost equivalents. Supports globs allowed_hosts Optional allowlist hosts/domains; supplied (length > 0), hosts permitted. Supports globs","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/is_ok_host.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if URL(s) are HTTPS and/or in allowed hosts lists — is_ok_host","text":"Logical indicator (TRUE URLs pass checks; FALSE otherwise)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/is_ok_host.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check if URL(s) are HTTPS and/or in allowed hosts lists — is_ok_host","text":"function used internally validate redirect URIs OAuth clients, can used elsewhere test URLs allowed. Internally, always determine default values allowed_non_https_hosts allowed_hosts options shinyOAuth.allowed_non_https_hosts shinyOAuth.allowed_hosts, respectively.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/is_ok_host.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if URL(s) are HTTPS and/or in allowed hosts lists — is_ok_host","text":"","code":"# HTTPS allowed by default is_ok_host(\"https://example.com\") #> [1] TRUE  # HTTP allowed for localhost is_ok_host(\"http://localhost:8100\") #> [1] TRUE  # Restrict to a specific domain (allowlist) is_ok_host(\"https://api.example.com\", allowed_hosts = c(\".example.com\")) #> [1] TRUE  # Caution: a catch-all pattern disables host restrictions # (only scheme rules remain). Avoid unless you truly intend it is_ok_host(\"https://anywhere.example\", allowed_hosts = c(\"*\")) #> [1] TRUE"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_client.html","id":null,"dir":"Reference","previous_headings":"","what":"Create generic OAuthClient — oauth_client","title":"Create generic OAuthClient — oauth_client","text":"Create generic OAuthClient","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_client.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create generic OAuthClient — oauth_client","text":"","code":"oauth_client(   provider,   client_id = Sys.getenv(\"OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"OAUTH_CLIENT_SECRET\"),   redirect_uri,   scopes = character(0),   state_store = cachem::cache_mem(max_age = 300),   state_payload_max_age = 300,   state_entropy = 64,   state_key = random_urlsafe(128),   client_private_key = NULL,   client_private_key_kid = NULL,   client_assertion_alg = NULL,   client_assertion_audience = NULL,   scope_validation = c(\"strict\", \"warn\", \"none\"),   introspect = FALSE,   introspect_elements = character(0) )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_client.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create generic OAuthClient — oauth_client","text":"provider OAuthProvider object client_id OAuth client ID client_secret OAuth client secret. Validation rules: Required (non-empty) provider authenticates client HTTP Basic auth token endpoint (token_auth_style = \"header\", also known client_secret_basic). Optional public PKCE-clients provider configured use_pkce = TRUE uses form-body client authentication token endpoint (token_auth_style = \"body\", also known client_secret_post). case, secret omitted token requests. Note: provider issues HS256 ID tokens id_token_validation enabled, non-empty client_secret required signature validation. redirect_uri Redirect URI registered provider scopes Vector scopes request state_store State storage backend. Defaults cachem::cache_mem(max_age = 300). Alternative backends include cachem::cache_disk() custom implementation (can create custom_cache(). backend must implement cachem-like methods $get(key, missing), $set(key, value), $remove(key); $info() optional. Trade-offs: cache_mem -memory thus scoped single R process (good default single Shiny process). cache_disk persists disk can shared across multiple R processes (useful multi-process deployments Shiny workers sticky). custom_cache() backend use database external store (e.g., Redis, Memcached). See also vignette(\"usage\", package = \"shinyOAuth\"). client automatically generates, persists (state_store), validates OAuth state parameter (OIDC nonce applicable) authorization code flow state_payload_max_age Positive number seconds. Maximum allowed age decrypted state payload's issued_at timestamp callback validation. value independent freshness backstop replay attacks encrypted state payload. intentionally decoupled state_store TTL (controls long single-use state entry can exist server-side cache, also drives browser cookie max-age oauth_module_server()). Default 300 seconds. state_entropy Integer. length (characters) randomly generated state parameter. Higher values provide entropy better security CSRF attacks. Must 22 128 (align validate_state()'s default minimum targets ~128 bits base64url‑like strings). Default 64, provides approximately 384 bits entropy state_key Optional per-client secret used state sealing key AES-GCM AEAD (authenticated encryption) state payload travels via state query parameter. provides confidentiality integrity (via authentication tag) embedded data used callback verification. omit argument, random value generated via random_urlsafe(128). key distinct OAuth client_secret may used public clients. Type: character string (>= 32 bytes encoded) raw vector (>= 32 bytes). Raw keys enable direct use high-entropy secrets external stores. forms normalized internally cryptographic helpers. Multi-process deployments: app runs multiple R workers behind non-sticky load balancer, must configure shared state_store state_key across workers. Otherwise callbacks land different worker unable decrypt/validate state envelope authentication fail. environments, rely random per-process default: provide explicit, high-entropy key (example via secret store environment variable). Prefer values substantial entropy (e.g., 64–128 base64url characters raw 32+ byte key). Avoid human‑memorable passphrases. See also vignette(\"usage\", package = \"shinyOAuth\"). client_private_key Optional private key private_key_jwt client authentication token endpoint. Can openssl::key PEM string containing private key. Required provider's token_auth_style = 'private_key_jwt'. Ignored auth styles. client_private_key_kid Optional key identifier (kid) include JWT header private_key_jwt assertions. Useful authorization server uses kid select correct verification key. client_assertion_alg Optional JWT signing algorithm use client assertions. omitted, defaults HS256 client_secret_jwt. private_key_jwt, compatible default selected based private key type/curve (e.g., RS256 RSA, ES256/ES384/ES512 EC P-256/384/521, EdDSA Ed25519/Ed448). explicit value provided incompatible key, validation fails early configuration error. Supported values HS256, HS384, HS512 client_secret_jwt asymmetric algorithms supported jose::jwt_encode_sig (e.g., RS256, PS256, ES256, EdDSA) private keys. client_assertion_audience Optional override aud claim used building JWT client assertions (client_secret_jwt / private_key_jwt). default, shinyOAuth uses exact token endpoint request URL. identity providers require different audience value; set exact value IdP expects. scope_validation Controls scope discrepancies handled authorization server grants fewer scopes requested. RFC 6749 Section 3.3 permits servers issue tokens reduced scope. \"strict\" (default): Throws error requested scope missing granted scopes. \"warn\": Emits warning continues authentication scopes missing. \"none\": Skips scope validation entirely. introspect TRUE, login flow call provider's token introspection endpoint (RFC 7662) validate access token. login considered complete unless introspection succeeds returns active = TRUE; otherwise login fails authenticated remains FALSE. Default FALSE. Requires provider introspection_url configured. introspect_elements Optional character vector additional requirements enforce introspection response introspect = TRUE. Supported values: \"sub\": require introspected sub match session subject (ID token sub available, else userinfo sub). \"client_id\": require introspected client_id match OAuth client id. \"scope\": validate introspected scope requested scopes (respects client's scope_validation mode). Default character(0). (Note providers may return fields introspection responses.)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_client.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create generic OAuthClient — oauth_client","text":"OAuthClient object","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_client.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create generic OAuthClient — oauth_client","text":"","code":"if (   # Example requires configured GitHub OAuth 2.0 app   # (go to https://github.com/settings/developers to create one):   nzchar(Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\")) &&     nzchar(Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\")) &&     interactive() ) {   library(shiny)   library(shinyOAuth)    # Define client   client <- oauth_client(     provider = oauth_provider_github(),     client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),     client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),     redirect_uri = \"http://127.0.0.1:8100\"   )    # Choose which app you want to run   app_to_run <- NULL   while (!isTRUE(app_to_run %in% c(1:4))) {     app_to_run <- readline(       prompt = paste0(         \"Which example app do you want to run?\\n\",         \"  1: Auto-redirect login\\n\",         \"  2: Manual login button\\n\",         \"  3: Fetch additional resource with access token\\n\",         \"  4: No app (all will be defined but none run)\\n\",         \"Enter 1, 2, 3, or 4... \"       )     )   }    if (app_to_run %in% c(1:3)) {     cli::cli_alert_info(paste0(       \"Will run example app {app_to_run} on {.url http://127.0.0.1:8100}\\n\",       \"Open this URL in a regular browser (viewers in RStudio/Positron/etc. \",       \"cannot perform necessary redirects)\"     ))   }    # Example app with auto-redirect (1) -----------------------------------------    ui_1 <- fluidPage(     use_shinyOAuth(),     uiOutput(\"login\")   )    server_1 <- function(input, output, session) {     # Auto-redirect (default):     auth <- oauth_module_server(       \"auth\",       client,       auto_redirect = TRUE     )      output$login <- renderUI({       if (auth$authenticated) {         user_info <- auth$token@userinfo         tagList(           tags$p(\"You are logged in!\"),           tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))         )       } else {         tags$p(\"You are not logged in.\")       }     })   }    app_1 <- shinyApp(ui_1, server_1)   if (app_to_run == \"1\") {     runApp(       app_1,       port = 8100,       launch.browser = FALSE     )   }    # Example app with manual login button (2) -----------------------------------    ui_2 <- fluidPage(     use_shinyOAuth(),     actionButton(\"login_btn\", \"Login\"),     uiOutput(\"login\")   )    server_2 <- function(input, output, session) {     auth <- oauth_module_server(       \"auth\",       client,       auto_redirect = FALSE     )      observeEvent(input$login_btn, {       auth$request_login()     })      output$login <- renderUI({       if (auth$authenticated) {         user_info <- auth$token@userinfo         tagList(           tags$p(\"You are logged in!\"),           tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))         )       } else {         tags$p(\"You are not logged in.\")       }     })   }    app_2 <- shinyApp(ui_2, server_2)   if (app_to_run == \"2\") {     runApp(       app_2,       port = 8100,       launch.browser = FALSE     )   }    # Example app requesting additional resource with access token (3) -----------    # Below app shows the authenticated username + their GitHub repositories,   # fetched via GitHub API using the access token obtained during login    ui_3 <- fluidPage(     use_shinyOAuth(),     uiOutput(\"ui\")   )    server_3 <- function(input, output, session) {     auth <- oauth_module_server(       \"auth\",       client,       auto_redirect = TRUE     )      repositories <- reactiveVal(NULL)      observe({       req(auth$authenticated)        # Example additional API request using the access token       # (e.g., fetch user repositories from GitHub)       req <- client_bearer_req(auth$token, \"https://api.github.com/user/repos\")       resp <- httr2::req_perform(req)        if (httr2::resp_is_error(resp)) {         repositories(NULL)       } else {         repos_data <- httr2::resp_body_json(resp, simplifyVector = TRUE)         repositories(repos_data)       }     })      # Render username + their repositories     output$ui <- renderUI({       if (isTRUE(auth$authenticated)) {         user_info <- auth$token@userinfo         repos <- repositories()          return(tagList(           tags$p(paste(\"You are logged in as:\", user_info$login)),           tags$h4(\"Your repositories:\"),           if (!is.null(repos)) {             tags$ul(               Map(                 function(url, name) {                   tags$li(tags$a(href = url, target = \"_blank\", name))                 },                 repos$html_url,                 repos$full_name               )             )           } else {             tags$p(\"Loading repositories...\")           }         ))       }        return(tags$p(\"You are not logged in.\"))     })   }    app_3 <- shinyApp(ui_3, server_3)   if (app_to_run == \"3\") {     runApp(       app_3,       port = 8100,       launch.browser = FALSE     )   } }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_module_server.html","id":null,"dir":"Reference","previous_headings":"","what":"OAuth 2.0 & OIDC authentication module for Shiny applications — oauth_module_server","title":"OAuth 2.0 & OIDC authentication module for Shiny applications — oauth_module_server","text":"function implements Shiny module server manages OAuth 2.0/OIDC authentication Shiny applications. handles OAuth 2.0/OIDC flow, including redirecting users authorization endpoint, securely processing callback, exchanging authorization codes tokens, verifying tokens, managing token refresh. also provides options automatic manual login flows, session expiry, proactive token refresh. Note: using module, must include shinyOAuth::use_shinyOAuth() UI definition load necessary JavaScript dependencies.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_module_server.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OAuth 2.0 & OIDC authentication module for Shiny applications — oauth_module_server","text":"","code":"oauth_module_server(   id,   client,   auto_redirect = TRUE,   async = FALSE,   indefinite_session = FALSE,   reauth_after_seconds = NULL,   refresh_proactively = FALSE,   refresh_lead_seconds = 60,   refresh_check_interval = 10000,   revoke_on_session_end = FALSE,   tab_title_cleaning = TRUE,   tab_title_replacement = NULL,   browser_cookie_path = NULL,   browser_cookie_samesite = c(\"Strict\", \"Lax\", \"None\") )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_module_server.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OAuth 2.0 & OIDC authentication module for Shiny applications — oauth_module_server","text":"id Shiny module id client OAuthClient object auto_redirect TRUE (default), unauthenticated sessions immediately initiate OAuth flow redirecting browser authorization endpoint. FALSE, module auto-redirect; instead, returned object exposes helpers triggering login manually (use: $request_login()) async TRUE, performs token exchange refresh background using mirai::mirai package, updates values promise resolves. Requires promises::promises mirai::mirai packages, mirai daemons configured mirai::daemons(). FALSE (default), token exchange refresh performed synchronously (may block Shiny event loop; thus strongly recommended set async = TRUE production apps) indefinite_session TRUE, module automatically clear token due access-token expiry reauth_after_seconds window, trigger automatic reauthentication token expires refresh fails. effectively makes sessions \"indefinite\" module's perspective user logged . Note API calls may still fail provider considers token expired; option affects module's automatic clearing/redirect behavior reauth_after_seconds Optional maximum session age seconds. set, module remove token (thus set authenticated FALSE) many seconds elapsed since authentication started. default NULL (forced re-authentication). value provided, timer reset successful refresh knob opt-counts rolling session age refresh_proactively TRUE, automatically refresh tokens expire (refresh token available). refresh scheduled adaptively executes approximately expires_at - refresh_lead_seconds rather coarse polling loop refresh_lead_seconds Number seconds expiry attempt proactive refresh (default: 60) refresh_check_interval Fallback check interval milliseconds expiry/refresh (default: 10000 ms). expiry known, module uses adaptive scheduling wake exactly needed; interval used safety net expiry unknown/infinite revoke_on_session_end TRUE, automatically revokes provider tokens Shiny session ends (e.g., browser tab closed, session timeout). best-effort operation. Revocation runs asynchronously module configured async = TRUE (otherwise runs synchronously). Requires provider revocation_url configured. Default FALSE. Note session-end revocation may always succeed (e.g., network issues, provider unavailable), combine appropriate token lifetimes provider side. tab_title_cleaning TRUE (default), removes query string suffix browser tab title OAuth callback, titles like \"localhost:8100?code=...&state=...\" become \"localhost:8100\" tab_title_replacement Optional character string explicitly set browser tab title OAuth callback. provided, takes precedence tab_title_cleaning browser_cookie_path Optional cookie Path scope browser token cookie. default (NULL), path fixed \"/\" reliable clearing across route changes. Provide explicit path (e.g., \"/app\") narrow cookie's scope sub-route. Note: path \"/\" page served HTTPS, cookie name uses __Host- prefix (Secure, Path=/) additional hardening; path \"/\", regular cookie name used. apps deployed nested routes OAuth callback may land different route initial page, keeping default (root path) ensures browser token cookie available clearable across app routes. deliberately scope cookie sub-path, make sure relevant routes share prefix. browser_cookie_samesite SameSite value browser-token cookie. One \"Strict\", \"Lax\", \"None\". Defaults \"Strict\" maximum protection cross-site request forgery. Use \"Lax\" deployment requires cookie accompany top-level cross-site navigations (example, reverse-proxy flows), document associated risk. set \"None\", cookie marked SameSite=None; Secure browser, authentication error non-HTTPS origins browsers reject SameSite=None cookies without Secure attribute","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_module_server.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"OAuth 2.0 & OIDC authentication module for Shiny applications — oauth_module_server","text":"reactiveValues object token, error, error_description, authenticated, plus additional fields used module. returned reactiveValues contains following fields: authenticated: logical TRUE error token present valid (matching verifications enabled client provider); FALSE otherwise. token: OAuthToken object, NULL yet authenticated. contains access token, refresh token (), ID token (), userinfo (fetched). See OAuthToken details. Note since OAuthToken S7 object, access fields @, e.g., token@userinfo. error: error code string OAuth flow fails. careful exposing directly users, may contain sensitive information aid attacker. error_description: human-readable error detail available. extra careful exposing directly users, may contain even sensitive information aid attacker. browser_token: internal opaque browser cookie value; used state double-submit protection; NULL yet set pending_callback: internal list(code, state); used defer token exchange browser_token available; NULL otherwise. pending_error: internal list(error, error_description, state); used defer error-response state consumption browser_token available; NULL otherwise. pending_login: internal logical; TRUE login requested must wait browser_token set, FALSE otherwise. auto_redirected: internal logical; TRUE module initiated automatic redirect session avoid duplicate redirects. reauth_triggered: internal logical; TRUE reauthentication attempt initiated (expiry failed refresh), avoid loops. auth_started_at: internal numeric timestamp (Sys.time()) authentication started; NA yet authenticated. Used enforce reauth_after_seconds set. token_stale: logical; TRUE token kept despite refresh failure indefinite_session = TRUE, access token past expiry indefinite_session = TRUE prevents automatic clearing. lets UIs warn users disable actions require fresh token. resets FALSE successful login, refresh, logout. last_login_async_used: internal logical; TRUE last login attempt used async = TRUE, FALSE synchronous. used testing diagnostics. refresh_in_progress: internal logical; TRUE token refresh currently flight (async sync). Used prevent concurrent refresh attempts proactive refresh logic wakes multiple times. also contains following helper functions, mainly useful auto_redirect = FALSE want implement manual login flow (e.g., button): request_login(): initiates login redirecting authorization endpoint, cookie-ensure semantics: browser_token missing, module sets cookie defers redirect browser_token present, redirects. main entry point login auto_redirect = FALSE want trigger login UI logout(): clears current token setting authenticated FALSE, clears browser token cookie. might call user clicks \"logout\" button build_auth_url(): internal; builds returns authorization URL, also storing relevant state client's state_store (validation callback). Note requires browser_token present, throw error called early (verify has_browser_token() first). Typically call directly, use request_login() instead, calls internally. set_browser_token(): internal; injects JS set browser token cookie missing. Normally called automatically first load, can call manually needed. token already present, return immediately without changing (call clear_browser_token() want force reset). Typically call directly, use request_login() instead, calls internally needed. clear_browser_token(): internal; injects JS clear browser token cookie clears browser_token. might call reset cookie suspect stale compromised. Typically call directly. has_browser_token(): internal; returns TRUE browser_token present (non-NULL, non-empty), FALSE otherwise. Typically call directly","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_module_server.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"OAuth 2.0 & OIDC authentication module for Shiny applications — oauth_module_server","text":"Blocking vs. async behavior: async = FALSE (default), network operations like token exchange refresh performed main R thread. Transient errors retried package's internal req_with_retry() helper, currently uses Sys.sleep() backoff. Shiny, Sys.sleep() blocks event loop entire worker process, potentially freezing UI updates sessions worker slow provider responses retry backoff. keep UI responsive: set async = TRUE network calls run background process via mirai::mirai package (configure daemons mirai::daemons(n)), reduce/block retries (see vignette(\"usage\", package = \"shinyOAuth\")). Browser requirements: module relies browser's Web Crypto API generate secure, per-session browser token used state double-submit protection. Specifically, login flow requires window.crypto.getRandomValues available. present (example, old highly locked-browsers), module unable proceed authentication. case client-side error emitted surfaced server shinyOAuth_cookie_error containing message \"webcrypto_unavailable\". Use modern browser (enable Web Crypto) resolve . Browser cookie lifetime: opaque browser token cookie lifetime mirrors client's state_store TTL. Internally, module reads client@state_store$info()$max_age uses value cookie's Max-Age/Expires. cache expose finite max_age, conservative default 5 minutes (300 seconds) used align built-cachem::cache_mem(max_age = 300) default. Separately, state payload issued_at freshness window controlled client's state_payload_max_age (default 300 seconds).","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_module_server.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OAuth 2.0 & OIDC authentication module for Shiny applications — oauth_module_server","text":"","code":"if (   # Example requires configured GitHub OAuth 2.0 app   # (go to https://github.com/settings/developers to create one):   nzchar(Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\")) &&     nzchar(Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\")) &&     interactive() ) {   library(shiny)   library(shinyOAuth)    # Define client   client <- oauth_client(     provider = oauth_provider_github(),     client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),     client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),     redirect_uri = \"http://127.0.0.1:8100\"   )    # Choose which app you want to run   app_to_run <- NULL   while (!isTRUE(app_to_run %in% c(1:4))) {     app_to_run <- readline(       prompt = paste0(         \"Which example app do you want to run?\\n\",         \"  1: Auto-redirect login\\n\",         \"  2: Manual login button\\n\",         \"  3: Fetch additional resource with access token\\n\",         \"  4: No app (all will be defined but none run)\\n\",         \"Enter 1, 2, 3, or 4... \"       )     )   }    if (app_to_run %in% c(1:3)) {     cli::cli_alert_info(paste0(       \"Will run example app {app_to_run} on {.url http://127.0.0.1:8100}\\n\",       \"Open this URL in a regular browser (viewers in RStudio/Positron/etc. \",       \"cannot perform necessary redirects)\"     ))   }    # Example app with auto-redirect (1) -----------------------------------------    ui_1 <- fluidPage(     use_shinyOAuth(),     uiOutput(\"login\")   )    server_1 <- function(input, output, session) {     # Auto-redirect (default):     auth <- oauth_module_server(       \"auth\",       client,       auto_redirect = TRUE     )      output$login <- renderUI({       if (auth$authenticated) {         user_info <- auth$token@userinfo         tagList(           tags$p(\"You are logged in!\"),           tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))         )       } else {         tags$p(\"You are not logged in.\")       }     })   }    app_1 <- shinyApp(ui_1, server_1)   if (app_to_run == \"1\") {     runApp(       app_1,       port = 8100,       launch.browser = FALSE     )   }    # Example app with manual login button (2) -----------------------------------    ui_2 <- fluidPage(     use_shinyOAuth(),     actionButton(\"login_btn\", \"Login\"),     uiOutput(\"login\")   )    server_2 <- function(input, output, session) {     auth <- oauth_module_server(       \"auth\",       client,       auto_redirect = FALSE     )      observeEvent(input$login_btn, {       auth$request_login()     })      output$login <- renderUI({       if (auth$authenticated) {         user_info <- auth$token@userinfo         tagList(           tags$p(\"You are logged in!\"),           tags$pre(paste(capture.output(str(user_info)), collapse = \"\\n\"))         )       } else {         tags$p(\"You are not logged in.\")       }     })   }    app_2 <- shinyApp(ui_2, server_2)   if (app_to_run == \"2\") {     runApp(       app_2,       port = 8100,       launch.browser = FALSE     )   }    # Example app requesting additional resource with access token (3) -----------    # Below app shows the authenticated username + their GitHub repositories,   # fetched via GitHub API using the access token obtained during login    ui_3 <- fluidPage(     use_shinyOAuth(),     uiOutput(\"ui\")   )    server_3 <- function(input, output, session) {     auth <- oauth_module_server(       \"auth\",       client,       auto_redirect = TRUE     )      repositories <- reactiveVal(NULL)      observe({       req(auth$authenticated)        # Example additional API request using the access token       # (e.g., fetch user repositories from GitHub)       req <- client_bearer_req(auth$token, \"https://api.github.com/user/repos\")       resp <- httr2::req_perform(req)        if (httr2::resp_is_error(resp)) {         repositories(NULL)       } else {         repos_data <- httr2::resp_body_json(resp, simplifyVector = TRUE)         repositories(repos_data)       }     })      # Render username + their repositories     output$ui <- renderUI({       if (isTRUE(auth$authenticated)) {         user_info <- auth$token@userinfo         repos <- repositories()          return(tagList(           tags$p(paste(\"You are logged in as:\", user_info$login)),           tags$h4(\"Your repositories:\"),           if (!is.null(repos)) {             tags$ul(               Map(                 function(url, name) {                   tags$li(tags$a(href = url, target = \"_blank\", name))                 },                 repos$html_url,                 repos$full_name               )             )           } else {             tags$p(\"Loading repositories...\")           }         ))       }        return(tags$p(\"You are not logged in.\"))     })   }    app_3 <- shinyApp(ui_3, server_3)   if (app_to_run == \"3\") {     runApp(       app_3,       port = 8100,       launch.browser = FALSE     )   } }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider.html","id":null,"dir":"Reference","previous_headings":"","what":"Create generic OAuthProvider — oauth_provider","title":"Create generic OAuthProvider — oauth_provider","text":"Helper function create OAuthProvider object. function provides sensible defaults infers settings based provided parameters.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create generic OAuthProvider — oauth_provider","text":"","code":"oauth_provider(   name,   auth_url,   token_url,   userinfo_url = NA_character_,   introspection_url = NA_character_,   revocation_url = NA_character_,   issuer = NA_character_,   use_nonce = NULL,   use_pkce = TRUE,   pkce_method = \"S256\",   userinfo_required = NULL,   userinfo_id_token_match = NULL,   userinfo_id_selector = function(userinfo) userinfo$sub,   id_token_required = NULL,   id_token_validation = NULL,   extra_auth_params = list(),   extra_token_params = list(),   extra_token_headers = character(),   token_auth_style = \"header\",   jwks_cache = NULL,   jwks_pins = character(),   jwks_pin_mode = \"any\",   jwks_host_issuer_match = NULL,   jwks_host_allow_only = NULL,   allowed_algs = c(\"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\",     \"ES384\", \"ES512\", \"EdDSA\"),   allowed_token_types = c(\"Bearer\"),   leeway = getOption(\"shinyOAuth.leeway\", 30) )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create generic OAuthProvider — oauth_provider","text":"name Provider name (e.g., \"github\", \"google\"). Cosmetic ; used logging audit events auth_url Authorization endpoint URL token_url Token endpoint URL userinfo_url User info endpoint URL (optional) introspection_url Token introspection endpoint URL (optional; RFC 7662) revocation_url Token revocation endpoint URL (optional; RFC 7009) issuer OIDC issuer URL (optional; required ID token validation). base URL identifies OpenID Provider (OP). used ID token validation verify iss claim ID token matches expected issuer. also used fetch provider's JSON Web Key Set (JWKS) verifying ID token signatures (typically via OIDC discovery document located /.well-known/openid-configuration relative issuer URL) use_nonce Whether use OIDC nonce. adds nonce parameter authorization request validates nonce claim ID token. recommended OIDC flows mitigate replay attacks use_pkce Whether use PKCE. adds code_challenge parameter authorization request requires code_verifier exchanging authorization code tokens. prevents authorization code interception attacks pkce_method PKCE code challenge method (\"S256\" \"plain\"). \"S256\" recommended. \"plain\" used non-compliant providers support \"S256\" userinfo_required Whether fetch userinfo token exchange. User information stored userinfo field returned OAuthToken object. requires valid userinfo_url set. fetching userinfo fails, token exchange fail. low-level constructor oauth_provider(), explicitly supplied, inferred presence non-empty userinfo_url: userinfo_url provided, userinfo_required defaults TRUE, otherwise defaults FALSE. avoids unexpected validation errors userinfo_url omitted (since optional). userinfo_id_token_match Whether verify user ID (\"sub\") ID token matches user ID extracted userinfo response. requires userinfo_required id_token_validation TRUE (thus valid userinfo_url issuer set, plus potentially setting client's scope include \"openid\", ID token returned). Furthermore, provider's userinfo_id_selector must configured extract user ID userinfo response. check helps ensure integrity user information confirming sources agree user's identity. oauth_provider(), explicitly supplied, inferred TRUE userinfo_required id_token_validation TRUE; otherwise defaults FALSE. userinfo_id_selector function extracts user ID userinfo response.#' take single argument (userinfo list) return user ID string. used userinfo_id_token_match TRUE. Optional otherwise; supplied, features (like subject matching) unavailable. Helper constructors like oauth_provider() oauth_provider_oidc() provide default selector extracts sub field. id_token_required Whether require ID token returned token exchange. ID token returned, token exchange fail. requires provider valid OpenID Connect provider may require setting client's scope include \"openid\". Note: S7 class level, defaults FALSE pure OAuth 2.0 providers can configured without OIDC. Helper constructors like oauth_provider() oauth_provider_oidc() enable issuer supplied OIDC explicitly requested. id_token_validation Whether perform ID token validation token exchange. requires provider valid OpenID Connect provider configured issuer token response include ID token (may require setting client's scope include \"openid\"). Note: S7 class level, defaults FALSE. Helper constructors like oauth_provider() oauth_provider_oidc() turn issuer provided OIDC used. extra_auth_params Extra parameters authorization URL extra_token_params Extra parameters token exchange extra_token_headers Extra headers token exchange requests (named character vector) token_auth_style authenticate exchanging tokens. One : \"header\": HTTP Basic (client_secret_basic) \"body\": Form body (client_secret_post) \"client_secret_jwt\": JWT client assertion signed HMAC using client_secret (RFC 7523) \"private_key_jwt\": JWT client assertion signed asymmetric key (RFC 7523) jwks_cache JWKS cache backend. provided, cachem::cache_mem(max_age = 3600) (1 hour) cache created. May cachem‑compatible backend, including cachem::cache_disk() filesystem cache shared across workers, custom implementation created via custom_cache() (e.g., database/Redis backed). TTL guidance: Choose max_age line identity platform’s JWKS rotation cache‑control cadence. range 15 minutes 2 hours typically sensible; default 1 hour. Shorter TTLs adopt new keys faster cost JWKS traffic; longer TTLs reduce traffic may delay new keys slightly. Signature verification automatically perform one‑time JWKS refresh new kid appears ID token. Cache keys internal, hashed issuer pinning configuration. Cache values lists elements jwks fetched_at (numeric epoch seconds) jwks_pins Optional character vector RFC 7638 JWK thumbprints (base64url) pin . non-empty, fetched JWKS must contain keys whose thumbprints match values depending jwks_pin_mode. Use reduce key substitution risks pre-authorizing expected keys jwks_pin_mode Pinning policy jwks_pins provided. Either \"\" (default; least one key JWKS must match) \"\" (every RSA/EC/OKP public key JWKS must match one configured pins) jwks_host_issuer_match TRUE, enforce discovery jwks_uri host matches issuer host (subdomain). Defaults FALSE class level, helper constructors OIDC (e.g., oauth_provider_oidc() oauth_provider_oidc_discover()) enable default safer config. generic helper oauth_provider() also automatically set TRUE issuer provided either id_token_validation id_token_required TRUE (OIDC-like configuration). Set explicitly FALSE opt . providers legitimately publish JWKS different host (e.g., Google), prefer setting jwks_host_allow_only exact hostname rather disabling check jwks_host_allow_only Optional explicit hostname jwks_uri must match. provided, jwks_uri host must equal value (exact match). can pass either just host (e.g., \"www.googleapis.com\") full URL; host component used. need include port IPv6 literal, pass full URL (e.g., https://[::1]:8443) — port ignored hostname part used matching. Takes precedence jwks_host_issuer_match allowed_algs Optional vector allowed JWT algorithms ID tokens. Use restrict acceptable alg values per-provider basis. Supported asymmetric algorithms include RS256, RS384, RS512, PS256, PS384, PS512, ES256, ES384, ES512, EdDSA (Ed25519/Ed448 via OKP). Symmetric HMAC algorithms HS256, HS384, HS512 also supported require supply client_secret explicitly enable HMAC verification via option options(shinyOAuth.allow_hs = TRUE). Defaults c(\"RS256\",\"RS384\",\"RS512\",\"PS256\",\"PS384\",\"PS512\", \"ES256\",\"ES384\",\"ES512\",\"EdDSA\"), intentionally excludes HS*. include HS* certain client_secret stored strictly server-side never shipped , derivable , browser untrusted environments. Prefer rotating secrets regularly enabling . allowed_token_types Character vector acceptable OAuth token types returned token endpoint (case-insensitive). non-empty, token response MUST include token_type must one allowed values; otherwise flow fails fast shinyOAuth_token_error. empty, check performed token_type may omitted provider. oauth_provider() helper defaults c(\"Bearer\") providers package supports Bearer tokens (.e., client_bearer_req() sends Authorization: Bearer). ensures provider returns non-Bearer token type (e.g., DPoP, MAC), flow fails fast rather misusing token. Set allowed_token_types = character() explicitly opt enforcement. leeway Clock skew leeway (seconds) applied ID token exp/iat/nbf checks state payload issued_at future check. Default 30. Can globally overridden via option shinyOAuth.leeway","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create generic OAuthProvider — oauth_provider","text":"OAuthProvider object","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create generic OAuthProvider — oauth_provider","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional URL for fetching user info:   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure a OIDC provider via OIDC discovery # (requires network access) # \\donttest{ # Using Auth0 sample issuer as an example oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://samples.auth0.com\" ) # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Slack via OIDC discovery # (requires network access) # \\donttest{ slack_provider <- oauth_provider_slack() # }    # Keycloak # (requires configured Keycloak realm; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\") } # }  # Auth0 # (requires configured Auth0 domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_auth0(domain = \"your-tenant.auth0.com\") } # }  # Okta # (requires configured Okta domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_auth0.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an Auth0 OAuthProvider (via OIDC discovery) — oauth_provider_auth0","title":"Create an Auth0 OAuthProvider (via OIDC discovery) — oauth_provider_auth0","text":"Create Auth0 OAuthProvider (via OIDC discovery)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_auth0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an Auth0 OAuthProvider (via OIDC discovery) — oauth_provider_auth0","text":"","code":"oauth_provider_auth0(domain, name = \"auth0\", audience = NULL)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_auth0.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an Auth0 OAuthProvider (via OIDC discovery) — oauth_provider_auth0","text":"domain Auth0 domain, e.g., \"-domain.auth0.com\" name Optional provider name (default \"auth0\") audience Optional audience request auth flows","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_auth0.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an Auth0 OAuthProvider (via OIDC discovery) — oauth_provider_auth0","text":"OAuthProvider object configured specified Auth0 domain","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_auth0.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an Auth0 OAuthProvider (via OIDC discovery) — oauth_provider_auth0","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional URL for fetching user info:   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure a OIDC provider via OIDC discovery # (requires network access) # \\donttest{ # Using Auth0 sample issuer as an example oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://samples.auth0.com\" ) # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Slack via OIDC discovery # (requires network access) # \\donttest{ slack_provider <- oauth_provider_slack() # }    # Keycloak # (requires configured Keycloak realm; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\") } # }  # Auth0 # (requires configured Auth0 domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_auth0(domain = \"your-tenant.auth0.com\") } # }  # Okta # (requires configured Okta domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_github.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a GitHub OAuthProvider — oauth_provider_github","title":"Create a GitHub OAuthProvider — oauth_provider_github","text":"Pre-configured OAuth 2.0 provider GitHub.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_github.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a GitHub OAuthProvider — oauth_provider_github","text":"","code":"oauth_provider_github(name = \"github\")"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_github.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a GitHub OAuthProvider — oauth_provider_github","text":"name Optional provider name (default \"github\")","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_github.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a GitHub OAuthProvider — oauth_provider_github","text":"OAuthProvider object use GitHub OAuth 2.0 app","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_github.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a GitHub OAuthProvider — oauth_provider_github","text":"can register new GitHub OAuth 2.0 app 'Developer Settings'.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_github.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a GitHub OAuthProvider — oauth_provider_github","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional URL for fetching user info:   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure a OIDC provider via OIDC discovery # (requires network access) # \\donttest{ # Using Auth0 sample issuer as an example oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://samples.auth0.com\" ) # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Slack via OIDC discovery # (requires network access) # \\donttest{ slack_provider <- oauth_provider_slack() # }    # Keycloak # (requires configured Keycloak realm; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\") } # }  # Auth0 # (requires configured Auth0 domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_auth0(domain = \"your-tenant.auth0.com\") } # }  # Okta # (requires configured Okta domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_google.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Google OAuthProvider — oauth_provider_google","title":"Create a Google OAuthProvider — oauth_provider_google","text":"Pre-configured OAuthProvider Google.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_google.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Google OAuthProvider — oauth_provider_google","text":"","code":"oauth_provider_google(name = \"google\")"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_google.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Google OAuthProvider — oauth_provider_google","text":"name Optional provider name (default \"google\")","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_google.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Google OAuthProvider — oauth_provider_google","text":"OAuthProvider object use Google OAuth 2.0 app","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_google.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Google OAuthProvider — oauth_provider_google","text":"can register new Google OAuth 2.0 app Google Cloud Console. Configure client ID & secret OAuthClient.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_google.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Google OAuthProvider — oauth_provider_google","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional URL for fetching user info:   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure a OIDC provider via OIDC discovery # (requires network access) # \\donttest{ # Using Auth0 sample issuer as an example oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://samples.auth0.com\" ) # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Slack via OIDC discovery # (requires network access) # \\donttest{ slack_provider <- oauth_provider_slack() # }    # Keycloak # (requires configured Keycloak realm; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\") } # }  # Auth0 # (requires configured Auth0 domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_auth0(domain = \"your-tenant.auth0.com\") } # }  # Okta # (requires configured Okta domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_keycloak.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Keycloak OAuthProvider (via OIDC discovery) — oauth_provider_keycloak","title":"Create a Keycloak OAuthProvider (via OIDC discovery) — oauth_provider_keycloak","text":"Create Keycloak OAuthProvider (via OIDC discovery)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_keycloak.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Keycloak OAuthProvider (via OIDC discovery) — oauth_provider_keycloak","text":"","code":"oauth_provider_keycloak(   base_url,   realm,   name = paste0(\"keycloak-\", realm),   token_auth_style = \"body\" )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_keycloak.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Keycloak OAuthProvider (via OIDC discovery) — oauth_provider_keycloak","text":"base_url Base URL Keycloak server, e.g., \"http://localhost:8080\" realm Keycloak realm name, e.g., \"myrealm\" name Optional provider name. Defaults paste0('keycloak-', realm) token_auth_style Optional override token endpoint authentication method. One \"header\" (client_secret_basic), \"body\" (client_secret_post), \"private_key_jwt\", \"client_secret_jwt\". Defaults \"body\" Keycloak, works confidential clients public PKCE clients (secretless). pass NULL, discovery infer method provider's token_endpoint_auth_methods_supported metadata.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_keycloak.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Keycloak OAuthProvider (via OIDC discovery) — oauth_provider_keycloak","text":"OAuthProvider object configured specified Keycloak realm","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_keycloak.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Keycloak OAuthProvider (via OIDC discovery) — oauth_provider_keycloak","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional URL for fetching user info:   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure a OIDC provider via OIDC discovery # (requires network access) # \\donttest{ # Using Auth0 sample issuer as an example oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://samples.auth0.com\" ) # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Slack via OIDC discovery # (requires network access) # \\donttest{ slack_provider <- oauth_provider_slack() # }    # Keycloak # (requires configured Keycloak realm; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\") } # }  # Auth0 # (requires configured Auth0 domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_auth0(domain = \"your-tenant.auth0.com\") } # }  # Okta # (requires configured Okta domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_microsoft.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Microsoft (Entra ID) OAuthProvider — oauth_provider_microsoft","title":"Create a Microsoft (Entra ID) OAuthProvider — oauth_provider_microsoft","text":"Pre-configured OAuthProvider Microsoft Entra ID (formerly Azure AD) using v2.0 endpoints. Accepts tenant identifier configures authorization, token, userinfo endpoints directly (discovery).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_microsoft.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Microsoft (Entra ID) OAuthProvider — oauth_provider_microsoft","text":"","code":"oauth_provider_microsoft(   name = \"microsoft\",   tenant = c(\"common\", \"organizations\", \"consumers\"),   id_token_validation = NULL )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_microsoft.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Microsoft (Entra ID) OAuthProvider — oauth_provider_microsoft","text":"name Optional friendly name provider. Defaults \"microsoft\" tenant Tenant identifier (\"common\", \"organizations\", \"consumers\", directory GUID). Defaults \"common\" id_token_validation Optional override (logical). NULL (default), enabled automatically tenant looks like GUID, otherwise disabled","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_microsoft.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Microsoft (Entra ID) OAuthProvider — oauth_provider_microsoft","text":"OAuthProvider object configured Microsoft identity platform","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_microsoft.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Microsoft (Entra ID) OAuthProvider — oauth_provider_microsoft","text":"tenant can one special values \"common\", \"organizations\", \"consumers\", specific directory (tenant) ID GUID (e.g., \"00000000-0000-0000-0000-000000000000\"). tenant specific GUID, provider enable strict ID token validation (issuer match). using multi-tenant aliases (\"common\", \"organizations\", \"consumers\"), exact issuer depends account signs therefore ID token validation disabled default avoid false negatives. can override via id_token_validation know environment guarantees fixed issuer. Note: ID token validation requires stable issuer. multi-tenant aliases, provider sets issuer = NA therefore also disables use_nonce default (nonce validation relies validating ID token). Microsoft issues RS256 ID tokens; allowed_algs restricted accordingly. userinfo endpoint provided Microsoft Graph (https://graph.microsoft.com/oidc/userinfo). configuring OAuthClient, option register app simply wish test development, may able use default Azure CLI public app, client_id '9391afd1-7129-4938-9e4d-633c688f93c0' (uses redirect_uri 'http://localhost:8100').","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_microsoft.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Microsoft (Entra ID) OAuthProvider — oauth_provider_microsoft","text":"","code":"if (   # Example requires configured Microsoft Entra ID (Azure AD) tenant:   nzchar(Sys.getenv(\"MS_TENANT\")) && interactive() && requireNamespace(\"later\") ) {   library(shiny)   library(shinyOAuth)    # Configure provider and client (Microsoft Entra ID with your tenant   client <- oauth_client(     provider = oauth_provider_microsoft(       # Provide your own tenant ID here (set as environment variable MS_TENANT)       tenant = Sys.getenv(\"MS_TENANT\")     ),     # Default Azure CLI app ID (public client; activated in many tenants):     client_id = \"04b07795-8ddb-461a-bbee-02f9e1bf7b46\",     redirect_uri = \"http://localhost:8100\",     scopes = c(\"openid\", \"profile\", \"email\")   )    # UI   ui <- fluidPage(     use_shinyOAuth(),     h3(\"OAuth demo (Microsoft Entra ID)\"),     uiOutput(\"oauth_error\"),     tags$hr(),     h4(\"Auth object (summary)\"),     verbatimTextOutput(\"auth_print\"),     tags$hr(),     h4(\"User info\"),     verbatimTextOutput(\"user_info\")   )    # Server   server <- function(input, output, session) {     auth <- oauth_module_server(\"auth\", client)      output$auth_print <- renderText({       authenticated <- auth$authenticated       tok <- auth$token       err <- auth$error        paste0(         \"Authenticated?\",         if (isTRUE(authenticated)) \" YES\" else \" NO\",         \"\\n\",         \"Has token? \",         if (!is.null(tok)) \"YES\" else \"NO\",         \"\\n\",         \"Has error? \",         if (!is.null(err)) \"YES\" else \"NO\",         \"\\n\\n\",         \"Token (str):\\n\",         paste(capture.output(str(tok)), collapse = \"\\n\")       )     })      output$user_info <- renderPrint({       req(auth$token)       auth$token@userinfo     })      output$oauth_error <- renderUI({       if (!is.null(auth$error)) {         msg <- auth$error         if (!is.null(auth$error_description)) {           msg <- paste0(msg, \": \", auth$error_description)         }         div(class = \"alert alert-danger\", role = \"alert\", msg)       }     })   }    # Need to open app in 'localhost:8100' to match with redirect_uri   # of the public Azure CLI app (above). Browser must use 'localhost'   # too to properly set the browser cookie. But Shiny only redirects to   # '127.0.0.1' & blocks process once it runs. So we disable browser   # launch by Shiny & then use 'later::later()' to open the browser   # ourselves a short moment after the app starts   later::later(     function() {       utils::browseURL(\"http://localhost:8100\")     },     delay = 0.25   )    # Run app   runApp(shinyApp(ui, server), port = 8100, launch.browser = FALSE) }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a generic OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc","title":"Create a generic OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc","text":"Preconfigured OAuthProvider OpenID Connect (OIDC) compliant providers.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a generic OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc","text":"","code":"oauth_provider_oidc(   name,   base_url,   auth_path = \"/authorize\",   token_path = \"/token\",   userinfo_path = \"/userinfo\",   introspection_path = \"/introspect\",   use_nonce = TRUE,   id_token_validation = TRUE,   jwks_host_issuer_match = TRUE,   allowed_token_types = c(\"Bearer\"),   ... )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a generic OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc","text":"name Friendly name provider base_url Base URL OIDC endpoints auth_path Authorization endpoint path (default: \"/authorize\") token_path Token endpoint path (default: \"/token\") userinfo_path User info endpoint path (default: \"/userinfo\") introspection_path Token introspection endpoint path (default: \"/introspect\") use_nonce Logical, whether use OIDC nonce. Defaults TRUE id_token_validation Logical, whether validate ID tokens automatically provider. Defaults TRUE jwks_host_issuer_match TRUE (default), enforce JWKS host discovered provider matches issuer host (subdomain). providers serve JWKS different host (e.g., Google), set jwks_host_allow_only exact hostname instead disabling . Disabling (FALSE) recommended unless also pin JWKS via jwks_host_allow_only jwks_pins allowed_token_types Character vector allowed token types access tokens issued provider. Defaults 'Bearer' ... Additional arguments passed oauth_provider()","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a generic OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc","text":"OAuthProvider object","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a generic OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional URL for fetching user info:   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure a OIDC provider via OIDC discovery # (requires network access) # \\donttest{ # Using Auth0 sample issuer as an example oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://samples.auth0.com\" ) # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Slack via OIDC discovery # (requires network access) # \\donttest{ slack_provider <- oauth_provider_slack() # }    # Keycloak # (requires configured Keycloak realm; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\") } # }  # Auth0 # (requires configured Auth0 domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_auth0(domain = \"your-tenant.auth0.com\") } # }  # Okta # (requires configured Okta domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc_discover.html","id":null,"dir":"Reference","previous_headings":"","what":"Discover and create an OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc_discover","title":"Discover and create an OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc_discover","text":"Uses OpenID Connect discovery document /.well-known/openid-configuration auto-configure OAuthProvider. present, introspection_endpoint wired resulting provider RFC 7662 support.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc_discover.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discover and create an OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc_discover","text":"","code":"oauth_provider_oidc_discover(   issuer,   name = NULL,   use_pkce = TRUE,   use_nonce = TRUE,   id_token_validation = TRUE,   token_auth_style = NULL,   allowed_algs = c(\"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\",     \"ES384\", \"ES512\", \"EdDSA\"),   allowed_token_types = c(\"Bearer\"),   jwks_host_issuer_match = TRUE,   issuer_match = c(\"url\", \"host\", \"none\"),   ... )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc_discover.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discover and create an OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc_discover","text":"issuer OIDC issuer base URL (including scheme), e.g., \"https://login.example.com\" name Optional friendly provider name. Defaults issuer hostname use_pkce Logical, whether use PKCE provider. Defaults TRUE. discovery document indicates token_endpoint_auth_methods_supported includes \"none\", PKCE required unless use_pkce explicitly set FALSE (recommended) use_nonce Logical, whether use OIDC nonce. Defaults TRUE id_token_validation Logical, whether validate ID tokens automatically provider. Defaults TRUE token_auth_style Authentication style token requests: \"header\" (client_secret_basic) \"body\" (client_secret_post). NULL (default), inferred conservatively discovery. PKCE enabled provider advertises support public clients via none, secretless flow preferred (modeled \"body\" without credentials). Otherwise, helper prefers \"header\" (client_secret_basic) available, \"body\" (client_secret_post). JWT-based methods auto-selected unless explicitly requested allowed_algs Character vector allowed ID token signing algorithms. Defaults broad set common algorithms, including RSA (RS*), RSA-PSS (PS*), ECDSA (ES*), EdDSA. discovery document advertises supported algorithms, intersection advertised caller-provided algorithms used avoid runtime mismatches. overlap, discovery fails configuration error (fallback) allowed_token_types Character vector allowed token types access tokens issued provider. Defaults 'Bearer' jwks_host_issuer_match TRUE (default), enforce JWKS host discovered provider matches issuer host (subdomain). providers serve JWKS different host, set jwks_host_allow_only exact hostname instead disabling . Disabling (FALSE) recommended unless also pin JWKS via jwks_host_allow_only jwks_pins issuer_match Character scalar controlling strictly validate discovery document's issuer input issuer. \"url\" (default): require full issuer URL match trailing-slash normalization (recommended). \"host\": compare scheme + host (explicit opt-; recommended). \"none\": validate issuer consistency. Prefer \"url\" tighten hosts via options(shinyOAuth.allowed_hosts) feasible. ... Additional fields passed oauth_provider()","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc_discover.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discover and create an OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc_discover","text":"OAuthProvider object configured discovery","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc_discover.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Discover and create an OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc_discover","text":"ID token algorithms: default helper accepts common asymmetric algorithms RSA (RS*), RSA-PSS (PS*), ECDSA (ES*), EdDSA. provider advertises supported ID token signing algorithms via id_token_signing_alg_values_supported, helper uses intersection caller-provided allowed_algs. overlap, discovery fails configuration error. automatic fallback discovery-advertised set. Token endpoint authentication methods: supports client_secret_basic (header), client_secret_post (body), public clients using none (PKCE), well JWT-based methods private_key_jwt client_secret_jwt per RFC 7523. Important: discovery metadata lists methods supported across provider, per-client provisioning. helper automatically select JWT-based methods just advertised. default prefers client_secret_basic (header) available, otherwise client_secret_post (body), uses public none PKCE clients. provider advertises JWT methods, must explicitly set token_auth_style configure corresponding credentials OAuthClient (private key private_key_jwt, sufficiently strong client_secret client_secret_jwt). Host policy: default, discovered endpoints must absolute URLs whose host matches issuer host exactly. Subdomains implicitly allowed. want allow subdomains, add leading-dot glob options(shinyOAuth.allowed_hosts), e.g., .example.com *.example.com. global whitelist supplied via options(shinyOAuth.allowed_hosts), discovery restrict endpoints whitelist. Scheme policy (https/http loopback) delegated is_ok_host(), may allow non-HTTPS hosts options(shinyOAuth.allowed_non_https_hosts) (see ?is_ok_host).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_oidc_discover.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discover and create an OpenID Connect (OIDC) OAuthProvider — oauth_provider_oidc_discover","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional URL for fetching user info:   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure a OIDC provider via OIDC discovery # (requires network access) # \\donttest{ # Using Auth0 sample issuer as an example oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://samples.auth0.com\" ) # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Slack via OIDC discovery # (requires network access) # \\donttest{ slack_provider <- oauth_provider_slack() # }    # Keycloak # (requires configured Keycloak realm; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\") } # }  # Auth0 # (requires configured Auth0 domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_auth0(domain = \"your-tenant.auth0.com\") } # }  # Okta # (requires configured Okta domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_okta.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an Okta OAuthProvider (via OIDC discovery) — oauth_provider_okta","title":"Create an Okta OAuthProvider (via OIDC discovery) — oauth_provider_okta","text":"Create Okta OAuthProvider (via OIDC discovery)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_okta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an Okta OAuthProvider (via OIDC discovery) — oauth_provider_okta","text":"","code":"oauth_provider_okta(domain, auth_server = \"default\", name = \"okta\")"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_okta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an Okta OAuthProvider (via OIDC discovery) — oauth_provider_okta","text":"domain Okta domain, e.g., \"dev-123456.okta.com\" auth_server Authorization server ID (default \"default\") name Optional provider name (default \"okta\")","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_okta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an Okta OAuthProvider (via OIDC discovery) — oauth_provider_okta","text":"OAuthProvider object configured specified Okta domain","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_okta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an Okta OAuthProvider (via OIDC discovery) — oauth_provider_okta","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional URL for fetching user info:   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure a OIDC provider via OIDC discovery # (requires network access) # \\donttest{ # Using Auth0 sample issuer as an example oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://samples.auth0.com\" ) # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Slack via OIDC discovery # (requires network access) # \\donttest{ slack_provider <- oauth_provider_slack() # }    # Keycloak # (requires configured Keycloak realm; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\") } # }  # Auth0 # (requires configured Auth0 domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_auth0(domain = \"your-tenant.auth0.com\") } # }  # Okta # (requires configured Okta domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_slack.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Slack OAuthProvider (via OIDC discovery) — oauth_provider_slack","title":"Create a Slack OAuthProvider (via OIDC discovery) — oauth_provider_slack","text":"Create Slack OAuthProvider (via OIDC discovery)","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_slack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Slack OAuthProvider (via OIDC discovery) — oauth_provider_slack","text":"","code":"oauth_provider_slack(name = \"slack\")"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_slack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Slack OAuthProvider (via OIDC discovery) — oauth_provider_slack","text":"name Optional provider name (default \"slack\")","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_slack.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Slack OAuthProvider (via OIDC discovery) — oauth_provider_slack","text":"OAuthProvider object configured Slack","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_slack.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Slack OAuthProvider (via OIDC discovery) — oauth_provider_slack","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional URL for fetching user info:   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure a OIDC provider via OIDC discovery # (requires network access) # \\donttest{ # Using Auth0 sample issuer as an example oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://samples.auth0.com\" ) # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Slack via OIDC discovery # (requires network access) # \\donttest{ slack_provider <- oauth_provider_slack() # }    # Keycloak # (requires configured Keycloak realm; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\") } # }  # Auth0 # (requires configured Auth0 domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_auth0(domain = \"your-tenant.auth0.com\") } # }  # Okta # (requires configured Okta domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_spotify.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Spotify OAuthProvider — oauth_provider_spotify","title":"Create a Spotify OAuthProvider — oauth_provider_spotify","text":"Pre-configured OAuth 2.0 provider Spotify. Uses /v1/\"userinfo\". ID token (OIDC).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_spotify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Spotify OAuthProvider — oauth_provider_spotify","text":"","code":"oauth_provider_spotify(name = \"spotify\")"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_spotify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Spotify OAuthProvider — oauth_provider_spotify","text":"name Optional provider name (default \"spotify\")","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_spotify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Spotify OAuthProvider — oauth_provider_spotify","text":"OAuthProvider object use Spotify OAuth 2.0 app","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_spotify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Spotify OAuthProvider — oauth_provider_spotify","text":"Spotify requires scopes included authorization request. Set requested scopes client oauth_client(..., scopes = ...).","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/reference/oauth_provider_spotify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Spotify OAuthProvider — oauth_provider_spotify","text":"","code":"# Configure generic OAuth 2.0 provider (no OIDC) generic_provider <- oauth_provider(   name = \"example\",   auth_url = \"https://example.com/oauth/authorize\",   token_url = \"https://example.com/oauth/token\",   # Optional URL for fetching user info:   userinfo_url = \"https://example.com/oauth/userinfo\" )  # Configure generic OIDC provider manually # (This defaults to using nonce & ID token validation) generic_oidc_provider <- oauth_provider_oidc(   name = \"My OIDC\",   base_url = \"https://my-issuer.example.com\" )  # Configure a OIDC provider via OIDC discovery # (requires network access) # \\donttest{ # Using Auth0 sample issuer as an example oidc_discovery_provider <- oauth_provider_oidc_discover(   issuer = \"https://samples.auth0.com\" ) # }  # GitHub preconfigured provider  github_provider <- oauth_provider_github()  # Google preconfigured provider google_provider <- oauth_provider_google()  # Microsoft preconfigured provider # See `?oauth_provider_microsoft` for example using a custom tenant ID  # Spotify preconfigured provider  spotify_provider <- oauth_provider_spotify()  # Slack via OIDC discovery # (requires network access) # \\donttest{ slack_provider <- oauth_provider_slack() # }    # Keycloak # (requires configured Keycloak realm; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_keycloak(base_url = \"http://localhost:8080\", realm = \"myrealm\") } # }  # Auth0 # (requires configured Auth0 domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_auth0(domain = \"your-tenant.auth0.com\") } # }  # Okta # (requires configured Okta domain; example below is therefore not run) if (FALSE) { # \\dontrun{ oauth_provider_okta(domain = \"dev-123456.okta.com\") } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/prepare_call.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare a OAuth 2.0 authorization call and build an authorization URL — prepare_call","title":"Prepare a OAuth 2.0 authorization call and build an authorization URL — prepare_call","text":"function prepares OAuth 2.0 authorization call generating necessary state, PKCE, nonce values, storing securely, constructing authorization URL redirect user . state accompanying values stored client's state store later verification callback phase OAuth 2.0 flow.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/prepare_call.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare a OAuth 2.0 authorization call and build an authorization URL — prepare_call","text":"","code":"prepare_call(oauth_client, browser_token)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/prepare_call.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare a OAuth 2.0 authorization call and build an authorization URL — prepare_call","text":"oauth_client OAuthClient object representing OAuth client configuration. browser_token string token (e.g., browser cookie) identify user/session.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/prepare_call.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare a OAuth 2.0 authorization call and build an authorization URL — prepare_call","text":"string containing constructed authorization URL. URL used redirect user OAuth provider's authorization endpoint.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/prepare_call.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare a OAuth 2.0 authorization call and build an authorization URL — prepare_call","text":"","code":"# Please note: `prepare_call()` & `handle_callback()` are typically # not called by users of this package directly, but are called  # internally by `oauth_module_server()`. These functions are exported # nonetheless for advanced use cases. Most users will not need to # call these functions directly  # Below code shows generic usage of `prepare_call()` and `handle_callback()` # (code is not run because it would require user interaction) if (FALSE) { # \\dontrun{ # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Get authorization URL and and store state in client's state store # `<browser_token>` is a token that identifies the browser session #  and would typically be stored in a browser cookie #  (`oauth_module_server()` handles this typically) authorization_url <- prepare_call(client, \"<browser_token>\")  # Redirect user to authorization URL; retrieve code & payload from query; # read also `<browser_token>` from browser cookie # (`oauth_module_server()` handles this typically) code <- \"...\" payload <- \"...\" browser_token <- \"...\"  # Handle callback, exchanging code for token and validating state # (`oauth_module_server()` handles this typically) token <- handle_callback(client, code, payload, browser_token) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/refresh_token.html","id":null,"dir":"Reference","previous_headings":"","what":"Refresh an OAuth 2.0 token — refresh_token","title":"Refresh an OAuth 2.0 token — refresh_token","text":"Refreshes OAuth session obtaining fresh access token using refresh token. configured, also re-fetches userinfo validates new ID token returned provider. Per OIDC Core Section 12.2, providers may omit ID token refresh responses. omitted, original ID token initial login preserved. provider return new ID token refresh, refresh_token() requires original ID token initial login available can enforce subject continuity (OIDC 12.2: sub MUST match). original ID token available, refresh fails error. id_token_validation = TRUE, refresh-returned ID token also fully validated (signature claims) addition OIDC 12.2 sub continuity check. userinfo_required = TRUE, userinfo re-fetched using fresh access token. new ID token fresh userinfo present userinfo_id_token_match = TRUE, subjects verified match.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/refresh_token.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refresh an OAuth 2.0 token — refresh_token","text":"","code":"refresh_token(   oauth_client,   token,   async = FALSE,   introspect = FALSE,   shiny_session = NULL )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/refresh_token.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refresh an OAuth 2.0 token — refresh_token","text":"oauth_client OAuthClient object token OAuthToken object containing refresh token async Logical, default FALSE. TRUE mirai::mirai package available, refresh performed main R session using mirai::mirai() function returns mirai (implements .promise()) resolves updated OAuthToken. Requires mirai daemons configured mirai::daemons(). introspect Logical, default FALSE. successful refresh, provider exposes introspection endpoint, perform best-effort introspection new access token audit/diagnostics. result stored token object. shiny_session Optional pre-captured Shiny session context (capture_shiny_session_context()) include audit events. Used calling async workers lack access reactive domain.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/refresh_token.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refresh an OAuth 2.0 token — refresh_token","text":"updated OAuthToken object refreshed credentials. changes: access_token: Always updated fresh token expires_at: Computed expires_in provided; otherwise Inf refresh_token: Updated provider rotates ; otherwise preserved id_token: Updated provider returns one (validates); otherwise original login preserved userinfo: Refreshed userinfo_required = TRUE; otherwise preserved Validation failures cause errors: provider returns new ID token fails validation (wrong issuer, audience, expired, subject mismatch original), userinfo subject match new ID token, refresh fails error. oauth_module_server(), clears session sets authenticated = FALSE.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/refresh_token.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Refresh an OAuth 2.0 token — refresh_token","text":"","code":"# Please note: `get_userinfo()`, `introspect_token()`, and `refresh_token()` # are typically not called by users of this package directly, but are called # internally by `oauth_module_server()`. These functions are exported # nonetheless for advanced use cases. Most users will not need to # call these functions directly  # Example requires a real token from a completed OAuth flow # (code is therefore not run; would error with placeholder values below) if (FALSE) { # \\dontrun{ # Define client client <- oauth_client(   provider = oauth_provider_github(),   client_id = Sys.getenv(\"GITHUB_OAUTH_CLIENT_ID\"),   client_secret = Sys.getenv(\"GITHUB_OAUTH_CLIENT_SECRET\"),   redirect_uri = \"http://127.0.0.1:8100\" )  # Have a valid OAuthToken object; fake example below # (typically provided by `oauth_module_server()` or `handle_callback()`) token <- handle_callback(client, \"<code>\", \"<payload>\", \"<browser_token>\")  # Get userinfo user_info <- get_userinfo(client, token)  # Introspect token (if supported by provider) introspection <- introspect_token(client, token)  # Refresh token new_token <- refresh_token(client, token, introspect = TRUE) } # }"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/revoke_token.html","id":null,"dir":"Reference","previous_headings":"","what":"Revoke an OAuth 2.0 token — revoke_token","title":"Revoke an OAuth 2.0 token — revoke_token","text":"Attempts revoke access refresh token using RFC 7009 provider exposes revocation endpoint. Authentication mirrors provider's token_auth_style (token exchange introspection). Best-effort semantics: provider expose revocation endpoint, returns supported = FALSE, revoked = NA, status = \"revocation_unsupported\". selected token value missing, returns supported = TRUE, revoked = NA, status = \"missing_token\". endpoint returns 2xx, returns supported = TRUE, revoked = TRUE, status = \"ok\". endpoint returns HTTP error, returns supported = TRUE, revoked = NA, status = \"http_<code>\".","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/revoke_token.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Revoke an OAuth 2.0 token — revoke_token","text":"","code":"revoke_token(   oauth_client,   oauth_token,   which = c(\"refresh\", \"access\"),   async = FALSE,   shiny_session = NULL )"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/revoke_token.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Revoke an OAuth 2.0 token — revoke_token","text":"oauth_client OAuthClient object oauth_token OAuthToken object containing tokens revoke token revoke: \"refresh\" (default) \"access\" async Logical, default FALSE. TRUE mirai::mirai package available, operation performed main R session using mirai::mirai() function returns mirai (implements .promise()) resolves result list. Requires mirai daemons configured mirai::daemons(). shiny_session Optional pre-captured Shiny session context (capture_shiny_session_context()) include audit events. Used calling async workers lack access reactive domain.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/revoke_token.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Revoke an OAuth 2.0 token — revoke_token","text":"list fields: supported, revoked, status","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/shinyOAuth-package.html","id":null,"dir":"Reference","previous_headings":"","what":"shinyOAuth: Provider-Agnostic OAuth Authentication for 'shiny' Applications — shinyOAuth-package","title":"shinyOAuth: Provider-Agnostic OAuth Authentication for 'shiny' Applications — shinyOAuth-package","text":"Provides simple, configurable, provider-agnostic 'OAuth 2.0' 'OpenID Connect' (OIDC) authentication framework 'shiny' applications using 'S7' classes. Defines providers, clients, tokens, well various supporting functions 'shiny' module. Features include cross-site request forgery (CSRF) protection, state encryption, 'Proof Key Code Exchange' (PKCE) handling, validation OIDC identity tokens (nonces, signatures, claims), automatic user info retrieval, asynchronous flows, hooks audit logging.","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/reference/shinyOAuth-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"shinyOAuth: Provider-Agnostic OAuth Authentication for 'shiny' Applications — shinyOAuth-package","text":"Maintainer: Luka Koning koningluka@gmail.com [copyright holder]","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_payload_decrypt_validate.html","id":null,"dir":"Reference","previous_headings":"","what":"Decrypt and validate OAuth state payload — state_payload_decrypt_validate","title":"Decrypt and validate OAuth state payload — state_payload_decrypt_validate","text":"Internal utility decrypts encrypted state payload using client's state_key, validates freshness client binding.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_payload_decrypt_validate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decrypt and validate OAuth state payload — state_payload_decrypt_validate","text":"","code":"state_payload_decrypt_validate(client, encrypted_payload, shiny_session = NULL)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_payload_decrypt_validate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Decrypt and validate OAuth state payload — state_payload_decrypt_validate","text":"client OAuthClient instance encrypted_payload Encrypted state payload string received via state query parameter. shiny_session Optional pre-captured Shiny session context (capture_shiny_session_context()) include audit events. Used calling async workers lack access reactive domain.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_payload_decrypt_validate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Decrypt and validate OAuth state payload — state_payload_decrypt_validate","text":"named list payload (state, client_id, redirect_uri, scopes, provider, issued_at) success; otherwise throws error via err_invalid_state().","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_store_get_remove.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch and remove the single-use state entry — state_store_get_remove","title":"Fetch and remove the single-use state entry — state_store_get_remove","text":"Retrieves state-bound values client's state_store removes entry enforce single-use semantics.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_store_get_remove.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch and remove the single-use state entry — state_store_get_remove","text":"","code":"state_store_get_remove(client, state, shiny_session = NULL)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_store_get_remove.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch and remove the single-use state entry — state_store_get_remove","text":"client OAuthClient instance state Plain (decrypted) state string used logical key shiny_session Optional pre-captured Shiny session context (capture_shiny_session_context()) include audit events. Used calling async workers lack access reactive domain.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/state_store_get_remove.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch and remove the single-use state entry — state_store_get_remove","text":"list browser_token, pkce_code_verifier, nonce. Throws error via err_invalid_state() retrieval removal fails, retrieved value missing/malformed.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/use_shinyOAuth.html","id":null,"dir":"Reference","previous_headings":"","what":"Add JavaScript dependency to the UI of a Shiny app — use_shinyOAuth","title":"Add JavaScript dependency to the UI of a Shiny app — use_shinyOAuth","text":"Adds package's client-side JavaScript helpers htmlDependency Shiny UI. enables features redirection setting browser cookie token. Without adding UI app,  oauth_module_server() function.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/use_shinyOAuth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add JavaScript dependency to the UI of a Shiny app — use_shinyOAuth","text":"","code":"use_shinyOAuth(inject_referrer_meta = TRUE)"},{"path":"https://lukakoning.github.io/shinyOAuth/reference/use_shinyOAuth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add JavaScript dependency to the UI of a Shiny app — use_shinyOAuth","text":"inject_referrer_meta TRUE (default), injects <meta name=\"referrer\" content=\"-referrer\"> tag document head. reduces risk leaking OAuth callback query parameters (like code state) via Referer header third-party subresources initial callback page load.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/use_shinyOAuth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add JavaScript dependency to the UI of a Shiny app — use_shinyOAuth","text":"tagList containing singleton dependency tag ensures JS file inst/www/shinyOAuth.js loaded","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/reference/use_shinyOAuth.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add JavaScript dependency to the UI of a Shiny app — use_shinyOAuth","text":"Place near top-level UI (e.g., inside fluidPage() tagList()), similar use shinyjs::useShinyjs().","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/reference/use_shinyOAuth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add JavaScript dependency to the UI of a Shiny app — use_shinyOAuth","text":"","code":"ui <- shiny::fluidPage(   use_shinyOAuth(),   # ... )"},{"path":"https://lukakoning.github.io/shinyOAuth/news/index.html","id":"shinyoauth-development-version","dir":"Changelog","previous_headings":"","what":"shinyOAuth (development version)","title":"shinyOAuth (development version)","text":"Mirai async backend improvements: Detect active daemons via mirai::daemons_set() instead mirai::info()/mirai::status() (requires mirai >= 2.3.0). Per-task timeout via options(shinyOAuth.async_timeout) (milliseconds); timed-mirai tasks automatically cancelled dispatcher. Async audit events now include mirai_error_type field. Prevent ‘mirai’ warning spam ‘stats’ maybe available workers. Reduce serialization overhead towards async workers using certain functions package namespace directly. OAuth callback error responses (?error=...) now require valid state parameter. Missing/invalid/consumed state treated properly invalid_state error instead surfacing error ?error=... (set attacker). Stricter URL validation: OAuthClient now rejects redirect URIs containing fragments (RFC 6749 §3.1.2), oauth_provider_oidc_discover() rejects issuer identifiers containing query fragment components. oauth_module_server(): also apply OAuth callback query cleanup early return paths internal function .process_query(), ensuring consistent cleanup.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/news/index.html","id":"shinyoauth-030","dir":"Changelog","previous_headings":"","what":"shinyOAuth 0.3.0","title":"shinyOAuth 0.3.0","text":"CRAN release: 2026-01-30 Async backend: default async backend now ‘mirai’ (>= 2.0.0) simpler efficient asynchronous execution. Use mirai::daemons() configure async workers. ‘future’ backend configured future::plan() still supported, ‘mirai’ takes precedence configured. Test suite: fixed inconsistent results several tests; tests suitable CRAN now skip CRAN. Silenced test output messages avoid confusion.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/news/index.html","id":"shinyoauth-020","dir":"Changelog","previous_headings":"","what":"shinyOAuth 0.2.0","title":"shinyOAuth 0.2.0","text":"CRAN release: 2026-01-13","code":""},{"path":[]},{"path":"https://lukakoning.github.io/shinyOAuth/news/index.html","id":"security-0-2-0","dir":"Changelog","previous_headings":"New/improved","what":"Security","title":"shinyOAuth 0.2.0","text":"Token revocation: tokens can now revoked Shiny session ends. Enable via revoke_on_session_end = TRUE oauth_module_server(). provider must expose revocation_url (auto-discovered OIDC, set manually via oauth_provider()). New exported function revoke_token(). Token introspection login: validate tokens via provider’s introspection endpoint login. Configure via introspect introspect_elements properties OAuthClient. provider must expose introspection_url (auto-discovered OIDC, set manually via oauth_provider()). DoS protection: callback query parameters state payload/browser token sizes validated expensive operations (e.g., hashing audit logs). Maximum size may configured via options(); see section ‘Size caps’ vignette(\"usage\", package = \"shinyOAuth\"). DoS protection: rate-limited JWKS refresh: forced JWKS cache refreshes (triggered unknown kid) now rate-limited prevent abuse. JWKS pinning: pinning now enforced signature verification: previously, jwks_pins jwks_pin_mode = \"\" verified least one key JWKS matched pin, signature verification still use matching key (pinned ). Now, signature verification restricted use keys whose thumbprints appear pin list, ensuring true key pinning rather presence-checks. use_shinyOAuth() now injects <meta name=\"referrer\" content=\"-referrer\"> default reduce leaking ?code=…&state=… via Referer header callback page. Can disabled use_shinyOAuth(inject_referrer_meta = FALSE). Sensitive outbound HTTP requests (token exchange/refresh, introspection, revocation, userinfo, OIDC discovery, JWKS) now default disable redirect following reject 3xx responses prevent bypassing host/HTTPS policies. Configurable via options(shinyOAuth.allow_redirect = TRUE). client_bearer_req() also gains follow_redirect, defaults FALSE, similarly control redirect behavior requests using bearer tokens. State now also consumed login failure paths (provider returns error also state). Callback URL parameters now also cleared login failure paths. OAuthProvider now requires absolute URLs (scheme + hostname) endpoint URLs. Provider fingerprint now includes userinfo_url introspection_url, reducing risk misconfiguration multiple providers share endpoints. state_payload_max_age property OAuthClient independent freshness validation state payload’s issued_at timestamp. Default client assertion JWT TTL reduced 5 minutes 120 seconds, reducing window replay attacks allowing clock skew.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/news/index.html","id":"auditing-0-2-0","dir":"Changelog","previous_headings":"New/improved","what":"Auditing","title":"shinyOAuth 0.2.0","text":"New audit events: session_ended (logged Shiny session close), authenticated_changed (logged authentication status changes), token_introspection (introspect_token() used), token_revocation (revoke_token() used), error_state_consumed error_state_consumption_failed (called provider returns error callback handling state attempted consumed). audit events now include $process_id, $is_async, $main_process_id (called async worker); fields help identify process generated event whether async worker. Async workers now also properly propagate audit hooks main process (see ‘Fixed’). Audit event login_success now includes sub_source indicate whether subject digest came userinfo, id_token (verified), id_token_unverified. Audit digest keying: audit/event digests (e.g., sub_digest, browser_token_digest) now default HMAC-SHA256 auto-generated per-process key reduce reidentification/correlation risk logs leak. Configure key options(shinyOAuth.audit_digest_key = \"...\"), disable keying (legacy deterministic SHA-256) options(shinyOAuth.audit_digest_key = FALSE). HTTP log sanitization: sensitive data HTTP contexts (headers, cookies) now sanitized default audit logs. Can disabled options(shinyOAuth.audit_redact_http = FALSE). Use options(shinyOAuth.audit_include_http = FALSE) include HTTP data logs.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/news/index.html","id":"ux-0-2-0","dir":"Changelog","previous_headings":"New/improved","what":"UX","title":"shinyOAuth 0.2.0","text":"Configurable scope validation: validate_scopes property OAuthClient controls whether returned scopes validated requested scopes (\"strict\", \"warn\", \"none\"). Scopes now normalized (alphabetically sorted) comparison. OAuthProvider: extra parameters now blocked overriding reserved keys essential OAuth 2.0/OIDC flow. Reserved keys may explicitly overridden via options(shinyOAuth.unblock_auth_params = c(...), shinyOAuth.unblock_token_params = c(...), shinyOAuth.unblock_token_headers = c(...)). also validated early parameters named, catching configuration errors sooner. Added warning negative expires_in values token responses. Added warning OAuthClient instantiated inside Shiny session; may cause sealed state payload decryption fail random secret generated upon client creation. Added hints error messages sealed state payload decryption fails. Ensured clearer error message token response unexpected format. Ensured clearer error retrieved state store entry unexpected format. Ensured clearer error message retrieved userinfo parsed JSON. Immediate error OAuthProvider uses HS* algorithm options(shinyOAuth.allow_hs = TRUE) enabled; also immediate error OAuthProvider uses HS* algorithm ID token verification can happen client_secret absent weak. build_auth_url() now uses package-typed errors (err_invalid_state()) instead generic stopifnot() assertions, ensuring consistent error handling audit logging.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/news/index.html","id":"other-0-2-0","dir":"Changelog","previous_headings":"New/improved","what":"Other","title":"shinyOAuth 0.2.0","text":"ID token signature/claims validation now occurs fetching userinfo. ensures cryptographic validation passes making external calls userinfo endpoint. fetching JWKS, key_ops present keys, keys key_ops including \"verify\" considered. oauth_provider() now defaults allowed_token_types c(\"Bearer\") providers. prevents accidentally misusing non-Bearer tokens (e.g., DPoP, MAC) Bearer tokens. Set allowed_token_types = character() opt . Token type also now validated calling userinfo endpoint. client_assertion_audience property OAuthClient allows overriding JWT audience claim client assertion authentication.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/news/index.html","id":"fixed-0-2-0","dir":"Changelog","previous_headings":"","what":"Fixed","title":"shinyOAuth 0.2.0","text":"Package now correctly requires httr2 >= 1.1.0. authenticated now flips FALSE promptly token expires reauth_after_seconds elapses, even without reactive changes. Previously, value remain TRUE past expiry unrelated reactive update triggered re-evaluation. HTTP error responses (4xx/5xx) now correctly returned caller immediately instead misclassified transport errors retried. Async worker options propagation: R options now automatically propagated async workers using async = TRUE. Previously, options set main process (including audit_hook, trace_hook, HTTP settings, custom options) available future::multisession workers. oauth_provider_microsoft(): fixed incorrect default blocked multi-tenant configuration. oauth_provider_oidc_discover(): stricter host matching; ? * wildcards now correctly handled. Fixed potential auto-redirect loop authentication error surfaced. Fixed potential race condition proactive refresh expiry watcher: expiry watcher now defers clearing token triggering reauthentication refresh progress. Token expiry handling token refresh now aligns handled login. State payload issued_at validation now applies clock drift leeway (OAuthProvider@leeway / shinyOAuth.leeway option), consistent ID token iat check.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/news/index.html","id":"shinyoauth-014","dir":"Changelog","previous_headings":"","what":"shinyOAuth 0.1.4","title":"shinyOAuth 0.1.4","text":"CRAN release: 2025-11-24 Added console warning needing access Shiny apps oauth_module_server() regular browser; also updated examples vignettes clarify . oauth_module_server(): improved formatting style warning messages (now consistent error messages).","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/news/index.html","id":"shinyoauth-013","dir":"Changelog","previous_headings":"","what":"shinyOAuth 0.1.3","title":"shinyOAuth 0.1.3","text":"CRAN release: 2025-11-10 Rewrote vignette(\"authentication-flow\") improve clarity. Skip timing-sensitive tests CRAN.","code":""},{"path":"https://lukakoning.github.io/shinyOAuth/news/index.html","id":"shinyoauth-011","dir":"Changelog","previous_headings":"","what":"shinyOAuth 0.1.1","title":"shinyOAuth 0.1.1","text":"CRAN release: 2025-11-09 Initial CRAN submission.","code":""}]

<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Authentication flow • shinyOAuth</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Authentication flow">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">shinyOAuth</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.2.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/audit-logging.html">Audit logging and hooks</a></li>
    <li><a class="dropdown-item" href="../articles/authentication-flow.html">Authentication flow</a></li>
    <li><a class="dropdown-item" href="../articles/example-spotify.html">Example: Spotify login to display listening data</a></li>
    <li><a class="dropdown-item" href="../articles/usage.html">Usage</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/lukakoning/shinyOAuth/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Authentication flow</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/lukakoning/shinyOAuth/blob/master/vignettes/authentication-flow.Rmd" class="external-link"><code>vignettes/authentication-flow.Rmd</code></a></small>
      <div class="d-none name"><code>authentication-flow.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="overview">Overview<a class="anchor" aria-label="anchor" href="#overview"></a>
</h2>
<p>This vignette provides a step-by-step description of what happens
during an authentication flow when using the
<code><a href="../reference/oauth_module_server.html">oauth_module_server()</a></code> Shiny module. It maps protocol
concepts (OAuth 2.0 Authorization Code + PKCE, OpenID Connect) to the
concrete implementation details in the package.</p>
<p>For a concise quick-start (minimal and manual button examples,
options, and security checklist) see:
<code><a href="../articles/usage.html">vignette("usage", package = "shinyOAuth")</a></code>.</p>
<p>For an explanation of logging key events during the flow, see:
<code><a href="../articles/audit-logging.html">vignette("audit-logging", package = "shinyOAuth")</a></code>.</p>
</div>
<div class="section level2">
<h2 id="what-happens-during-the-authentication-flow">What happens during the authentication flow?<a class="anchor" aria-label="anchor" href="#what-happens-during-the-authentication-flow"></a>
</h2>
<p>The package implements the OAuth 2.0 ‘Authorization Code’ flow and
optional ‘OpenID Connect’ (OIDC) checks end‑to‑end. Below is the
sequence of operations and the rationale behind each step.</p>
<div class="section level3">
<h3 id="first-page-load-set-a-browser-token">1. First page load: set a browser token<a class="anchor" aria-label="anchor" href="#first-page-load-set-a-browser-token"></a>
</h3>
<p>On the first load of your app, the module sets a small random cookie
in the user’s browser (SameSite=Strict; Secure when over HTTPS). This
browser token is mirrored to Shiny as an input. Its purpose is to ensure
that the same browser that starts the OAuth 2.0 flow is the one that
finishes it (a “double-submit” style CSRF defense).</p>
</div>
<div class="section level3">
<h3 id="decide-whether-to-start-login">2. Decide whether to start login<a class="anchor" aria-label="anchor" href="#decide-whether-to-start-login"></a>
</h3>
<p>If <code>oauth_module_server(auto_redirect = TRUE)</code>, an
unauthenticated session triggers immediate redirection to the provider
authorization endpoint.</p>
<p>If <code>oauth_module_server(auto_redirect = FALSE)</code>, you
manually call <code>$request_login()</code> (e.g., via a button) to do
so.</p>
</div>
<div class="section level3">
<h3 id="build-the-authorization-url-prepare_call">3. Build the authorization URL (<code>prepare_call()</code>)<a class="anchor" aria-label="anchor" href="#build-the-authorization-url-prepare_call"></a>
</h3>
<p>To redirect the user to the provider, the module constructs an
authorization request URL. The URL is built from the provider’s
authorization endpoint and includes various query parameters to ensure
security and proper context tracking:</p>
<ul>
<li>State: this is a high-entropy random string to prevent CSRF; this
package seals the state to enhance security (see below)</li>
<li>PKCE: a <code>code_verifier</code> (random) and
<code>code_challenge</code> (S256 hash) proving the same party finishes
the flow</li>
<li>Nonce (OIDC): random string echoed back in the ID token, mitigating
replay attacks</li>
</ul>
<p>This package seals the state, meaning it encrypts and authenticates
(AES-GCM AEAD) a payload containing:</p>
<ul>
<li>state, client_id, redirect_uri</li>
<li>requested scopes</li>
<li>provider fingerprint (issuer/auth/token URLs)</li>
<li>issued_at timestamp</li>
</ul>
<p>Sealing the state prevents tampering, stale callbacks, and mix-ups
with other providers/clients.</p>
<p>On the server side, the package will store the sealed state (as a
cache-safe hash key) in the state store (e.g., a ‘cachem’ backend) along
with the following data:</p>
<ul>
<li>browser token</li>
<li>code_verifier</li>
<li>nonce (OIDC)</li>
</ul>
<p>All this data will be used for validation during the callback
processing.</p>
</div>
<div class="section level3">
<h3 id="app-redirects-to-the-provider">4. App redirects to the provider<a class="anchor" aria-label="anchor" href="#app-redirects-to-the-provider"></a>
</h3>
<p>The browser of the app user will be redirected to the provider’s
authorization endpoint with the following parameters:
<code>response_type=code</code>, <code>client_id</code>,
<code>redirect_uri</code>, <code>state=&lt;sealed state&gt;</code>, PKCE
parameters, <code>nonce</code> (OIDC), <code>scope</code>, plus any
configured extra parameters.</p>
</div>
<div class="section level3">
<h3 id="user-authenticates-and-authorizes">5. User authenticates and authorizes<a class="anchor" aria-label="anchor" href="#user-authenticates-and-authorizes"></a>
</h3>
<p>Once at the provider’s authorization page, the user is prompted to
log in and authorize the app to access the requested scopes.</p>
</div>
<div class="section level3">
<h3 id="provider-redirects-user-back-to-the-app">6. Provider redirects user back to the app<a class="anchor" aria-label="anchor" href="#provider-redirects-user-back-to-the-app"></a>
</h3>
<p>The provider redirects the user’s browser back to your Shiny app
(your <code>redirect_uri</code>), including the <code>code</code> and
<code>state</code> parameters (and optionally <code>error</code> and
<code>error_description</code> on failure).</p>
</div>
<div class="section level3">
<h3 id="callback-processing-state-verification-handle_callback">7. Callback processing &amp; state verification
(<code>handle_callback()</code>)<a class="anchor" aria-label="anchor" href="#callback-processing-state-verification-handle_callback"></a>
</h3>
<p>Once the user is redirected back to the app, the module processes the
callback. This consists of the following steps:</p>
<ul>
<li>Wait for the browser token input if not yet visible</li>
<li>Decrypt and verify the sealed state, ensuring integrity,
authenticity, and freshness (using the <code>issued_at</code>
window)</li>
<li>Check that embedded context matches expected client/provider
(defends against misconfiguration/multi-tenant mix-ups)</li>
<li>Fetch and immediately delete the one-time state entry from the
configured state store
<ul>
<li>If the entry is missing, malformed, or deletion fails, the flow
aborts with a <code>shinyOAuth_state_error</code>
</li>
<li>Audit events are emitted on failures (e.g.,
<code>state_store_lookup_failed</code>,
<code>state_store_removal_failed</code>)</li>
</ul>
</li>
<li>Verify that user’s browser token matches the previously stored
browser token</li>
<li>Ensure PKCE components are available when required</li>
</ul>
<p>Note: in asynchronous token exchange mode, the module may pre‑decrypt
the sealed state and prefetch plus remove the state store entry on the
main thread before handing work to the async worker, preserving the same
single‑use and strict failure behavior.</p>
</div>
<div class="section level3">
<h3 id="exchange-authorization-code-for-tokens">8. Exchange authorization code for tokens<a class="anchor" aria-label="anchor" href="#exchange-authorization-code-for-tokens"></a>
</h3>
<p>Once the callback is verified, the module proceeds to exchange the
authorization code for tokens.</p>
<p>A POST request is made to the token endpoint with
<code>grant_type=authorization_code</code>, the code, the redirect_uri,
and the <code>code_verifier</code> (PKCE). Client authentication method
depends on provider style: HTTP Basic header
(<code>client_secret_basic</code>), body params
(<code>client_secret_post</code>), or JWT-based assertions
(<code>client_secret_jwt</code>, <code>private_key_jwt</code>) when
configured. The response must include at least
<code>access_token</code>. Malformed or error responses abort the
flow.</p>
<p>When successful, the package also applies two safety rails:</p>
<ul>
<li>If the token response includes <code>scope</code>, shinyOAuth can
reconcile it against the requested scopes (defaults to strict
enforcement; configurable via the client <code>scope_validation</code>
setting)</li>
<li>If the provider was configured with a non-empty
<code>allowed_token_types</code>, the token response must include
<code>token_type</code> and its value must be one of the allowed types
(case-insensitive, e.g., <code>Bearer</code>)</li>
</ul>
</div>
<div class="section level3">
<h3 id="fetch-userinfo-optional">9. Fetch userinfo (optional)<a class="anchor" aria-label="anchor" href="#fetch-userinfo-optional"></a>
</h3>
<p>If userinfo is requested via
<code>oauth_provider(userinfo_required = TRUE)</code> (for which you
should have a <code>userinfo_url</code> configured), the module calls
the userinfo endpoint with the access token and stores returned claims.
If this request fails, the flow aborts with an error.</p>
</div>
<div class="section level3">
<h3 id="validate-id-token-oidc-only">10. Validate ID token (OIDC only)<a class="anchor" aria-label="anchor" href="#validate-id-token-oidc-only"></a>
</h3>
<p>When using <code>oauth_provider(id_token_validation = TRUE)</code>,
the following verifications are performed:</p>
<ul>
<li>Signature: verified against provider JWKS (with optional pinning)
for standard asymmetric algorithms (RSA-PKCS1, RSA-PSS, ECDSA, EdDSA).
HMAC algorithms (HS256/384/512) are only allowed with explicit opt-in
(<code>options(shinyOAuth.allow_hs = TRUE)</code>) and a sufficiently
strong server-held secret</li>
<li>Claims: <code>iss</code> matches expected issuer; <code>aud</code>
vector contains <code>client_id</code>; <code>sub</code> present;
<code>iat</code> is required and must be a single finite numeric;
time-based claims (<code>exp</code> is required, <code>nbf</code>
optional) are evaluated with a small configurable leeway; tokens issued
in the future are rejected</li>
<li>Header <code>typ</code> (when present): must indicate a JWT
(<code>JWT</code>, case-insensitive). Other values (e.g.,
<code>at+jwt</code>) are rejected for ID tokens</li>
<li>Nonce: must match the previously stored value (if configured)</li>
<li>Subject match: if
<code>oauth_provider(userinfo_id_token_match = TRUE)</code>, it is
checked that <code>sub</code> in userinfo equals <code>sub</code> in the
ID token</li>
</ul>
</div>
<div class="section level3">
<h3 id="token-introspection-optional">11. Token introspection (optional)<a class="anchor" aria-label="anchor" href="#token-introspection-optional"></a>
</h3>
<p>Some providers support RFC 7662 token introspection (an additional
endpoint where the server can ask the provider whether an access token
is currently active and retrieve related metadata).</p>
<p>If you enable <code>introspect = TRUE</code> when creating your
<code><a href="../reference/oauth_client.html">oauth_client()</a></code>, the module calls the provider’s
introspection endpoint during callback processing and requires the
response to indicate <code>active = TRUE</code>. If introspection is
unsupported by the provider or the introspection request fails, the
login is aborted and <code>$authenticated</code> is not set to
<code>TRUE</code>.</p>
<p>You can optionally enforce additional provider-dependent fields via
<code>oauth_client(introspect_elements = ...)</code>:</p>
<ul>
<li>
<code>"sub"</code> – require introspection <code>sub</code> to match
the session subject</li>
<li>
<code>"client_id"</code> – require introspection
<code>client_id</code> to match your OAuth client id</li>
<li>
<code>"scope"</code> – validate introspection <code>scope</code>
against requested scopes (respects the client’s
<code>scope_validation</code> mode)</li>
</ul>
<p>(Note that not all providers may return each of these fields in
introspection responses.)</p>
</div>
<div class="section level3">
<h3 id="build-the-oauthtoken-object">12. Build the <code>OAuthToken</code> object<a class="anchor" aria-label="anchor" href="#build-the-oauthtoken-object"></a>
</h3>
<p>Now that all verifications have passed, the module builds the final
token object. This is an S7 <code>OAuthToken</code> object which
contains:</p>
<ul>
<li>
<code>access_token</code> (string)</li>
<li>
<code>refresh_token</code> (optional string)</li>
<li>
<code>expires_at</code> (numeric timestamp, seconds since epoch;
<code>Inf</code> for non-expiring tokens)</li>
<li>
<code>id_token</code> (optional string)</li>
<li>
<code>userinfo</code> (optional list)</li>
</ul>
<p>The <code>$authenticated</code> value as returned by
<code><a href="../reference/oauth_module_server.html">oauth_module_server()</a></code> now becomes TRUE, meaning all
requested verifications have passed.</p>
</div>
<div class="section level3">
<h3 id="clean-url-tidy-ui-clear-browser-token">13. Clean URL &amp; tidy UI; clear browser token<a class="anchor" aria-label="anchor" href="#clean-url-tidy-ui-clear-browser-token"></a>
</h3>
<p>The user’s browser was redirected to your app with OAuth 2.0 query
parameters (<code>code</code>, <code>state</code>, etc.). To improve UX
and avoid leaking sensitive data, these values are removed from the
address bar with JavaScript. Optionally, the page title may also be
adjusted (see the <code>tab_title_</code> arguments in
<code><a href="../reference/oauth_module_server.html">oauth_module_server()</a></code>).</p>
<p>The browser token cookie is also cleared and immediately re-issued
with a fresh value, so a future flow can start with a new per-session
token.</p>
</div>
<div class="section level3">
<h3 id="post-flow-session-management">14. Post-flow session management<a class="anchor" aria-label="anchor" href="#post-flow-session-management"></a>
</h3>
<p>Now that the flow is complete, the module will manage the token
lifetime during the active session. This may consist of:</p>
<ul>
<li>Proactive refresh: if enabled and a refresh token exists, the access
token is refreshed before expiry</li>
<li>Expiration: expired tokens are cleared automatically, setting the
<code>$authenticated</code> flag to FALSE</li>
<li>Re-authentication: optionally,
<code>oauth_module_server(reauth_after_seconds = ...)</code> can force
periodic re-authentication</li>
</ul>
<div class="section level4">
<h4 id="refresh-behavior-refresh_token">Refresh behavior (<code>refresh_token()</code>)<a class="anchor" aria-label="anchor" href="#refresh-behavior-refresh_token"></a>
</h4>
<p>When the module refreshes a session (or when you call
<code><a href="../reference/refresh_token.html">refresh_token()</a></code> directly), it performs an OAuth 2.0 refresh
token grant against the provider’s token endpoint and updates the
<code>OAuthToken</code> object. This works as follows:</p>
<ul>
<li>A token request is sent with <code>grant_type=refresh_token</code>
and the current <code>refresh_token</code>
</li>
<li>The response must include a new <code>access_token</code>.
<code>expires_at</code> is updated from <code>expires_in</code> when
present; otherwise it is set to <code>Inf</code>
</li>
<li>If the provider rotates the refresh token (returns a new
<code>refresh_token</code>), it is stored; otherwise the original is
preserved</li>
<li>If <code>oauth_provider(userinfo_required = TRUE)</code>, userinfo
is re-fetched using the fresh access token</li>
</ul>
<p>With respect to OIDC ID token handling:</p>
<ul>
<li>Per OIDC Core Section 12.2, refresh responses may omit
<code>id_token</code>. When omitted, the original <code>id_token</code>
from the initial login is preserved. Thus, a refresh does not
necessarily revalidate identity</li>
<li>If the provider does return an <code>id_token</code> during refresh,
shinyOAuth enforces OIDC 12.2 subject continuity: the refresh-returned
<code>id_token</code> must have the same <code>sub</code> as the
original <code>id_token</code> from login
<ul>
<li>If an original <code>id_token</code> did not exist in the session,
and the refresh does return one, the refresh fails (cannot establish
subject claim match with no baseline)</li>
<li>If <code>id_token_validation = TRUE</code>, the refresh-returned
<code>id_token</code> is fully validated (signature + claims); the
<code>sub</code> claim match is enforced as part of validation</li>
<li>If <code>id_token_validation = FALSE</code>, shinyOAuth still
enforces the <code>sub</code> match by parsing the JWT payload (ensuring
that the <code>sub</code> claim still matches but without full
validation)</li>
</ul>
</li>
</ul>
<p>If refresh fails inside <code><a href="../reference/oauth_module_server.html">oauth_module_server()</a></code>, the
module exposes the failure via its reactive state (for example,
<code>token_refresh_error</code>). By default it also clears the current
session token; if
<code>oauth_module_server(indefinite_session = TRUE)</code>, the token
is kept but marked stale. In all cases, the <code>$authenticated</code>
flag becomes <code>FALSE</code> while the error is present.</p>
</div>
</div>
<div class="section level3">
<h3 id="logout-and-token-revocation">15. Logout and token revocation<a class="anchor" aria-label="anchor" href="#logout-and-token-revocation"></a>
</h3>
<p>When <code>auth$logout()</code> is called, the module:</p>
<ol style="list-style-type: decimal">
<li>Attempts to revoke both refresh and access tokens at the provider
(RFC 7009) if a <code>revocation_url</code> is configured. This runs
asynchronously only when
<code>oauth_module_server(async = TRUE)</code>
</li>
<li>Clears the local session (<code>OAuthToken</code>, browser
cookie)</li>
<li>Emits a <code>"logout"</code> audit event</li>
<li>Re-issues a fresh browser token for subsequent logins</li>
</ol>
<p>You can also revoke tokens directly via
<code>revoke_token(client, token, which = "refresh")</code>.</p>
<p>To automatically attempt revocation when a Shiny session ends (for
example, a tab close or session timeout), set
<code>revoke_on_session_end = TRUE</code>:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">auth</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/oauth_module_server.html">oauth_module_server</a></span><span class="op">(</span></span>
<span>  <span class="st">"auth"</span>,</span>
<span>  client <span class="op">=</span> <span class="va">client</span>,</span>
<span>  revoke_on_session_end <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>This is best-effort: the session may end while the provider is
unavailable, and revocation failures do not block session cleanup.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Luka Koning.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer>
</div>





  </body>
</html>

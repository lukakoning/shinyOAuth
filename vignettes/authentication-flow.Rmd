---
title: "Authentication flow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Authentication flow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Overview

This vignette provides a step-by-step description of what happens during an authentication flow
when using the `oauth_module_server()` Shiny module. It maps protocol concepts (OAuth 2.0 Authorization Code + PKCE,
OpenID Connect) to the concrete implementation details in the package.

For a concise quick-start (minimal and manual button examples, options, and security checklist) see:
`vignette("usage", package = "shinyOAuth")`.

For an explanation of logging key events during the flow, see:
`vignette("audit-logging", package = "shinyOAuth")`.

## What happens during the authentication flow?

The package implements the OAuth 2.0 Authorization Code flow (with PKCE) and optional OpenID Connect checks end‑to‑end.
Below is the sequence of operations and the rationale behind each step.

### 1. First page load – set a browser token
On the first load of your app, the module sets a small random cookie in the user's browser (SameSite=Strict; Secure when over HTTPS).
This *browser token* is mirrored to Shiny as an input. It helps bind the start and end of the OAuth flow to the same browser
(a "double-submit" style CSRF defense) and prevents cross-tab confusion.

### 2. Decide whether to start login
If `auto_redirect = TRUE`, an unauthenticated session triggers immediate redirection.
If `auto_redirect = FALSE`, you manually call `auth$request_login()` (e.g., via a button) to begin the flow.

### 3. Build the authorization URL (`prepare_call`)
A secure authorization request requires multiple high-entropy and contextual elements:

- **state**: high-entropy random string to prevent CSRF; *sealed* before being sent
- **PKCE**: a `code_verifier` (random) and `code_challenge` (S256 hash) proving the same party finishes the flow
- **nonce** (OIDC): random string echoed back in the ID token, mitigating replay attacks
- **Server-side one-time state store**: keyed by the raw state; stores: browser token, code_verifier, nonce. Purged after callback
- **Sealed state payload**: Instead of sending raw state, the package seals (AES-GCM AEAD: encrypts + authenticates) a payload containing:
  - state, client_id, redirect_uri
  - requested scopes
  - provider fingerprint (issuer/auth/token URLs)
  - issued_at timestamp

This sealing thwarts tampering, stale callbacks, and mix-ups with other providers/clients.

### 4. Redirect to the provider
Browser navigates to the provider's authorization endpoint with parameters:
`response_type=code`, `client_id`, `redirect_uri`, `state=<sealed>`, PKCE parameters, `nonce` (OIDC), `scope`, plus configured extras.

### 5. Provider redirects back
Provider calls your `redirect_uri` with `code` and `state` (or `error`, `error_description` on failure).

### 6. Callback processing & state verification (`handle_callback`)
- Wait for the browser token input if not yet visible (page load race) before proceeding
- Decrypt + verify sealed state: integrity (auth tag), authenticity, and freshness (issued_at window)
- Check embedded context matches expected client/provider (defends against misconfiguration / multi-tenant mix-ups)
- Fetch and immediately delete the one-time state entry from the configured state store
  - Strict semantics: if the entry is missing, malformed, or deletion fails, the flow aborts with a `shinyOAuth_state_error`
  - Audit events are emitted on failures (e.g., `audit_state_store_lookup_failed`, `audit_state_store_removal_failed`) with redacted context
- Verify browser token equality with stored value
- Ensure PKCE components are available when required

Note: In asynchronous token exchange mode, the module may pre‑decrypt the sealed state and prefetch+remove the state store entry on the main thread before handing work to the async worker, preserving the same single‑use and strict failure behavior.

### 7. Exchange authorization code for tokens (back-channel)
A POST request is made to the token endpoint with `grant_type=authorization_code`, code, redirect_uri, and `code_verifier` (PKCE).
Client authentication method depends on provider style (`basic` header vs body params). Response must include at least `access_token`.
Malformed or error responses abort the flow. When successful, the package also applies two safety rails:

- If the token response includes `scope`, all scopes requested by the client must be present in the granted set; otherwise the flow fails fast to avoid downstream surprises.
- If the token response includes `token_type`, and the provider was configured with `allowed_token_types`, the
  `token_type` must be present in the response and be one fo the allowed types (e.g., `Bearer`). Failure aborts the flow.

### 8. (Optional) Fetch userinfo
If `userinfo_required = TRUE`, the module calls the userinfo endpoint with the access token and stores returned claims.
Failure aborts the flow.

### 9. (OIDC) Validate ID token
When `id_token_validation = TRUE`:
- **Signature**: Verified against provider JWKS (with optional thumbprint pinning) for RS256/ES256; HS256 only with explicit opt-in and server-held secret
- **Claims**: `iss` matches expected issuer; `aud` vector contains `client_id`; `sub` present; `iat` is REQUIRED and must be a single finite numeric; time-based claims (`exp` REQUIRED, `nbf` optional) are evaluated with a small configurable leeway; tokens issued in the future are rejected
- **Nonce**: If used, matches stored value
- **Subject match**: If `userinfo_id_token_match = TRUE`, ensure `sub` in userinfo equals ID token `sub`

### 10. Materialize the `OAuthToken`
Constructs an S7 `OAuthToken` capturing `access_token`, optional `refresh_token`, expiry time, `id_token`, `userinfo`, and verification results.
`auth$authenticated` becomes TRUE only after all requested verifications pass.

### 11. Clean URL & tidy UI
Removes OAuth query parameters (`code`, `state`, etc.) from the browser's address bar and optionally adjusts the page title.
Clears the browser token cookie to allow a fresh future flow.

### 12. Keeping the session alive
- **Proactive refresh**: If enabled and a refresh token exists, refresh before expiry.
- **Expiration & reauth**: Expired tokens are cleared. Optional `reauth_after_seconds` forces periodic re-authentication.

### 13. Errors, logging, and safety rails
- Structured errors surface short codes and (optionally) detailed descriptions (avoid exposing full descriptions to users)
- Host and HTTPS constraints enforced early
- State is single‑use and time‑limited; sealed state + cookie binding mitigate CSRF/state injection
- State store access is strict: lookup or removal failures cause the flow to abort with a `shinyOAuth_state_error` to prevent replay/mix‑up
- Hooks (`trace_hook`, `audit_hook`) provide structured telemetry without exposing raw tokens
